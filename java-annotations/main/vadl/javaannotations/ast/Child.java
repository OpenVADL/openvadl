// SPDX-FileCopyrightText : Â© 2025 TU Wien <vadl@tuwien.ac.at>
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package vadl.javaannotations.ast;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * The Child annotation indicates that this field is a child of this Node and is owned by it.
 * Identifiers are only children if they aren't used to identify the definition.
 *
 * <p>The Child annotaion should only be used on fieleds inside a Node and can only be used on
 * fields that are {@code Node} or {@code List<T extends Node>}.
 * Other more complex cases need custom handing and are not suited for this annotation.
 *
 * <p>Annotating with this annotaion will include the field in the NodeChildrenRegistry, which
 * is generated by the {@link ChildAnnotationProcessor}.
 *
 * <p>The NodeChildrenRegistry provides the {@code List<Node> getChildren(Node node)} which
 * returns all children of the provided Node.
 *
 * <p>The NodeChildrenRegistry will only have entries for classes that have at least one @Child
 * annotation. This means if a class inherits from another class that does have annotations but
 * itself doesn't have a Child annotation the registry will return an empty list. In those rare
 * cases the {@code List<Node> unsafeGetChildrenDirect(Node node, Class<? extends Node> nodeType)}
 * can be used provided with the node and the superclass you want to impersonate.
 */
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.FIELD)
public @interface Child {
}
