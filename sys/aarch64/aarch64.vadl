// SPDX-FileCopyrightText : Â© 2025 TU Wien <vadl@tuwien.ac.at>
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ARM AArch64 base instruction set

instruction set architecture AArch64Base = {

  constant SizeW = 32                 // size of W registers is 32
  constant SizeX = 64                 // size of X registers is 64

  using Byte     = Bits< 8>           // 8 bit Byte
  using Half     = Bits<16>           // 16 bit half word type
  using Word     = Bits<32>           // 32 bit word type
  using XWord    = Bits<64>           // 64 bit eXtendend (double) word type
  using Bits1    = Bits< 1>           //  1 bit type
  using Bits2    = Bits< 2>           //  2 bit type
  using Bits3    = Bits< 3>           //  3 bit type
  using Bits4    = Bits< 4>           //  4 bit type
  using Bits5    = Bits< 5>           //  5 bit type
  using Bits6    = Bits< 6>           //  6 bit type
  using Bits7    = Bits< 7>           //  7 bit type
  using Bits8    = Bits< 8>           //  8 bit type
  using Bits9    = Bits< 9>           //  9 bit type
  using Bits11   = Bits<11>           // 11 bit type
  using Bits12   = Bits<12>           // 12 bit type
  using Bits13   = Bits<13>           // 13 bit type
  using Bits14   = Bits<14>           // 14 bit type
  using Bits15   = Bits<15>           // 15 bit type
  using Bits16   = Bits<16>           // 16 bit type
  using Bits19   = Bits<19>           // 19 bit type
  using Bits21   = Bits<21>           // 21 bit type
  using Bits24   = Bits<24>           // 24 bit type
  using Bits25   = Bits<25>           // 25 bit type
  using Bits26   = Bits<26>           // 26 bit type
  using Bits27   = Bits<27>           // 27 bit type
  using Instr    = Word               // instruction are 32 bit wide
  using BitsW    = Bits<SizeW>        // Bits W register type
  using BitsX    = Bits<SizeX>        // Bits X register type
  using SIntW    = SInt<SizeW>        //   signed integer W sized
  using SIntX    = SInt<SizeX>        //   signed integer X sized
  using UIntW    = UInt<SizeW>        // unsigned integer W sized
  using UIntX    = UInt<SizeX>        // unsigned integer X sized
  using Index    = Bits5              // 5 bit register index type for 32 registers
  using Address  = BitsX              // address has X register type

  program counter PC: Address         // program counter

  memory        MEM : Address -> Byte // byte addressed memory
 
  register        S : Index -> BitsX  // general purpose register file with stack pointer
  [zero : X(31)]                      // X(31) is the zero register
  alias register  X = S               // general purpose register file with zero register
  alias register SP : Address = S(31) // stack pointer
  alias register LR : Address = S(30) // link register (return address)

  register NZCV_N : Bits1             // Negative
  register NZCV_Z : Bits1             // Zero
  register NZCV_C : Bits1             // Carry
  register NZCV_V : Bits1             // oVerflow

  enumeration CondCode : Bits<4> =    // condition code encodings, do not change order
    { EQ                              // EQual                    Z == 1
    , NE                              // Not Equal                Z == 0
    , CS                              // Carry Set                C == 1    HS unsigned Higher or Same
    , CC                              // Carry Clear              C == 0    LO unsigned LOwer
    , MI                              // MInus                    N == 1
    , PL                              // PLus                     N == 0
    , VS                              // oVerflow Set             V == 1
    , VC                              // oVerflow Clear           V == 0
    , HI                              // unsigned HIgher          C == 1 and Z == 0
    , LS                              // unsigned Lower or Same   C == 0  or Z == 1
    , GE                              // signed Greater or Equal  N == V
    , LT                              // signed Less Than         N != V
    , GT                              // signed Greater Than      N == V and Z == 0
    , LE                              // signed Less or Equal     N != V  or Z == 1
    , AL                              // ALways true
    , NV                              // NeVer, Not aVailable, reserved, gives true
    }

  function conditionHolds (cond: Bits<4>) -> Bool = // evaluate condition code
    match cond with
      { CondCode::EQ => NZCV_Z  = 1
      , CondCode::NE => NZCV_Z  = 0
      , CondCode::CS => NZCV_C  = 1
      , CondCode::CC => NZCV_C  = 0
      , CondCode::MI => NZCV_N  = 1
      , CondCode::PL => NZCV_N  = 0
      , CondCode::VS => NZCV_V  = 1
      , CondCode::VC => NZCV_V  = 0
      , CondCode::HI => NZCV_C  = 1 && NZCV_Z = 0
      , CondCode::LS => NZCV_C  = 0 || NZCV_Z = 1
      , CondCode::GE => NZCV_N  = NZCV_V
      , CondCode::LT => NZCV_N != NZCV_V
      , CondCode::GT => NZCV_N  = NZCV_V && NZCV_Z = 0
      , CondCode::LE => NZCV_N != NZCV_V || NZCV_Z = 1
      , _            => true
      }

  enumeration SF: Bits1 =             // size field values and assembly function name, do not rename elements or change order
    { WSize                           // 32 bit operation or W register names
    , XSize                           // 64 bit operation or X register names
    }

  enumeration Size =                  // bit size values for operation size, do not rename elements
    { WSize = SizeW                   // 32 is size for WSize operations
    , XSize = SizeX                   // 64 is size for XSize operations
    }

  enumeration ShiftSize =             // shift size values for operation size, do not rename elements
    { WSize = 5                       // 5 is size for WSize shift immediate values
    , XSize = 6                       // 6 is size for XSize shift immediate values
    }

  enumeration FF: Bits1 =             // flag field values, do not change order
    { OffFlags                        // flag setting is off
    , SetFlags                        // operation sets flags
    }

  enumeration ShiftType : Bits2 =     // register operand shift type, do not change order
    { LSL                             // Logical Shift Left
    , LSR                             // Logical Shift Right
    , ASR                             // Arithmetic Shift Right
    , ROR                             // ROtate Right
    }

  enumeration ExtendType : Bits3 =    // register operand extend type, do not change order
    { UXTB                            // Unsigned eXTend Byte
    , UXTH                            // Unsigned eXTend Half
    , UXTW                            // Unsigned eXTend Word
    , UXTX                            // Unsigned eXTend Xword
    , SXTB                            // Signed   eXTend Byte
    , SXTH                            // Signed   eXTend Half
    , SXTW                            // Signed   eXTend Word
    , SXTX                            // Signed   eXTend Xword
    }


// assembly string functions ***************************************************

  // assembly W register names or zero
  function WSize (idx: Index) -> String =   // do not rename
    if idx = 31 then "wzr" else "w" + decimal( idx )

  // assembly X register names or zero
  function XSize (idx: Index) -> String =   // do not rename
    if idx = 31 then "xzr"  else "x" + decimal( idx )

  // assembly W register names or sp
  function WSizeSP (idx: Index) -> String = // do not rename
    if idx = 31 then "wsp" else "w" + decimal( idx )

  // assembly X register names or sp
  function XSizeSP (idx: Index) -> String = // do not rename
    if idx = 31 then "sp"  else "x" + decimal( idx )

  function Imm7decimal  (imm: Bits7)  -> String =
    if imm = 0 then "" else (", #", decimal( imm ))

  function Imm9decimal  (imm: Bits9)  -> String =
    if imm = 0 then "" else (", #", decimal( imm ))

  function Imm12decimal (imm: Bits12) -> String =
    if imm = 0 then "" else (", #", decimal( imm ))

// syntax records and model types **********************************************

  // instruction id, mnemonic, opcode as literal or enum
  record InstrNoFunct (id: Id, mnemo: Str, opcode: Ex)

  // instruction id, mnemonic, opcode as literal or enum, function or type name
  record InstrWithFunct (id: Id, mnemo: Str, opcode: Ex, funct: Id)

  // condition code id, mnemonic extension, condition expression
  record Cond (cc: Id, mext: Str, ex: Ex)

  // register shift expression, encoding elements, assembly string expression
  record RegShift (ex: Ex, enc: Encs, asm: Ex)

  // register size (WSize, XSize), access size (Byte, Half, Word, XWord), 
  // mnemonic extension ("b", "sb", "h", "sh", "sw"), opc, memory statement
  record Memory  (regsize: Id, accsize: Id, mext: Str, opc: Lit, stmt: Stat)

  // higher order model for simple flag setting models
  model-type NoSetFlags = () -> Stats

  // higher order model for flag setting models
  model-type SetResultFlags = (CallEx, Ex) -> Stats

  // result model, OffFlags or SetFlags, mnemonic extension ("" or "s")
  record Flags  (resModel: SetResultFlags, ff: Id, mext: Str)

  // higher order model enriched with size: [WX]Size, flags
  model-type InstrWithFunctSizeFlags = (InstrWithFunct, Id, Flags) -> IsaDefs

  // higher order model enriched with size: [WX]Size, shifted register
  model-type InstrWithFunctSizeRegShift = (InstrWithFunct, Id, RegShift) -> IsaDefs

  // higher order model enriched with operation size
  model-type InstrWithFunctSize = (InstrWithFunct, Id) -> IsaDefs

  // higher order model enriched with condition
  model-type InstrWithCond = (InstrWithFunct, Cond) -> IsaDefs

  // higher order model enriched with memory
  model-type MemoryModel = (InstrNoFunct, Memory) -> IsaDefs


// models for setting flags ****************************************************

  // set no flags
  model NoFlags (): Stats = {}

  // set all flags
  model SetFlags (): Stats = {
    NZCV_N := flags.negative
    NZCV_Z := flags.zero
    NZCV_C := flags.carry
    NZCV_V := flags.overflow
    }

  // set NZ flags, clear CV flags
  model SetNZClearCVFlags (): Stats = {
    NZCV_N := flags.negative
    NZCV_Z := flags.zero
    NZCV_C := false
    NZCV_V := false
    }

  // assigns zero extended word result to destination expression
  model WResult (dest: CallEx, result: Ex): Stats = {
    $dest := ($result) as BitsW as BitsX
    }

  // assigns result to destination expression
  model XResult (dest: CallEx, result: Ex): Stats = {
    $dest := ($result) as BitsX
    }

  // assigns zero extended word result to destination expression and set flags
  model WResFlags (dest: CallEx, result: Ex): Stats = {
    $dest := ($result) as BitsW as BitsX
    $SetFlags ()
    }

  // assigns result to destination expression and set flags
  model XResFlags (dest: CallEx, result: Ex): Stats = {
    $dest := ($result) as BitsX
    $SetFlags ()
    }


// add / sub extend models *****************************************************

  format AddSubExtFormat: Instr =     // add/sub extended register format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , ff       [29]                   // flag field, if (ff = 1) set status register flags
    , op       [30,28..21]            // opcode
    , rm       [20..16] : Index       // 2nd source register
    , option   [15..13]               // ExtendType depending on option value
    , imm3     [12..10] : Bits3       // immediate shift amount, if (imm3 > 4) raise Undefined
    , rn       [9..5]   : Index       // 1st source register (SP)
    , rd       [4..0]   : Index       // destination register (SP if ff = 0)
    }

  model AddSubExtInstrBase (i: InstrWithFunct, extId: Id, size: Id, f: Flags, extEx: Ex, optId: Id, enc: Encs, asm: Ex): IsaDefs = {
    [undefined when : imm3(2) = 1 && imm3(1..0) != 0]
    instruction AsId ($i.id, $extId): AddSubExtFormat =
      let result, flags = VADL::$i.funct (S(rn) as Bits<Size::$size>, ($extEx) as Bits<Size::$size>) in {
        $f.resModel (match: Id ($f.ff = OffFlags => S ; _ => X)(rd) ; result )
        }
    encoding AsId ($i.id, $extId) = { op = $i.opcode, sf = SF::$size, ff = FF::$f.ff, option = ExtendType::$optId, $enc }
    assembly AsId ($i.id, $extId) = ( $i.mnemo, $f.mext, ' ', AsId($size, match: Str ($f.ff = OffFlags => "SP" ; _ => ""))(rd),
                       ', ', AsId($size, "SP")(rn), ', ', $asm )
    }

  model AddSubExtInstr (i: InstrWithFunct, size: Id, f: Flags): IsaDefs = {
    $AddSubExtInstrBase ($i; UXTB; $size; $f; X(rm)( 7..0) as UIntX; UXTB; imm3 = 0; (WSize(rm), ", uxtb"))
    $AddSubExtInstrBase ($i; UXTH; $size; $f; X(rm)(15..0) as UIntX; UXTH; imm3 = 0; (WSize(rm), ", uxth"))
    $AddSubExtInstrBase ($i; UXTW; $size; $f; X(rm)(31..0) as UIntX; UXTW; imm3 = 0; (WSize(rm), ", uxtw"))
    $AddSubExtInstrBase ($i; UXTX; $size; $f; X(rm)(63..0) as UIntX; UXTX; imm3 = 0; ($size(rm), ", uxtx"))
    $AddSubExtInstrBase ($i; SXTB; $size; $f; X(rm)( 7..0) as SIntX; SXTB; imm3 = 0; (WSize(rm), ", sxtb"))
    $AddSubExtInstrBase ($i; SXTH; $size; $f; X(rm)(15..0) as SIntX; SXTH; imm3 = 0; (WSize(rm), ", sxth"))
    $AddSubExtInstrBase ($i; SXTW; $size; $f; X(rm)(31..0) as SIntX; SXTW; imm3 = 0; (WSize(rm), ", sxtw"))
    $AddSubExtInstrBase ($i; SXTX; $size; $f; X(rm)(63..0) as SIntX; SXTX; imm3 = 0; ($size(rm), ", sxtx"))

    $AddSubExtInstrBase ($i; UXSB; $size; $f; X(rm)( 7..0) as UIntX << imm3; UXTB; none; (WSize(rm), ", uxtb #", decimal(imm3)))
    $AddSubExtInstrBase ($i; UXSH; $size; $f; X(rm)(15..0) as UIntX << imm3; UXTH; none; (WSize(rm), ", uxth #", decimal(imm3)))
    $AddSubExtInstrBase ($i; UXSW; $size; $f; X(rm)(31..0) as UIntX << imm3; UXTW; none; (WSize(rm), ", uxtw #", decimal(imm3)))
    $AddSubExtInstrBase ($i; UXSX; $size; $f; X(rm)(63..0) as UIntX << imm3; UXTX; none; ($size(rm), ", uxtx #", decimal(imm3)))
    $AddSubExtInstrBase ($i; SXSB; $size; $f; X(rm)( 7..0) as SIntX << imm3; SXTB; none; (WSize(rm), ", sxtb #", decimal(imm3)))
    $AddSubExtInstrBase ($i; SXSH; $size; $f; X(rm)(15..0) as SIntX << imm3; SXTH; none; (WSize(rm), ", sxth #", decimal(imm3)))
    $AddSubExtInstrBase ($i; SXSW; $size; $f; X(rm)(31..0) as SIntX << imm3; SXTW; none; (WSize(rm), ", sxtw #", decimal(imm3)))
    $AddSubExtInstrBase ($i; SXSX; $size; $f; X(rm)(63..0) as SIntX << imm3; SXTX; none; ($size(rm), ", sxtx #", decimal(imm3)))
    }


// add / sub immediate models **************************************************

  format AddSubImmFormat: Instr =     // add/sub immediate format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , ff       [29]                   // flag field, if (ff = 1) set status register flags
    , op       [30,28..23]            // opcode
    , sh       [22]                   // if (sh = 1) imm12 << 12
    , imm12    [21..10] : Bits12      // immediate operand eventually shifted
    , rn       [9..5]   : Index       // source register (SP)
    , rd       [4..0]   : Index       // destination register (SP if ff = 0)
    , imm12X   = imm12 as BitsX       // zero extended immediate operand
    , imm12S   = imm12 as BitsX << 12 // zero extended shifted immediate operand
    }

  model AddSubImmInstrShft (i: InstrWithFunct, size: Id, f: Flags, immEx: Ex, sh: Lit, asm: Str): IsaDefs = {
    instruction $i.id: AddSubImmFormat =
      let result, flags = VADL::$i.funct (S(rn) as Bits<Size::$size>, ($immEx) as Bits<Size::$size>) in {
        $f.resModel (match: Id ($f.ff = OffFlags => S ; _ => X)(rd) ; result )
        }
    encoding $i.id = { op = $i.opcode, sf = SF::$size, ff = FF::$f.ff, sh = $sh }
    assembly $i.id = ( $i.mnemo, $f.mext, ' ', AsId($size, match: Str ($f.ff = OffFlags => "SP" ; _ => ""))(rd),
                       ', ', AsId($size, "SP")(rn), ', ', "#", decimal($immEx), $asm )
    }

  model ExtInstrStr (i: InstrWithFunct, ext: Str): InstrWithFunct = {
    (AsId ($i.id, $ext); $i.mnemo; $i.opcode; $i.funct)
    }

  model AddSubImmInstr (i: InstrWithFunct, size: Id, f: Flags): IsaDefs = {
    $AddSubImmInstrShft ($ExtInstrStr ($i; "I"  ); $size; $f; imm12X; 0 ; "") //  decimal(imm12)
    $AddSubImmInstrShft ($ExtInstrStr ($i; "I12"); $size; $f; imm12S; 1 ; "") // (decimal(imm12), ", lsl #12")
    }


// add / sub shift models ******************************************************

  format AddSubSftFormat: Instr =     // add/sub shifted register format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , ff       [29]                   // flag field, if (ff = 1) set status register flags
    , op       [30,28..24,21]         // opcode
    , shift    [23,22]                // ShiftType, if (shift = ROR) raise Undefined
    , rm       [20..16] : Index       // 2nd source register (eventually shifted)
    , imm6     [15..10] : Bits6       // immediate shift amount, if (sf = 0 && imm6(5) = 1) raise Undefined
    , rn       [9..5]   : Index       // 1st source register
    , rd       [4..0]   : Index       // destination register
    }

  model AddSubSftInstrBase (i: InstrWithFunct, size: Id, f: Flags, sftex: Ex, enc: Encs, asm: Ex): IsaDefs = {
    [undefined when : sf = 0 && imm6(5) = 1]
    instruction $i.id: AddSubSftFormat =
      let result, flags = VADL::$i.funct (X(rn) as Bits<Size::$size>, ($sftex) as Bits<Size::$size>) in {
        $f.resModel (X(rd) ; result )
      }
    encoding $i.id = { op = $i.opcode, sf = SF::$size, ff = FF::$f.ff, $enc }
    assembly $i.id = ( $i.mnemo, $f.mext, ' ', $size(rd), ', ', $size(rn), ', ', $size(rm), $asm )
    }

  model AddSubSftInstr (i: InstrWithFunct, size: Id, f: Flags): IsaDefs = {
    $AddSubSftInstrBase ($i; $size; $f; X(rm); imm6 = 0, shift = ShiftType::LSL; "") // TODO pseudo instruction
    $AddSubSftInstrBase ($ExtInstrStr ($i; "LSL"); $size; $f; X(rm) as Bits<Size::$size> << imm6; shift = ShiftType::LSL; (", lsl #", decimal(imm6)))
    $AddSubSftInstrBase ($ExtInstrStr ($i; "LSR"); $size; $f; X(rm) as UInt<Size::$size> >> imm6; shift = ShiftType::LSR; (", lsr #", decimal(imm6)))
    $AddSubSftInstrBase ($ExtInstrStr ($i; "ASR"); $size; $f; X(rm) as SInt<Size::$size> >> imm6; shift = ShiftType::ASR; (", asr #", decimal(imm6)))
    }


// encoding / assembly model for 3 register operand instructions ***************

  format ThreeRegOpFormat: Instr =    // three register operand format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..21,15..10]        // opcode
    , rm       [20..16] : Index       // 2nd source register
    , rn       [9..5]   : Index       // 1st source register
    , rd       [4..0]   : Index       // destination register
    }

  model ThreeRegOpEncAsm (i: InstrWithFunct, size: Id): IsaDefs = {
    encoding $i.id = { op = $i.opcode, sf = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn), ', ', $size(rm))
    }


// add / sub carry models ******************************************************

  model AddSubCarryInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: ThreeRegOpFormat =
      let result, flags = VADL::$i.funct(X(rn) as Bits<Size::$size>, X(rm) as Bits<Size::$size>, NZCV_C) in
        X(rd) := result as Bits<Size::$size> as BitsX
    $ThreeRegOpEncAsm ($i; $size)
    }

  model AddSubCarryFlagInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: ThreeRegOpFormat =
      let result, flags = VADL::$i.funct(X(rn) as Bits<Size::$size>, X(rm) as Bits<Size::$size>, NZCV_C) in {
        X(rd) := result as Bits<Size::$size> as BitsX
        $SetFlags()
        }
    $ThreeRegOpEncAsm ($i; $size)
    }


// PC relative address models **************************************************

  format RelAddressFormat: Instr =    // PC relative address format
    { op       [31,28..24]            // opcode
    , imm21    [23..5,30,29]          // PC relative offset
    , rd       [4..0]   : Index       // destination register
    , offset   = imm21 as SIntX       // sign extended offset
    }

  model AddressBaseInstr (i: InstrNoFunct, ex: Ex): IsaDefs = {
    instruction $i.id: RelAddressFormat =
      X(rd) := $ex
    encoding $i.id = { op = $i.opcode }
    assembly $i.id = ($i.mnemo, ' ', decimal(imm21))
    }

  model AddressRelInstr (i: InstrNoFunct): IsaDefs = {
    $AddressBaseInstr ($i; PC + offset)
    }

  model AddressPageInstr (i: InstrNoFunct): IsaDefs = {
    $AddressBaseInstr ($i; ((PC >> 12) + offset) << 12)
    }


// multiply add / sub (long)  models *******************************************

  format MulAddSubFormat: Instr =     // multiply add / sub format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..21,15]            // opcode
    , rm       [20..16] : Index       // 2nd source  register
    , ra       [14..10] : Index       // accumulator register
    , rn       [9..5]   : Index       // 1st source  register
    , rd       [4..0]   : Index       // destination register
    }

  model MulAddSubInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: MulAddSubFormat =
      let result = VADL::$i.funct (X(ra) as Bits<Size::$size>, (X(rn) as Bits<Size::$size> * X(rm) as Bits<Size::$size>)) in
        X(rd) := result as Bits<Size::$size> as BitsX
    encoding $i.id = { op = $i.opcode, sf = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn), ', ', $size(rm), ', ', $size(ra))
    }

  model MulAddSubLongInstr (i: InstrWithFunct, type: Id): IsaDefs = {
    instruction $i.id: MulAddSubFormat =
      X(rd) := VADL::$i.funct (X(ra), (X(rn) as $type<Size::WSize> *# X(rm) as $type<Size::WSize>))
    encoding $i.id = { op = $i.opcode, sf = SF::XSize }
    assembly $i.id = ($i.mnemo, ' ', XSize(rd), ', ', WSize(rn), ', ', WSize(rm), ', ', XSize(ra))
    }

  model SMulAddSubLongInstr (i: InstrWithFunct): IsaDefs = { $MulAddSubLongInstr ($i; SInt) }
  model UMulAddSubLongInstr (i: InstrWithFunct): IsaDefs = { $MulAddSubLongInstr ($i; UInt) }

// multiply high model *********************************************************

  model MulHighInstr (i: InstrWithFunct): IsaDefs = {
    instruction $i.id: ThreeRegOpFormat =
      let result = X(rn) as $i.funct *# X(rm) as $i.funct in
        X(rd) := result(127..SizeX)
    $ThreeRegOpEncAsm ($i; XSize)
    }


// divide model ****************************************************************

  model DivInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: ThreeRegOpFormat =
      let result =
        if X(rm) = 0
          then 0
          else X(rn) as $i.funct<Size::$size> / X(rm) as $i.funct<Size::$size> in
        X(rd) := result as Bits<Size::$size> as BitsX
    $ThreeRegOpEncAsm ($i; $size)
    }


// logic immediate models ******************************************************

  // Additional information on immediate operand de/encoding is available at
  // https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/
  // https://kddnewton.com/2022/08/11/aarch64-bitmask-immediates.html

  // pattern replication functions

  function rep2  (pattern: Bits< 2>) -> Bits< 4> = (pattern, pattern)
  function rep4  (pattern: Bits< 4>) -> Bits< 8> = (pattern, pattern)
  function rep8  (pattern: Bits< 8>) -> Bits<16> = (pattern, pattern)
  function rep16 (pattern: Bits<16>) -> Bits<32> = (pattern, pattern)
  function rep32 (pattern: Bits<32>) -> Bits<64> = (pattern, pattern)

  // replicate replicates the size0 sized pattern in pat0 until 64 bit are
  // filled, size0 must be a power of 2 > 1, the bits above the pattern in
  // pat0 must be zero
 
  function replicate (pat0: BitsX, size0: Bits6) -> BitsX =
    if size0 = 0 then pat0 else let pat1 = pat0 << size0 | pat0 in let size1 = size0 << 1 in
    if size1 = 0 then pat1 else let pat2 = pat1 << size1 | pat1 in let size2 = size1 << 1 in
    if size2 = 0 then pat2 else let pat3 = pat2 << size2 | pat2 in let size3 = size2 << 1 in
    if size3 = 0 then pat3 else let pat4 = pat3 << size3 | pat3 in let size4 = size3 << 1 in
    if size4 = 0 then pat4 else            pat4 << size4 | pat4

  // imm13Decode takes the N, imms and immr fields as a combined 13 bit value
  // and returns the replicated and rotated 64 bit immediate value for defined
  // N, imms and immr values. 0 is returned for undefined values of imms, either
  // explicitely for an invalid level or implicitely for an invalid length of
  // all ones by shifting 1 zero times and subtracting 1 which also results in
  // 0. The unused high bits of immr have no effect as rotating the identical
  // pattern more positions than required gives the same result.

  function imm13DecAlt (imm13: Bits13) -> BitsX =
    (    if imm13(12  ) = 0b1     then                                 (1 as Bits<64> << imm13(5..0) + 1) - 1
    else if imm13(5   ) = 0b0     then rep32 (                         (1 as Bits<32> << imm13(4..0) + 1) - 1)
    else if imm13(5..4) = 0b10    then rep32 (rep16(                   (1 as Bits<16> << imm13(3..0) + 1) - 1))
    else if imm13(5..3) = 0b110   then rep32 (rep16 (rep8(             (1 as Bits< 8> << imm13(2..0) + 1) - 1)))
    else if imm13(5..2) = 0b1110  then rep32 (rep16 (rep8 (rep4(       (1 as Bits< 4> << imm13(1..0) + 1) - 1))))
    else if imm13(5..1) = 0b11110 then rep32 (rep16 (rep8 (rep4 (rep2 ((1 as Bits< 2> << imm13(   0) + 1) - 1)))))
    else 0  ) <>> imm13(11..6)

  function imm13Decode (imm13: Bits13) -> BitsX =
    (    if imm13(12  ) = 0b1     then            (1 as BitsX << imm13(5..0) + 1) - 1
    else if imm13(5   ) = 0b0     then replicate ((1 as BitsX << imm13(4..0) + 1) - 1, 32)
    else if imm13(5..4) = 0b10    then replicate ((1 as BitsX << imm13(3..0) + 1) - 1, 16)
    else if imm13(5..3) = 0b110   then replicate ((1 as BitsX << imm13(2..0) + 1) - 1,  8)
    else if imm13(5..2) = 0b1110  then replicate ((1 as BitsX << imm13(1..0) + 1) - 1,  4)
    else if imm13(5..1) = 0b11110 then replicate ((1 as BitsX << imm13(   0) + 1) - 1,  2)
    else 0  ) <>> imm13(11..6)

  // patternSize determines the size of a repeating pattern.
  // Zero and all ones are invalid patterns for the immediate operands of
  // logical instructions. The function returns the valid pattern sizes
  // (2,4,8,16,32,64) or 0 for an invalid pattern size.

  function patternSize (val: BitsX) -> SIntW =
         if val =  0    || val = -1   then  0
    else if val(63..32) != val(31..0) then 64
    else if val(31..16) != val(15..0) then 32
    else if val(15.. 8) != val( 7..0) then 16
    else if val( 7.. 4) != val( 3..0) then  8
    else if val( 3.. 2) != val( 1..0) then  4
    else 2 as SIntW

  // nImmrImms returns the concatenated values for N, immr and imms

  function nImmrImms (patSize: SIntW, leftRotations: SIntW, trailingOnes: SIntW) -> Bits13 =
    // immr is the number of right rotations of the pattern
    // imms is a bitwise or of the pattern size and the number of ones - 1
    let immr = (patSize - leftRotations &  patSize - 1) as Bits6 in
    let imms = (~(patSize - 1) << 1 | trailingOnes - 1) as Bits6 in
      (patSize = 64,immr,imms)

// The function isOnesZeros returns true if the argument onesZeros is a
// sequence of one or more ones followed by one or more zeroes.

  function isOnesZeros(onesZeros: BitsX) -> Bool =
    let mask = ((onesZeros - 1) | onesZeros) in
      (mask + 1 & mask) = 0

// imm13Encode encodes an unsigned 64 bit integer into the 13 bit N|immr|imms
// representation for a valid pattern, otherwise it returns 0 as Bits13

  function imm13Encode (val: BitsX) -> Bits13 =
    let size = patternSize (val) in
    if size = 0 then 0 else
    let mask = ~(0 as BitsX) >> (64 - size) in
    let imm = val & mask in
    if isOnesZeros(imm) then
      let leftRotations = VADL::ctz(imm) as SIntW in
        nImmrImms(size, leftRotations, VADL::cto(imm >> leftRotations) as SIntW)
    else let immNmask = imm | ~mask in
      if isOnesZeros(~immNmask) then
        let leadingOnes = VADL::clo(immNmask) as SIntW in
          nImmrImms(size, 64 - leadingOnes, (leadingOnes + VADL::cto(immNmask) as SIntW) - (64 - size))
      else 0 as Bits13

  function imm13EncodeWSize (val: BitsX) -> Bits13 =
    let trunc = val as BitsW as BitsX in
      if trunc != val then 0
      else imm13Encode (val << Size::WSize | val)

  format LogicImmFormat: Instr =      // logic immediate format
    { sf       : Bits1                // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       : Bits8                // opcode
    , imm13    : Bits13               // N, imms and immr fields
    , rn       : Index                // source register
    , rd       : Index                // destination register
    , immX     = imm13Decode (imm13)  // decoded immediate value
    // TODO encode
    // TODO predicate
    }

  model LogicImmEncAsm (i: InstrWithFunct, size: Id, ext: Str): IsaDefs = {
    encoding $i.id = { op = $i.opcode, sf = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', AsId($size, $ext)(rd), ', ', $size(rn), ', #', decimal(immX))
    }

  model LogicImmFlagInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    [undefined when : sf = 0 && imm13(12) = 1]
    instruction $i.id: LogicImmFormat =
      let result, flags = VADL::$i.funct (X(rn) as Bits<Size::$size>, immX as Bits<Size::$size>) in {
        X(rd) := result as Bits<Size::$size> as BitsX
        $SetNZClearCVFlags ()
        }
    $LogicImmEncAsm ($i; $size; "")
    }

  model LogicImmInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: LogicImmFormat =
      let result = VADL::$i.funct (X(rn) as Bits<Size::$size>, immX as Bits<Size::$size>) in
        S(rd) := result as Bits<Size::$size> as BitsX
    $LogicImmEncAsm ($i; $size; "SP")
    }


// logic shifted register models ***********************************************

  format LogicRegShiftFormat: Instr = // logic shifted register format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..24,21]            // opcode
    , shift    [23,22]                // shift type (enum ShiftType, ROR is allowed)
    , rm       [20..16] : Index       // 2nd source register eventually shifted
    , imm6     [15..10] : Bits6       // immediate shift amount, if (sf = 0 && imm6(5) = 1) raise Undefined
    , rn       [9..5]   : Index       // 1st source register
    , rd       [4..0]   : Index       // destination register
    }

  model LogicRegGeneralInstr (i: InstrWithFunct, size: Id, s: RegShift, f: NoSetFlags): IsaDefs = {
    [undefined when : sf = 0 && imm6(5) = 1]
    instruction $i.id: LogicRegShiftFormat =
      let result, flags = VADL::$i.funct (X(rn) as Bits<Size::$size>, $s.ex) in {
        X(rd) := result as Bits<Size::$size> as BitsX
        $f ()
        }
    encoding $i.id = { op = $i.opcode,  sf = SF::$size, $s.enc }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn), ', ', $s.asm)
    }

  model LogicRegBasicInstr (i: InstrWithFunct, size: Id, s: RegShift): IsaDefs = {
    $LogicRegGeneralInstr ($i; $size; $s; NoFlags)
    }

  model LogicRegFlagInstr (i: InstrWithFunct, size: Id, s: RegShift): IsaDefs = {
    $LogicRegGeneralInstr ($i; $size; $s; SetNZClearCVFlags)
    }

  model LogicRegNegInstr (i: InstrWithFunct, size: Id, s: RegShift): IsaDefs = {
    $LogicRegGeneralInstr ($i; $size; (~($s.ex); $s.enc; $s.asm); NoFlags)
    }

  model LogicRegNegFlagInstr (i: InstrWithFunct, size: Id, s: RegShift): IsaDefs = {
    $LogicRegGeneralInstr ($i; $size; (~($s.ex); $s.enc; $s.asm); SetNZClearCVFlags)
    }

  model LogicRegShiftExtInstr (modelid: InstrWithFunctSizeRegShift, i: InstrWithFunct, ext: Str, size: Id, s: RegShift): IsaDefs = {
    $modelid ((AsId ($i.id, $ext); $i.mnemo; $i.opcode; $i.funct); $size; $s)
    }

  model LogicRegShiftInstr (modelid: InstrWithFunctSizeRegShift, i: InstrWithFunct, size: Id): IsaDefs = {
    $LogicRegShiftExtInstr ($modelid; $i; ""   ; $size; (X(rm) as Bits<Size::$size>; imm6 = 0, shift = ShiftType::LSL;  $size(rm))) // TODO pseudo instruction
    $LogicRegShiftExtInstr ($modelid; $i; "LSL"; $size; (X(rm) as Bits<Size::$size>  << imm6;  shift = ShiftType::LSL; ($size(rm), ", lsl #", decimal(imm6))))
    $LogicRegShiftExtInstr ($modelid; $i; "LSR"; $size; (X(rm) as UInt<Size::$size>  >> imm6;  shift = ShiftType::LSR; ($size(rm), ", lsr #", decimal(imm6))))
    $LogicRegShiftExtInstr ($modelid; $i; "ASR"; $size; (X(rm) as SInt<Size::$size>  >> imm6;  shift = ShiftType::ASR; ($size(rm), ", asr #", decimal(imm6))))
    $LogicRegShiftExtInstr ($modelid; $i; "ROR"; $size; (X(rm) as Bits<Size::$size> <>> imm6;  shift = ShiftType::ROR; ($size(rm), ", ror #", decimal(imm6))))
    }


// register shift models *******************************************************

  format ShiftRegFormat: Instr =      // variable shift register format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..21,15..12]        // opcode
    , rm       [20..16] : Index       // 2nd source register
    , shift    [11..10]               // shift type (enum ShiftType, ROR is allowed)
    , rn       [9..5]   : Index       // 1st source register
    , rd       [4..0]   : Index       // destination register
    }

  model ShiftRegInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: ShiftRegFormat =
      X(rd) :=  VADL::$i.funct (X(rn) as Bits<Size::$size>, X(rm) as Bits<Size::$size>) as Bits as BitsX
    encoding $i.id = { op = 0b0011'0101'1000'10, sf = SF::$size, shift = ShiftType::$i.opcode }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn), ', ', $size(rm))
    }


// movk, movn, movz models *****************************************************

  enumeration Position: Bits2 =       // position in destination register, do not reorder
    { Pos00                           // 15..0
    , Pos16                           // 31..16
    , Pos32                           // 47..32
    , Pos48                           // 63..48
    }

  format MovFormat: Instr =           // movk, movn, movz format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..23]               // opcode
    , pos      [22,21]                // position of imm16 in destination (enum Position)
    , imm16    [20..5]  : Bits16      // immediate value shifted by (pos << 4)
    , rd       [4..0]   : Index       // destination register
    }

  model notOrIdent (not: Id, ex: Ex) : Ex = { match: Ex ($not = not => ~($ex) ;_=> $ex) }
  
  model MovInstr (i: InstrWithFunct, size: Id, pos: Id, posex: Ex): IsaDefs = {
    instruction AsId ($i.id, $pos): MovFormat =
      X(rd) := $posex
    encoding AsId ($i.id, $pos) = { sf = SF::$size, op = $i.opcode, pos = Position::$pos }
    assembly AsId ($i.id, $pos) = ($i.mnemo, ' ', $size(rd), ', #', decimal(imm16),
      match: Str ($pos = Pos00 => ""; $pos = Pos16 => ", LSL #16"; $pos = Pos32 => ", LSL #32"; _ => ", LSL #48"))
    }

  model MovKInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    match: IsaDefs ( $size = WSize
         => $MovInstr ($i; $size; Pos00; let xrd = X(rd) in (xrd(31..16), imm16) as BitsX)
            $MovInstr ($i; $size; Pos16; let xrd = X(rd) in (imm16, xrd(15..0 )) as BitsX)
      ; _=> $MovInstr ($i; $size; Pos00; let xrd = X(rd) in (xrd(63..16), imm16            ))
            $MovInstr ($i; $size; Pos16; let xrd = X(rd) in (xrd(63..32), imm16, xrd(15..0)))
            $MovInstr ($i; $size; Pos32; let xrd = X(rd) in (xrd(63..48), imm16, xrd(31..0)))
            $MovInstr ($i; $size; Pos48; let xrd = X(rd) in (             imm16, xrd(47..0)))
      )
    }

  model MovNZInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    match: IsaDefs ( $size = WSize
         => $MovInstr ($i; $size; Pos00; $notOrIdent($i.funct; (imm16 as BitsW      )) as BitsX)
            $MovInstr ($i; $size; Pos16; $notOrIdent($i.funct; (imm16 as BitsW << 16)) as BitsX)
      ; _=> $MovInstr ($i; $size; Pos00; $notOrIdent($i.funct;  imm16 as BitsX      ))
            $MovInstr ($i; $size; Pos16; $notOrIdent($i.funct;  imm16 as BitsX << 16))
            $MovInstr ($i; $size; Pos32; $notOrIdent($i.funct;  imm16 as BitsX << 32))
            $MovInstr ($i; $size; Pos48; $notOrIdent($i.funct;  imm16 as BitsX << 48))
      )
    }


// bitfield extract model ******************************************************

  format ExtractRegFormat: Instr =    // bit field extract register format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..23,21]            // opcode
    , N        [22]                   // must be equal to sf, otherwise undefined
    , rm       [20..16]               // 2nd source register
    , imms     [15..10]               // right shift amount (bit field position)
    , rn       [9..5]                 // 1st source register
    , rd       [4..0]                 // destination register
    , shiftWSize  = imms(4..0)
    , shiftXSize  = imms
    }

  model ExtractRegPairInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    [undefined when : sf = 0 && imms(5)]
    instruction $i.id: ExtractRegFormat =
      let pair = (X(rn) as Bits<Size::$size>, X(rm) as Bits<Size::$size>) in
        X(rd) :=  (pair >> AsId (shift, $size)) as Bits<Size::$size> as BitsX
    encoding $i.id = { op = $i.opcode, sf = SF::$size, N = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn), ', ', $size(rm), ', #', decimal(imms))
    }


// bitfield move model *********************************************************

// There exist different versions of a BFM, SBFM, UBFM (BitField Move)
// instruction. Bitfield move commons are:
//
// If <imms> is greater than or equal to <immr>, this copies a bitfield of
// (<imms>-<immr>+1) bits starting from bit position <immr> in the source
// register to the least significant bits of the destination register.
//
// If <imms> is less than <immr>, *BFM copies a bitfield of (<imms>+1) bits from
// the least significant bits of the source register to bit position
// (regsize-<immr>) of the destination register, where regsize is the
// destination register size of 32 or 64 bits (but regsize becomes 0 in Bit5 or
// Bit6 sized positions computations).
//
// BFM:  In both cases, the other bits of the destination register remain
// unchanged.
// SBFM: In both cases, the destination bits below the bitfield are set to zero,
// and the bits above the bitfield are set to a copy of the most significant bit
// of the bitfield.
// UBFM: In both cases, the destination bits below and above the bitfield are
// set to zero.
//
// For SBFM and UBFM there exist pseudo instructions for shifts and sign/zero
// extension. Therefore, *BFM instructions are specified using a shift left
// followed by a shift right.

  format BitFieldMoveFormat: Instr =  // bit field move format
    { sf         : Bits1              // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op         : Bits8              // opcode
    , N          : Bits1              // must be equal to sf, otherwise undefined
    , immr       : Bits6              // rotate right count (bit field low position)
    , imms       : Bits6              // bit field length -1 or high position
    , rn         : Index              // source register
    , rd         : Index              // destination register
    , leftWSize  = -1 as Bits5 - imms as Bits5
    , leftXSize  = -1 as Bits6 - imms
    , rightWSize = immr as Bits5 - imms as Bits5 - 1
    , rightXSize = immr - imms - 1
    //, imms := (-1 as Bits5 - leftWSize) as Bits6
    //, imms :=  -1 as Bits6 - leftXSize
    //, immr := (rightWSize  - leftWSize) as Bits6
    //, immr :=  rightXSize  - leftXSize
    // true
    }

  model BitfieldMoveInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    // if (sf = 0) specification ignores imms(5) and immr(5)
    // (sf != N) cannot happen as N is set in encoding
    [undefined when : sf = 0 && (imms(5) = 1 || immr(5) = 1)]
    instruction $i.id: BitFieldMoveFormat =
      let left = AsId (left, $size) in
        let right = AsId (right, $size) in
          let xrn = X(rn) as $i.funct<Size::$size> << left >> right in
            let result = match: Ex ($i.mnemo = "bfm" =>
              let mask = ~(~(0 as Bits<Size::$size>) << left >> right) in
                X(rd) as Bits<Size::$size> & mask | xrn
              ; _ =>
              xrn) in
            X(rd) := result as Bits<Size::$size> as BitsX
    encoding $i.id = { op = $i.opcode, sf = SF::$size, N = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn), ', #', decimal(immr), ', #', decimal(imms))
    }


// bit count models ************************************************************

  format TwoRegOpFormat: Instr =      // two register operand format
    { sf       : Bits1                // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       : Bits21               // opcode
    , rn       : Index                // source register
    , rd       : Index                // destination register
    }

  model TwoRegOpEncAsm (i: InstrWithFunct, size: Id): IsaDefs = {
    encoding $i.id = { op = $i.opcode, sf = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', $size(rd), ', ', $size(rn))
    }

  model CountBitsInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: TwoRegOpFormat =
      let result = VADL::$i.funct (X(rn) as Bits<Size::$size>) in
        X(rd) := result as Bits<Size::$size> as BitsX
    $TwoRegOpEncAsm ($i; $size)
    }


// reverse bits / bytes model **************************************************

  function revBitsWSize (bits: BitsW) -> BitsW = bits 
    ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
     16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)

  function revBitsXSize (bits: BitsX) -> BitsX = bits
    ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
     16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
     32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
     48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63)

  model ReverseBitsInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: TwoRegOpFormat =
      let result = AsId (revBits, $size) (X(rn) as Bits<Size::$size>) in
        X(rd) := result as Bits<Size::$size> as BitsX
    $TwoRegOpEncAsm ($i; $size)
    }

  model RevBytesHInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: TwoRegOpFormat = {
      let xrn = (X(rn)) in
        let result = (xrn(55..48),xrn(63..56),xrn(39..32),xrn(47..40),xrn(23..16),xrn(31..24),xrn(7..0),xrn(15..8)) in
          X(rd) := result as Bits<Size::$size> as BitsX
      }
    $TwoRegOpEncAsm ($i; $size)
    }

  model RevBytesWInstr (i: InstrWithFunct): IsaDefs = {
    instruction $i.id: TwoRegOpFormat =
      let xrn = (X(rn)) in
        let result = (xrn(39..32),xrn(47..40),xrn(55..48),xrn(63..56),xrn(7..0),xrn(15..8),xrn(23..16),xrn(31..24)) in
          X(rd) := result as Bits<Size::$i.funct> as BitsX
    $TwoRegOpEncAsm ($i; $i.funct)
    }

  model RevBytesXInstr (i: InstrWithFunct): IsaDefs = {
    instruction $i.id: TwoRegOpFormat =
      let xrn = (X(rn)) in
        let result = (xrn(7..0),xrn(15..8),xrn(23..16),xrn(31..24),xrn(39..32),xrn(47..40),xrn(55..48),xrn(63..56)) in
          X(rd) := result as Bits<Size::$i.funct> as BitsX
    $TwoRegOpEncAsm ($i; $i.funct)
    }

// conditional compare models **************************************************

  format CondCompareFormat: Instr =   // conditional compare format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..21,11,10,4]       // opcode
    , rm       [20..16] : Index       // 2nd source register or unsigned 5 bit immediate value
    , cc       [15..12] : Bits4       // condition code (enum CondCode)
    , rn       [9..5]   : Index       // source register
    , nzcv     [3..0]   : Bits4       // new condition flags
    , immX     = rm as BitsX          // rm zero extended to 64 bits
    }

  model CondCompareBaseInstr (i: InstrWithFunct, c: Cond, size: Id, ex: Ex, asm: Ex): IsaDefs = {
    instruction $i.id: CondCompareFormat =
      if $c.ex
        then let result, flags = VADL::$i.funct(X(rn) as Bits<Size::$size>, $ex) in {
          $SetFlags()
          }
        else {
          NZCV_N := nzcv(3)
          NZCV_Z := nzcv(2)
          NZCV_C := nzcv(1)
          NZCV_V := nzcv(0)
          }
    encoding $i.id = { op = $i.opcode, sf = SF::$size, cc = CondCode::$c.cc }
    assembly $i.id = ( $i.mnemo, ' ', $size(rn), $asm, ', #', decimal(nzcv), ', ', $c.mext )
    }

  model CondCompareImmInstr (i: InstrWithFunct, c: Cond): IsaDefs = {
    $CondCompareBaseInstr ($ExtInstrStr ($i; "W"); $c; WSize; immX as BitsW; (', #', decimal(rm)))
    $CondCompareBaseInstr ($ExtInstrStr ($i; "X"); $c; XSize; immX         ; (', #', decimal(rm)))
    }

  model CondCompareRegInstr (i: InstrWithFunct, c: Cond): IsaDefs = {
    $CondCompareBaseInstr ($ExtInstrStr ($i; "W"); $c; WSize; X(rm) as BitsW; (', ', WSize(rm)))
    $CondCompareBaseInstr ($ExtInstrStr ($i; "X"); $c; XSize; X(rm)         ; (', ', XSize(rm)))
    }


// conditional select models ***************************************************

  format CondSelectFormat: Instr =    // conditional select format
    { sf       [31]                   // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       [30..21,11,10]         // opcode
    , rm       [20..16]               // 2nd source register
    , cc       [15..12]               // condition code (enum CondCode)
    , rn       [9..5]                 // source register
    , rd       [4..0]                 // destination register
    }

  model CondSelectBaseInstr (i: InstrWithFunct, c: Cond, size: Id, ex: Ex): IsaDefs = {
    instruction $i.id: CondSelectFormat =
      let result = if $c.ex then X(rn) else $ex in
        X(rd) := result as Bits<Size::$size> as BitsX
    encoding $i.id = { op = $i.opcode, sf = SF::$size, cc = CondCode::$c.cc }
    assembly $i.id = ( $i.mnemo, ' ', $size(rd), ', ', $size(rn), ', ', $size(rm), ', ', $c.mext)
    }

  model CondSelectWX (i: InstrWithFunct, c: Cond, ex: Ex): IsaDefs = {
    $CondSelectBaseInstr ($ExtInstrStr ($i; "W"); $c; WSize; $ex)
    $CondSelectBaseInstr ($ExtInstrStr ($i; "X"); $c; XSize; $ex)
    }

  model CondSelectInstr (i: InstrWithFunct, c: Cond): IsaDefs = {
    match: IsaDefs (
      $i.funct = inc => $CondSelectWX ($i; $c;  X(rm) + 1);
      $i.funct = neg => $CondSelectWX ($i; $c; -X(rm)    );
      $i.funct = not => $CondSelectWX ($i; $c; ~X(rm)    );
      _              => $CondSelectWX ($i; $c;  X(rm)    ))
    }


// branch models ***************************************************************

  format BranchFormat: Instr =        // unconditional branch immediate format
    { op       : Bits6                // opcode
    , imm26    : Bits26               // branch offset, needs to be sign extended and shifted
    , offset   = imm26 as SIntX << 2  // sign extended and shifted offset
    }

  model BranchEncAsm (i: InstrNoFunct): IsaDefs = {
    encoding $i.id = { op = $i.opcode }
    assembly $i.id = ( $i.mnemo, ' ', decimal(imm26))
    }

  model BranchInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: BranchFormat =
      PC := PC + offset
    $BranchEncAsm ($i)
    }

  model BranchLinkInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: BranchFormat = {
      LR := PC.next
      PC := PC + offset
      }
    $BranchEncAsm ($i)
    }

  model BranchRegEncAsm (i: InstrNoFunct): IsaDefs = {
    encoding $i.id = { op = $i.opcode }
    assembly $i.id = ( $i.mnemo, ' ', XSize(rn))
    }

  format BranchRegFormat: Instr =     // branch register format
    { op       [31..10,4..0]          // opcode
    , rn       [9..5]   : Index       // branch target register
    }

  model BranchRegInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: BranchRegFormat =
      PC := X(rn)
    $BranchRegEncAsm ($i)
    }

  model BranchRegLinkInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: BranchRegFormat =
      let target = X(rn) in {
        LR := PC.next
        PC := target
        }
    $BranchRegEncAsm ($i)
    }

  format CondBranchFormat: Instr =    // conditional branch conditional immediate format
    { op       [31..24,4]             // opcode
    , imm19    [23..5]  : Bits19      // branch offset, needs to be sign extended and shifted
    , cc       [3..0]                 // condition code (enum CondCode)
    , offset   = imm19 as SIntX << 2  // sign extended and shifted offset
    }

  model CondBranchInstr (i: InstrWithFunct, c: Cond): IsaDefs = {
    instruction $i.id: CondBranchFormat =
      if $c.ex then
        PC := PC + offset
    encoding $i.id = { op = $i.opcode, cc = CondCode::$c.cc }
    assembly $i.id = ($i.mnemo, $c.mext, ' ', decimal(imm19))
    }

  model ExtendCondInstr (modelid: InstrWithCond, i: InstrWithFunct, c: Cond): IsaDefs = {
    $modelid ((AsId($i.id, $c.cc); $i.mnemo; $i.opcode; $i.funct); $c)
    }

  model CondInstr (modelid: InstrWithCond, i: InstrWithFunct): IsaDefs = {
    $ExtendCondInstr ($modelid; $i; (EQ ; "eq" ; NZCV_Z  = 1                    ))
    $ExtendCondInstr ($modelid; $i; (NE ; "ne" ; NZCV_Z  = 0                    ))
    $ExtendCondInstr ($modelid; $i; (CS ; "cs" ; NZCV_C  = 1                    ))
    $ExtendCondInstr ($modelid; $i; (CC ; "cc" ; NZCV_C  = 0                    ))
    $ExtendCondInstr ($modelid; $i; (MI ; "mi" ; NZCV_N  = 1                    ))
    $ExtendCondInstr ($modelid; $i; (PL ; "pl" ; NZCV_N  = 0                    ))
    $ExtendCondInstr ($modelid; $i; (VS ; "vs" ; NZCV_V  = 1                    ))
    $ExtendCondInstr ($modelid; $i; (VC ; "vc" ; NZCV_V  = 0                    ))
    $ExtendCondInstr ($modelid; $i; (HI ; "hi" ; NZCV_C  = 1 && NZCV_Z = 0      ))
    $ExtendCondInstr ($modelid; $i; (LS ; "ls" ; NZCV_C  = 0 || NZCV_Z = 1      ))
    $ExtendCondInstr ($modelid; $i; (GE ; "ge" ; NZCV_N  = NZCV_V               ))
    $ExtendCondInstr ($modelid; $i; (LT ; "lt" ; NZCV_N != NZCV_V               ))
    $ExtendCondInstr ($modelid; $i; (GT ; "gt" ; NZCV_N  = NZCV_V && NZCV_Z = 0 ))
    $ExtendCondInstr ($modelid; $i; (LE ; "le" ; NZCV_N != NZCV_V || NZCV_Z = 1 ))
    $ExtendCondInstr ($modelid; $i; (AL ; "al" ; true                           ))
    $ExtendCondInstr ($modelid; $i; (NV ; "nv" ; true                           ))
    }

  format CompareBranchFormat: Instr = // compare and branch immediate format
    { sf       : Bits1                // size field (enum SF), if (sf = 0) 32 bit operation else 64 bit
    , op       : Bits7                // opcode
    , imm19    : Bits19               // branch offset, needs to be sign extended and shifted
    , rt       : Index                // source register
    , offset   = imm19 as SIntX << 2  // sign extended and shifted offset
    }

  model CompareBranchInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    instruction $i.id: CompareBranchFormat =
      if VADL::$i.funct (X(rt) as Bits<Size::$size>, 0) then
        PC := PC + offset
    encoding $i.id = { op = $i.opcode, sf = SF::$size }
    assembly $i.id = ($i.mnemo, ' ', $size(rt), ', ', decimal(imm19))
    }

  format TestBitBranchFormat: Instr = // test bit and branch immediate format
    { op       [30..24]    : Bits7    // opcode
    , imm6     [31,23..19] : Bits6    // bit identifier
    , imm14    [18..5]     : Bits14   // branch offset, needs to be sign extended and shifted
    , rt       [4..0]      : Index    // source register
    , offset   = imm14 as SIntX << 2  // sign extended and shifted offset
    }

  model TestBitBranchInstr (i: InstrWithFunct): IsaDefs = {
    instruction $i.id: TestBitBranchFormat =
      if VADL::$i.funct ((X(rt) >> imm6) as Bits1, 0) then
        PC := PC + offset
    encoding $i.id = { op = $i.opcode }
    assembly $i.id = ( $i.mnemo, ' ', XSize(rt), ', #', decimal(imm6), ', ', decimal(imm14))
    }

// load / store register models ************************************************

  enumeration AccSize: Bits2 =        // memory operations access size, do not change order
    { Byte                            // 1 byte  access
    , Half                            // 2 bytes access
    , Word                            // 4 bytes access
    , XWord                           // 8 bytes access
    }

  format MemoryImmFormat: Instr =     // unscaled immediate load / store format
    { size     [31..30]    : Bits2    // size of memory operation (enum AccSize)
    , op       [29..24,21,11..10]     // opcode
    , opc      [23..22]    : Bits2    // function code for access kind 
    , imm9     [20..12]    : Bits9    // signed offset
    , rn       [9..5]      : Index    // base register (SP)
    , rt       [4..0]      : Index    // source or target register
    , offset   = imm9 as SIntX        // sign extended offset
    }

  format MemoryOffFormat: Instr =     // unsigned offset load / store format
    { size     : Bits2                // size of memory operation (enum AccSize)
    , op       : Bits6                // opcode
    , opc      : Bits2                // function code for access kind
    , imm12    : Bits12               // unsigned scaled offset
    , rn       : Index                // base register (SP)
    , rt       : Index                // source or target register
    , offset   = imm12 as UIntX       // zero extended shifted offset
    }

  model MemoryEncAsm (i: InstrNoFunct, m: Memory, asm: Ex): IsaDefs = {
    encoding $i.id = { op = $i.opcode, opc = $m.opc, size = AccSize::$m.accsize }
    assembly $i.id = ( $i.mnemo, $m.mext, ' ', $m.regsize(rt), ', [', XSizeSP(rn), $asm )
  }

  model MemoryPreIndexInstr (i: InstrNoFunct, m: Memory): IsaDefs = {
    instruction $i.id: MemoryImmFormat =
      let addr = S(rn) + offset in {
        $m.stmt
        S(rn) := addr
        }
    $MemoryEncAsm ($i; $m; (Imm9decimal(imm9), ']!') )
    }

  model MemoryPostIndexInstr (i: InstrNoFunct, m: Memory): IsaDefs = {
    instruction $i.id: MemoryImmFormat =
      let addr = S(rn) in {
        $m.stmt
        S(rn) := addr + offset
        }
    $MemoryEncAsm ($i; $m; (']', Imm9decimal(imm9)) )
    }

  model MemoryOffsetInstr (i: InstrNoFunct, m: Memory): IsaDefs = {
    // TODO check SP alignment
    instruction $i.id: MemoryOffFormat =
      let addr = S(rn) + (offset << AccSize::$m.accsize) in $m.stmt
    $MemoryEncAsm ($i; $m; (Imm12decimal(imm12), ']') )
    }

  model MemoryUnscaledInstr(i: InstrNoFunct, m: Memory): IsaDefs = {
    // TODO check SP alignment
    instruction $i.id: MemoryImmFormat =
      let addr = S(rn) + offset in $m.stmt
    $MemoryEncAsm ($i; $m; (Imm9decimal(imm9), ']') )
    }

// load / store scaled register models *****************************************

  enumeration Scaled: Bits1 =         // scaled index register
    { Un                              // index register unscaled
    , Is                              // index register is scaled
    }

  format MemoryRegFormat: Instr =     // load store (scaled) register format
    { size     [31..30]    : Bits2    // size of memory operation (enum AccSize)
    , op       [29..24,21,11,10]      // opcode
    , opc      [23,22]     : Bits2    // function code for access kind
    , rm       [20..16]    : Index    // (scaled) index register
    , option   [15..13]    : Bits3    // option type (enum ExtendType)
    , scaled   [12]        : Bits1    // set if index register is scaled (enum Scaled)
    , rn       [9..5]      : Index    // base register (SP)
    , rt       [4..0]      : Index    // source or target register
    }

  model MemoryRegisterBase (i: InstrNoFunct, m: Memory, option: Id, scaled: Id, asm: Ex, addr: Ex): IsaDefs = {
    // TODO check SP alignment
    instruction $i.id: MemoryRegFormat =
      let addr = S(rn) + ($addr) in $m.stmt
    encoding $i.id = { op = $i.opcode, opc = $m.opc, size = AccSize::$m.accsize, option = ExtendType::$option, scaled = Scaled::$scaled }
    assembly $i.id = ( $i.mnemo, $m.mext, ' ', $m.regsize(rt), ', [', XSizeSP(rn), ', ', $asm, ']' )
    }

  model MemoryRegisterXtd (i: InstrNoFunct, m: Memory, option: Id, scaled: Id, asm: Ex, addr: Ex): IsaDefs = {
  	$MemoryRegisterBase ((AsId ($i.id, $option, $scaled); $i.mnemo; $i.opcode); $m; $option; $scaled; $asm; $addr)
    }

  model MemoryRegisterInstr (i: InstrNoFunct, m: Memory): IsaDefs = {
    $MemoryRegisterXtd ($i; $m; UXTW; Un; (WSize(rm), ", uxtw"   );               X(rm) as UIntW as BitsX)
    $MemoryRegisterXtd ($i; $m; UXTW; Is; (WSize(rm), ", uxtw #", decimal(size)); X(rm) as UIntW as BitsX << AccSize::$m.accsize)
    $MemoryRegisterXtd ($i; $m; UXTX; Un; (XSize(rm)             );               X(rm))
    $MemoryRegisterXtd ($i; $m; UXTX; Is; (XSize(rm), ", lsl #",  decimal(size)); X(rm) << AccSize::$m.accsize)
    $MemoryRegisterXtd ($i; $m; SXTW; Un; (WSize(rm), ", sxtw"   );               X(rm) as SIntW as BitsX)
    $MemoryRegisterXtd ($i; $m; SXTW; Is; (WSize(rm), ", sxtw #", decimal(size)); X(rm) as SIntW as BitsX << AccSize::$m.accsize)
    $MemoryRegisterXtd ($i; $m; SXTX; Un; (XSize(rm), ", sxtx"   );               X(rm))
    $MemoryRegisterXtd ($i; $m; SXTX; Is; (XSize(rm), ", sxtx #", decimal(size)); X(rm) << AccSize::$m.accsize)
    }

// memory literal model ********************************************************

  format MemoryLitFormat: Instr =     // literal load format
    { opc      : Bits2                // opcode / size of memory operation
    , op       : Bits6                // opcode
    , imm19    : Bits19               // PC relative offset
    , rt       : Index                // target register
    , offset   = imm19 as SIntX << 2
    }

  model MemoryLiteralInstr (i: InstrNoFunct, m: Memory): IsaDefs = {
    instruction $i.id: MemoryLitFormat =
      let addr = PC + offset in $m.stmt
    encoding $i.id = { op = $i.opcode, opc = $m.opc }
    assembly $i.id = ( $i.mnemo, $m.mext, ' ', $m.regsize(rt), ', ', decimal(imm19))
    }

// memory enriching models *****************************************************

  model MemoryInstr (memmodel: MemoryModel, i: InstrNoFunct, xtdId: Str, m: Memory): IsaDefs = {
  	$memmodel ((AsId ($i.id, $xtdId); $i.mnemo; $i.opcode); $m)
    }

  model StoreInstr (memmodel: MemoryModel, i: InstrNoFunct): IsaDefs = {
    $MemoryInstr ($memmodel; $i; "B"  ; (WSize; Byte ;  "b"; 0b00; MEM<1> (addr) := X(rt) as Byte))
    $MemoryInstr ($memmodel; $i; "H"  ; (WSize; Half ;  "h"; 0b00; MEM<2> (addr) := X(rt) as Half))
    $MemoryInstr ($memmodel; $i; "W"  ; (WSize; Word ;   ""; 0b00; MEM<4> (addr) := X(rt) as Word))
    $MemoryInstr ($memmodel; $i; "X"  ; (XSize; XWord;   ""; 0b00; MEM<8> (addr) := X(rt)        ))
    }

  model LoadInstr (memmodel: MemoryModel, i: InstrNoFunct): IsaDefs = {
    $MemoryInstr ($memmodel; $i; "B"  ; (WSize; Byte ;  "b"; 0b01; X(rt) := MEM<1> (addr) as UIntX))
    $MemoryInstr ($memmodel; $i; "H"  ; (WSize; Half ;  "h"; 0b01; X(rt) := MEM<2> (addr) as UIntX))
    $MemoryInstr ($memmodel; $i; "W"  ; (WSize; Word ;   ""; 0b01; X(rt) := MEM<4> (addr) as UIntX))
    $MemoryInstr ($memmodel; $i; "X"  ; (XSize; XWord;   ""; 0b01; X(rt) := MEM<8> (addr)         ))
    $MemoryInstr ($memmodel; $i; "SBX"; (XSize; Byte ; "sb"; 0b10; X(rt) := MEM<1> (addr) as SIntX))
    $MemoryInstr ($memmodel; $i; "SHX"; (XSize; Half ; "sh"; 0b10; X(rt) := MEM<2> (addr) as SIntX))
    $MemoryInstr ($memmodel; $i; "SWX"; (XSize; Word ; "sw"; 0b10; X(rt) := MEM<4> (addr) as SIntX))
    $MemoryInstr ($memmodel; $i; "SBW"; (WSize; Byte ; "sb"; 0b11; X(rt) := MEM<1> (addr) as SIntW as BitsW as BitsX))
    $MemoryInstr ($memmodel; $i; "SHW"; (WSize; Half ; "sh"; 0b11; X(rt) := MEM<2> (addr) as SIntW as BitsW as BitsX))
    }

  model LoadLitInstr (memmodel: MemoryModel, i: InstrNoFunct): IsaDefs = {
    $MemoryInstr ($memmodel; $i; "W"  ; (WSize; Word ; ""  ; 0b00; X(rt) := MEM<4> (addr) as UIntX))
    $MemoryInstr ($memmodel; $i; "X"  ; (XSize; XWord; ""  ; 0b01; X(rt) := MEM<8> (addr)         ))
    $MemoryInstr ($memmodel; $i; "SWX"; (XSize; Word ; "sw"; 0b10; X(rt) := MEM<4> (addr) as SIntX))
    }


// memory register pair models *************************************************

  format MemoryPairFormat: Instr =    // load / store register pairs format
    { opc      [31..30,26,22]         // opcode kind memory operation
    , op       [29..27,25..23]        // opcode and addressing mode
    , imm7     [21..15]    : Bits7    // signed offset
    , rt2      [14..10]    : Index    // 2nd source or target register
    , rn       [9..5]      : Index    // base register (SP)
    , rt       [4..0]      : Index    // source or target register
    , offWSize = imm7 as SIntX << 2   // sign extended and shifted offset W
    , offXSize = imm7 as SIntX << 3   // sign extended and shifted offset X
    }

  model MemoryRegPairEncAsm (i: InstrWithFunct, extId: Str, size: Id, isLoad: Bool, op: Bin, asm: Ex): IsaDefs = {
    encoding AsId ($i.id, $extId) = { opc = $i.opcode, op = $op }
    assembly AsId ($i.id, $extId) = ($i.mnemo, ' ', $size(rt), ', ', $size(rt2), $asm)
    }

  model MemoryRegPairInstr (i: InstrWithFunct, size: Id, isLoad: Bool, memstmts: Stats): IsaDefs = {
    // TODO check SP alignment
    // [undefined when : match: Ex ( $isLoad = true => Ex1 ; _=> Ex2)]
    instruction $i.id: MemoryPairFormat = 
      let addr = S(rn) + AsId (off, $size) in { $memstmts }
    $MemoryRegPairEncAsm ($i; ""; $size; $isLoad; 0b101'010; ("[", XSizeSP(rn), Imm7decimal(imm7), "]"))
    // [undefined when : match: Ex ( $isLoad = true => Ex1 ; _=> Ex2)]
    instruction AsId ($i.id, "Pre"): MemoryPairFormat =
      let addr = S(rn) + AsId (off, $size) in {
          $memstmts
          S(rn) := addr
        }
    $MemoryRegPairEncAsm ($i; "Pre"; $size; $isLoad; 0b101'011; ("[", XSizeSP(rn), Imm7decimal(imm7), "]!"))
    // [undefined when : match: Ex ( $isLoad = true => Ex1 ; _=> Ex2)]
    instruction AsId ( $i.id, "Pst"): MemoryPairFormat =
      let addr = S(rn) in {
          $memstmts
          S(rn) := addr + AsId (off, $size)
        }
    $MemoryRegPairEncAsm ($i; "Pst"; $size; $isLoad; 0b101'001; ("[", XSizeSP(rn), "]", Imm7decimal(imm7)))
    }

  model LoadPairInstrW (i: InstrWithFunct): IsaDefs = {
    $MemoryRegPairInstr ($i; WSize; true; X(rt) := MEM<4> (addr) as $i.funct   X(rt2) := MEM<4> (addr + 4) as $i.funct)
    }

  model LoadPairInstrX (i: InstrWithFunct): IsaDefs = {
    $MemoryRegPairInstr ($i; XSize; true; X(rt) := MEM<8> (addr)               X(rt2) := MEM<8> (addr + 8))
    }

  model StorePairInstrW (i: InstrWithFunct): IsaDefs = {
    $MemoryRegPairInstr ($i; WSize; false; MEM<4> (addr) := X(rt) as BitsW     MEM<4> (addr + 4) := X(rt2) as BitsW)
    }

  model StorePairInstrX (i: InstrWithFunct): IsaDefs = {
    $MemoryRegPairInstr ($i; XSize; false; MEM<8> (addr) := X(rt)              MEM<8> (addr + 8) := X(rt2))
    }


// pseudo instruction models ***************************************************

  model PseudoMulInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    pseudo instruction $i.id (rd: Index, rn: Index, rm: Index) = {
      $i.funct {rd = rd, rn = rn, rm = rm, ra = $i.opcode}
      }
    assembly $i.id = ($i.mnemo, " ", $size(rd), ", ", $size(rn), ", ", $size(rm))
    }

  model Pseudo3OpInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    pseudo instruction $i.id (rd: Index, rn: Index, rm: Index) = {
      $i.funct {rd = rd, rn = rn, rm = rm}
      }
    assembly $i.id = ($i.mnemo, " ", $size(rd), ", ", $size(rn), ", ", $size(rm))
    }

  model PseudoShiftRightInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    pseudo instruction $i.id (rd: Index, rn: Index, shift: Bits6) = {
      $i.funct {rd = rd, rn = rn, immr = shift as Bits<ShiftSize::$size> as Bits6, imms = Size::$size - 1}
      }
    assembly $i.id = ($i.mnemo, " ", $size(rd), ", ", $size(rn), ", #", decimal(shift))
    }

  model PseudoShiftLeftInstr (i: InstrWithFunct, size: Id): IsaDefs = {
    pseudo instruction $i.id (rd: Index, rn: Index, shift: Bits6) = {
      $i.funct{rd = rd, rn = rn, immr = - shift as Bits<ShiftSize::$size> as Bits6,
                 imms = Size::$size - 1 - shift as Bits<ShiftSize::$size> as Bits6}
      }
    assembly $i.id = ($i.mnemo, " ", $size(rd), ", ", $size(rn), ", #", decimal(shift))
    }


// instruction enriching models ************************************************

  model InstrWX (modelid: InstrWithFunctSize, i: InstrWithFunct): IsaDefs = {
    $modelid ($ExtInstrStr ($i;  "W"); WSize)
    $modelid ($ExtInstrStr ($i;  "X"); XSize)
    }

  model InstrWXFlags (modelid: InstrWithFunctSizeFlags, i: InstrWithFunct): IsaDefs = {
    $modelid ($ExtInstrStr ($i;  "W"); WSize; (WResult  ; OffFlags;  ""))
    $modelid ($ExtInstrStr ($i;  "X"); XSize; (XResult  ; OffFlags;  ""))
    $modelid ($ExtInstrStr ($i; "WS"); WSize; (WResFlags; SetFlags; "s"))
    $modelid ($ExtInstrStr ($i; "XS"); XSize; (XResFlags; SetFlags; "s"))
    }

  model InstrWXRegShift (modelid: InstrWithFunctSizeRegShift, i: InstrWithFunct): IsaDefs = {
    $LogicRegShiftInstr ($modelid; $ExtInstrStr ($i; "W"); WSize)
    $LogicRegShiftInstr ($modelid; $ExtInstrStr ($i; "X"); XSize)
    }

  model ExtPseudoStr (i: InstrWithFunct, ext: Str): InstrWithFunct = {
    (AsId ($i.id, $ext); $i.mnemo; $i.opcode; AsId ($i.funct, $ext))
    }

  model PseudoWX (modelid: InstrWithFunctSize, i: InstrWithFunct): IsaDefs = {
    $modelid ($ExtPseudoStr ($i;  "W"); WSize)
    $modelid ($ExtPseudoStr ($i;  "X"); XSize)
    }


// base instructions ***********************************************************

  $InstrWXFlags        (AddSubExtInstr        ; (ADD    ; "add"   ; 0b0'0101'1001         ; adds       ))
  $InstrWXFlags        (AddSubImmInstr        ; (ADD    ; "add"   ; 0b0'1000'10           ; adds       ))
  $InstrWXFlags        (AddSubSftInstr        ; (ADD    ; "add"   ; 0b0'0101'10           ; adds       ))
  $InstrWXFlags        (AddSubExtInstr        ; (SUB    ; "sub"   ; 0b1'0101'1001         ; subsc      ))
  $InstrWXFlags        (AddSubImmInstr        ; (SUB    ; "sub"   ; 0b1'1000'10           ; subsc      ))
  $InstrWXFlags        (AddSubSftInstr        ; (SUB    ; "sub"   ; 0b1'0101'10           ; subsc      ))
  $InstrWX             (AddSubCarryInstr      ; (ADC    ; "adc"   ; 0b0011'0100'0000'0000 ; addc       ))
  $InstrWX             (AddSubCarryFlagInstr  ; (ADCS   ; "adcs"  ; 0b0111'0100'0000'0000 ; addc       ))
  $InstrWX             (AddSubCarryInstr      ; (SBC    ; "sbc"   ; 0b1011'0100'0000'0000 ; subc       ))
  $InstrWX             (AddSubCarryFlagInstr  ; (SBCS   ; "sbcs"  ; 0b1111'0100'0000'0000 ; subc       ))

  $AddressRelInstr     (                        (ADR    ; "adr"   ; 0b01'0000                          ))
  $AddressPageInstr    (                        (ADRP   ; "adrp"  ; 0b11'0000                          ))

  $InstrWX             (MulAddSubInstr        ; (MADD   ; "madd"  ; 0b0011'0110'000       ; add        ))
  $InstrWX             (MulAddSubInstr        ; (MSUB   ; "msub"  ; 0b0011'0110'001       ; sub        ))
  $SMulAddSubLongInstr (                        (SMADDL ; "smaddl"; 0b0011'0110'010       ; add        ))
  $SMulAddSubLongInstr (                        (SMSUBL ; "smsubl"; 0b0011'0110'011       ; sub        ))
  $UMulAddSubLongInstr (                        (UMADDL ; "umaddl"; 0b0011'0111'010       ; add        ))
  $UMulAddSubLongInstr (                        (UMSUBL ; "umsubl"; 0b0011'0111'011       ; sub        ))
  $MulHighInstr        (                        (SMULH  ; "smulh" ; 0b0011'0110'1001'1111 ; SInt       ))
  $MulHighInstr        (                        (UMULH  ; "umulh" ; 0b0011'0111'1001'1111 ; UInt       ))

  $InstrWX             (DivInstr              ; (SDIV   ; "sdiv"  ; 0b0011'0101'1000'0011 ; SInt       ))
  $InstrWX             (DivInstr              ; (UDIV   ; "udiv"  ; 0b0011'0101'1000'0010 ; UInt       ))

  $InstrWX             (LogicImmInstr         ; (ANDI   ; "and"   ; 0b0010'0100           ; and        ))
  $InstrWX             (LogicImmFlagInstr     ; (ANDSI  ; "ands"  ; 0b1110'0100           ; ands       ))
  $InstrWX             (LogicImmInstr         ; (EORI   ; "eor"   ; 0b1010'0100           ; xor        ))
  $InstrWX             (LogicImmInstr         ; (ORRI   ; "orr"   ; 0b0110'0100           ; or         ))

  $InstrWXRegShift     (LogicRegBasicInstr    ; (AND    ; "and"   ; 0b0001'0100           ; ands       ))
  $InstrWXRegShift     (LogicRegFlagInstr     ; (ANDS   ; "ands"  ; 0b1101'0100           ; ands       ))
  $InstrWXRegShift     (LogicRegBasicInstr    ; (EOR    ; "eor"   ; 0b1001'0100           ; xors       ))
  $InstrWXRegShift     (LogicRegBasicInstr    ; (ORR    ; "orr"   ; 0b0101'0100           ; ors        ))
  $InstrWXRegShift     (LogicRegNegInstr      ; (BIC    ; "bic"   ; 0b0001'0101           ; ands       ))
  $InstrWXRegShift     (LogicRegNegFlagInstr  ; (BICS   ; "bics"  ; 0b1101'0101           ; ands       ))
  $InstrWXRegShift     (LogicRegNegInstr      ; (EON    ; "eon"   ; 0b1001'0101           ; xors       ))
  $InstrWXRegShift     (LogicRegNegInstr      ; (ORN    ; "orn"   ; 0b0101'0101           ; ors        ))

  $InstrWX             (ShiftRegInstr         ; (ASR    ; "asrv"  ; ASR                   ; asr        ))
  $InstrWX             (ShiftRegInstr         ; (LSL    ; "lslv"  ; LSL                   ; lsl        ))
  $InstrWX             (ShiftRegInstr         ; (LSR    ; "lsrv"  ; LSR                   ; lsr        ))
  $InstrWX             (ShiftRegInstr         ; (ROR    ; "rorv"  ; ROR                   ; ror        ))

  $InstrWX             (MovKInstr             ; (MOVK   ; "movk"  ; 0b1110'0101           ; unused     ))
  $InstrWX             (MovNZInstr            ; (MOVN   ; "movn"  ; 0b0010'0101           ; not        ))
  $InstrWX             (MovNZInstr            ; (MOVZ   ; "movz"  ; 0b1010'0101           ; ident      ))

  $InstrWX             (ExtractRegPairInstr   ; (EXTR   ; "extr"  ; 0b0'0100'1110         ; Bits       ))
  $InstrWX             (BitfieldMoveInstr     ; (BFM    ; "bfm"   ; 0b0110'0110           ; Bits       ))
  $InstrWX             (BitfieldMoveInstr     ; (SBFM   ; "sbfm"  ; 0b0010'0110           ; SInt       ))
  $InstrWX             (BitfieldMoveInstr     ; (UBFM   ; "ubfm"  ; 0b1010'0110           ; UInt       ))

  $InstrWX             (CountBitsInstr        ; (CLS    ; "cls"   ; 0b1'0110'1011'0000'0000'0101; cls  ))
  $InstrWX             (CountBitsInstr        ; (CLZ    ; "clz"   ; 0b1'0110'1011'0000'0000'0100; clz  ))
  $InstrWX             (ReverseBitsInstr      ; (RBIT   ; "rbit"  ; 0b1'0110'1011'0000'0000'0000; rvb  ))
  $InstrWX             (RevBytesHInstr        ; (REV16  ; "rev16" ; 0b1'0110'1011'0000'0000'0001; half ))
  $RevBytesWInstr      (                        (REV32  ; "rev32" ; 0b1'0110'1011'0000'0000'0010; XSize))
  $RevBytesWInstr      (                        (REVW   ; "rev"   ; 0b1'0110'1011'0000'0000'0010; WSize))
  $RevBytesXInstr      (                        (REVX   ; "rev"   ; 0b1'0110'1011'0000'0000'0011; XSize))

  $CondInstr           (CondCompareImmInstr   ; (CCMNI  ; "ccmn"  ; 0b0111'0100'1010'0    ; adds       ))
  $CondInstr           (CondCompareImmInstr   ; (CCMPI  ; "ccmp"  ; 0b1111'0100'1010'0    ; subsc      ))
  $CondInstr           (CondCompareRegInstr   ; (CCMN   ; "ccmn"  ; 0b0111'0100'1000'0    ; adds       ))
  $CondInstr           (CondCompareRegInstr   ; (CCMP   ; "ccmp"  ; 0b1111'0100'1000'0    ; subsc      ))

  $CondInstr           (CondSelectInstr       ; (CSEL   ; "csel"  ; 0b0011'0101'0000      ; equ        ))
  $CondInstr           (CondSelectInstr       ; (CSINC  ; "csinc" ; 0b0011'0101'0001      ; inc        ))
  $CondInstr           (CondSelectInstr       ; (CSINV  ; "csinv" ; 0b1011'0101'0000      ; not        ))
  $CondInstr           (CondSelectInstr       ; (CSNEG  ; "csneg" ; 0b1011'0101'0001      ; neg        ))

  $BranchInstr         (                        (B      ; "b"     ; 0b0001'01                          ))
  $BranchLinkInstr     (                        (BL     ; "bl"    ; 0b1001'01                          ))
  $BranchRegInstr      (                        (BR     ; "br"    ; 0b1101'0110'0001'1111'0000'0000'000))
  $BranchRegInstr      (                        (RET    ; "ret"   ; 0b1101'0110'0101'1111'0000'0000'000))
  $BranchRegLinkInstr  (                        (BLR    ; "blr"   ; 0b1101'0110'0011'1111'0000'0000'000))
  $CondInstr           (CondBranchInstr       ; (B_     ; "b."    ; 0b0101'0100'0         ; unused     ))
  $InstrWX             (CompareBranchInstr    ; (CBZ    ; "cbz"   ; 0b0110'100            ; equ        ))
  $InstrWX             (CompareBranchInstr    ; (CBNZ   ; "cbnz"  ; 0b0110'101            ; neq        ))
  $TestBitBranchInstr  (                        (TBZ    ; "tbz"   ; 0b0110'110            ; equ        ))
  $TestBitBranchInstr  (                        (TBNZ   ; "tbnz"  ; 0b0110'111            ; neq        ))

  $LoadInstr           (MemoryPreIndexInstr   ; (LDRPre ; "ldr"   ; 0b111'000'011                      ))
  $StoreInstr          (MemoryPreIndexInstr   ; (STRPre ; "str"   ; 0b111'000'011                      ))
  $LoadInstr           (MemoryPostIndexInstr  ; (LDRPst ; "ldr"   ; 0b111'000'001                      ))
  $StoreInstr          (MemoryPostIndexInstr  ; (STRPst ; "str"   ; 0b111'000'001                      ))
  $LoadInstr           (MemoryOffsetInstr     ; (LDR    ; "ldr"   ; 0b111'001                          ))
  $StoreInstr          (MemoryOffsetInstr     ; (STR    ; "str"   ; 0b111'001                          ))
  $LoadInstr           (MemoryRegisterInstr   ; (LDRReg ; "ldr"   ; 0b111'000'110                      ))
  $StoreInstr          (MemoryRegisterInstr   ; (STRReg ; "str"   ; 0b111'000'110                      ))
  $LoadInstr           (MemoryUnscaledInstr   ; (LDUR   ; "ldur"  ; 0b111'000'000                      ))
  $StoreInstr          (MemoryUnscaledInstr   ; (STUR   ; "stur"  ; 0b111'000'000                      ))
  $LoadLitInstr        (MemoryLiteralInstr    ; (LDRLit ; "ldr"   ; 0b011'000                          ))

  $LoadPairInstrW      (                        (LDPW   ; "ldp"   ; 0b0001                ; UIntX      ))
  $LoadPairInstrW      (                        (LDPS   ; "ldpsw" ; 0b0101                ; SIntX      ))
  $LoadPairInstrX      (                        (LDPX   ; "ldp"   ; 0b1001                ; BitsX      ))
  $StorePairInstrW     (                        (STPW   ; "stp"   ; 0b0000                ; BitsX      ))
  $StorePairInstrX     (                        (STPX   ; "stp"   ; 0b1000                ; BitsX      ))

  $PseudoWX            (PseudoMulInstr        ; (MUL    ; "mul"   ; 0b1'1111              ; MADD       ))
  $PseudoWX            (Pseudo3OpInstr        ; (ASRV   ; "asr"   ; 0                     ; ASR        ))
  $PseudoWX            (Pseudo3OpInstr        ; (LSRV   ; "lsr"   ; 0                     ; LSR        ))
  $PseudoWX            (Pseudo3OpInstr        ; (LSLV   ; "lsl"   ; 0                     ; LSL        ))
  $PseudoWX            (PseudoShiftRightInstr ; (ASRI   ; "asr"   ; 0b11'1111             ; SBFM       ))
  $PseudoWX            (PseudoShiftRightInstr ; (LSRI   ; "lsr"   ; 0b11'1111             ; UBFM       ))
  $PseudoWX            (PseudoShiftLeftInstr  ; (LSLI   ; "lsl"   ; 0b11'1111             ; UBFM       ))

//}
//
//instruction set architecture AArch64Sys extending AArch64Base = {

  enumeration ExceptionClass: Bits6 =        // exception class (of exception syndrome register)
    {Uncategorized           = 0x00          //  0 Uncategorized or unknown reason (e.g. undefined instruction)
    ,WFxAccessTrap           = 0x01          //  1 Trapped WFI or WFE instruction
    ,AdvSIMDFPAccessTrap     = 0x07          //  7 HCPTR-trapped access to SIMD or FP
    ,UncoveredException      = 0x0A          // 10 Trapped execution of any instruction not covered by other EC values
    ,BranchTarget            = 0x0D          // 13 Branch Target Exception
    ,IllegalState            = 0x0E          // 14 Illegal Execution state
    ,SupervisorCall          = 0x15          // 21 Supervisor Call
    ,InstructionAbortLowerEL = 0x20          // 32 Instruction Abort from a lower Exception level
    ,InstructionAbortSameEL  = 0x21          // 33 Instruction Abort taken without a change in Exception level
    ,PCAlignment             = 0x22          // 34 PC alignment fault
    ,DataAbortLowerEL        = 0x24          // 36 Data Abort exception from a lower Exception level
    ,DataAbortSameEL         = 0x25          // 37 Data Abort exception taken without a change in Exception level
    ,SPAlignment             = 0x26          // 38 SP alignment fault
    ,MemoryOperation         = 0x27          // 38 Memory Operation Exception
    ,FPTrappedException      = 0x2C          // 44 IEEE trapped FP exception
    ,SError                  = 0x2F          // 47 SError interrupt
    ,BreakpointLowerEL       = 0x30          // 48 Breakpoint exception from a lower Exception level
    ,BreakpointSameEL        = 0x31          // 49 Breakpoint exception taken without a change in Exception level
    ,SoftwareStepLowerEL     = 0x32          // 50 Software Step exception from a lower Exception level
    ,SoftwareStepSameEL      = 0x33          // 51 Software Step exception taken without a change in Exception level
    ,WatchpointLowerEL       = 0x34          // 52 Watchpoint exception from a lower Exception level
    ,WatchpointSameEL        = 0x35          // 53 Watchpoint exception taken without a change in Exception level
    ,SoftwareBreakpoint      = 0x3C          // 60 BRK instruction execution
    ,ProfilingException      = 0x3D          // 61 Profiling Exception
    }

  format ExceptionSyndromeFormat: BitsX =    // exception syndrome register format
    { Res0    : Bits8                        // [63..56] reserved
    , ISS2    : Bits24                       // [55..32] instruction specific syndrome extension
    , EC      : Bits6                        // [31..26] exception class
    , IL      : Bits1                        // [25]     instruction length
    , ISS     : Bits25                       // [24..0]  instruction specific syndrome
    }

  format SavedProgramStateFormat: BitsX =    // saved program state register format
    { Res0    [63..37]                       // reserved
    , UINJ    [36]                           // INJect Undefined instruction exception
    , PACM    [35]                           // PACM
    , EXLOCK  [34]                           // Exception return state lock
    , PPEND   [33]                           // PMU Profiling exception pending bit
    , PM      [32]                           // Profiling exception mask bit
    , NZCV    [31..28]                       // condition flags (negative, zero, carry, overflow)
    , Res1    [27..26]                       // reserved
    , TCO     [25]                           // tag check override
    , DIT     [24]                           // data independent timing
    , UAO     [23]                           // user access override
    , PAN     [22]                           // privileged access never
    , SS      [21]                           // software step
    , IL      [20]                           // illegal execution state
    , Res2    [19..14]                       // reserved
    , ALLINT  [13]                           // All IRQ or FIQ interrupts mask
    , SSBS    [12]                           // speculative store bypass
    , BTYPE   [11..10]                       // branch type indicator
    , D       [9]                            // debug  exception mask
    , A       [8]                            // SError interrupt mask
    , I       [7]                            // IRQ    interrupt mask
    , F       [6]                            // FIQ    interrupt mask
    , Res3    [5]                            // reserved
    , M4      [4]                            // execution state (0b0 AArch64 execution state)
    , M       [3..0]                         // exception level and selected stack pointer
    }

  enumeration SysRegEncode: Bits16 =         // system register encoding
    { NZCV      = 0b11'011'0100'0010'000     // condition flag register
    , CurrentEL = 0b11'000'0100'0010'010     // Current Exception Level register
    , SPSel     = 0b11'000'0100'0010'000     // stack pointer select register
    , SP_EL0    = 0b11'000'0100'0001'000     // stack pointer register exception level 0
    , SP_EL1    = 0b11'100'0100'0001'000     // stack pointer register exception level 1
    , ELR_EL1   = 0b11'000'0100'0000'001     // exception link register exception level 1
    , VBAR_EL1  = 0b11'000'1100'0000'000     // vector base address register exception level 1
    , ESR_EL1   = 0b11'000'0101'0010'000     // exception syndrome register exception level 1
    , SPSR_EL1  = 0b11'000'0100'0000'000     // saved program state register exception level 1
    }

  register CurrentEL:Bits2                   // exception level register
  register SPSel:    Bits1                   // stack pointer select register
  register SP_EL0:   Address                 // stack pointer exception level level 0
  register SP_EL1:   Address                 // stack pointer exception level level 1
  register ELR_EL1:  Address                 // exception link register exception level level 1
  register VBAR_EL1: Address                 // vector base address register exception level 1
  register ESR_EL1:  ExceptionSyndromeFormat // exception syndrome register exception level level 1
  register SPSR_EL1: SavedProgramStateFormat // saved program state register exception level level 1

  model SaveProgramState (): Stats = {
    SPSR_EL1 := (SPSR_EL1(63..32), NZCV_N, NZCV_Z, NZCV_C, NZCV_V, SPSR_EL1(27..4), SPSel as Bits4 | 0b0100)
    }

  model RestoreProgramState (): Stats = {
    NZCV_N := SPSR_EL1.NZCV(3)
    NZCV_Z := SPSR_EL1.NZCV(2)
    NZCV_C := SPSR_EL1.NZCV(1)
    NZCV_V := SPSR_EL1.NZCV(0)
    }

  exception GeneralException (exClass: Bits6, syndrome: Bits25, continuation: Address, exOffset: Address) = {
    if CurrentEL = 0 then {
      $SaveProgramState ()
      if SPSel != 0 then {
        SP_EL0 := SP
        SP := SP_EL1
      }
      ESR_EL1.EC  := exClass
      ESR_EL1.IL  := 0b1
      ESR_EL1.ISS := syndrome
      CurrentEL   := 1
      ELR_EL1     := continuation
      PC          := VBAR_EL1 + exOffset
      }
    }

  model UndefinedException (): Stat = {
    GeneralException (ExceptionClass::Uncategorized, 0, PC, 0)
    }

  model ReturnFromException (): Stats = {
    if CurrentEL = 0
      then raise $UndefinedException ()
      else {
        $RestoreProgramState ()
        if SPSel != 0 then {
          SP_EL1 := SP
          SP := SP_EL0
          }
        CurrentEL := 0
        PC := ELR_EL1
        }
    }

  format MoveSystemRegFormat: Instr =        // move system register format
    { op        : Bits12                     // [31..20] opcode
    , rs        : Bits15                     // [20..5]  system register code without leading one
    , rt        : Index                      // [4..0]   source/target register
    , sysreg    = (true, rs)
    }

  format SuperVisorCallFormat: Instr =       // supervisor call format
    { op       [31..21,4..0] : Bits16        // opcode
    , imm16    [20..5]       : Bits16        // system call number
    }

  format UndefinedInstrFormat: Instr =       // undefined instruction format
    { op       : Bits16                      // [31..16] opcode
    , imm16    : Bits16                      // [15..0]  ignored
    }

  format BTIFormat: Instr =                  // Branch target identification format
    { op       [31..16]      : Bits16        // opcode part one
    , opc      [15..8,5..0]  : Bits14        // opcode part two
    , bti      [7..6]        : Bits2         // BTI target, PSTATE.BTYPE compatibility
  }

  function SysRegName (sysreg: Bits16) -> String =
    match sysreg with
      { SysRegEncode::NZCV      => "nzcv"
      , SysRegEncode::CurrentEL => "currentel"
      , SysRegEncode::SPSel     => "spsel"
      , SysRegEncode::SP_EL0    => "sp_el0"
      , SysRegEncode::SP_EL1    => "sp_el1"
      , SysRegEncode::ELR_EL1   => "elr_el1"
      , SysRegEncode::ESR_EL1   => "esr_el1"
      , SysRegEncode::SPSR_EL1  => "spsr_el1"
      , SysRegEncode::VBAR_EL1  => "vbar_el1"
      , _ => ("S", decimal(sysreg(15..14)), "_",
                   decimal(sysreg(13..11)), "_",
                   decimal(sysreg(10.. 7)), "_",
                   decimal(sysreg( 6.. 3)), "_",
                   decimal(sysreg( 2.. 0)))
      }

  model MrsRegInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: MoveSystemRegFormat =
      if sysreg = SysRegEncode::NZCV
        then X(rt) := (NZCV_N, NZCV_Z, NZCV_C, NZCV_V) as BitsX << 28
        else if CurrentEL = 0
        then raise $UndefinedException ()
        else match sysreg with
          { SysRegEncode::CurrentEL => X(rt) := CurrentEL as BitsX << 2
          , SysRegEncode::SPSel     => X(rt) := SPSel as BitsX
          , SysRegEncode::ESR_EL1   => X(rt) := ESR_EL1
          , SysRegEncode::SPSR_EL1  => X(rt) := SPSR_EL1
          , SysRegEncode::SP_EL0    => if SPSel = 0
                                       then raise $UndefinedException ()
                                       else X(rt) := SP_EL0
          , SysRegEncode::SP_EL1    => if SPSel = 0
                                       then raise $UndefinedException ()
                                       else let sp = SP in {
                                         SP_EL1 := sp
                                         X(rt) := sp
                                         }
          , SysRegEncode::ELR_EL1   => X(rt) := ELR_EL1
          , SysRegEncode::VBAR_EL1  => X(rt) := VBAR_EL1
          , _                       => raise $UndefinedException ()
          }
    encoding $i.id = {op = $i.opcode}
    assembly $i.id = ($i.mnemo, ' ', XSize(rt), ', ', SysRegName(sysreg))
    }

  model MsrRegInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: MoveSystemRegFormat =
      if sysreg = SysRegEncode::NZCV
        then {
          NZCV_N := X(rt)(31)
          NZCV_Z := X(rt)(30)
          NZCV_C := X(rt)(29)
          NZCV_V := X(rt)(28)
          }
        else if CurrentEL = 0
        then raise $UndefinedException ()
        else match sysreg with
          { SysRegEncode::CurrentEL => raise $UndefinedException ()
          , SysRegEncode::SPSR_EL1  => SPSR_EL1 := X(rt)
          , SysRegEncode::ESR_EL1   => ESR_EL1 := X(rt)
          , SysRegEncode::SPSel     => SPSel := X(rt)(0)
          , SysRegEncode::SP_EL0    => SP_EL0 := X(rt)
          , SysRegEncode::SP_EL1    => if SPSel = 0
                                     then raise $UndefinedException ()
                                     else let sp = X(rt) in {
                                       SP_EL1 := sp
                                       SP := sp
                                       }
          , SysRegEncode::ELR_EL1   => ELR_EL1 := X(rt)
          , SysRegEncode::VBAR_EL1  => VBAR_EL1 := X(rt)
          , _                     => raise $UndefinedException ()
          }
    encoding $i.id = {op = $i.opcode}
    assembly $i.id = ($i.mnemo, ' ', SysRegName(sysreg), ', ', XSize(rt))
    }

  model ExceptionCallEncAsm (i: InstrWithFunct): IsaDefs = {
    encoding $i.id = {op = $i.opcode}
    assembly $i.id = ($i.mnemo, ' #', decimal(imm16))
    }

  model ExceptionCallInstr (i: InstrWithFunct): IsaDefs = {
    instruction $i.id: SuperVisorCallFormat = {
      raise GeneralException (ExceptionClass::$i.funct, 0, PC.next, 0)
      }
    $ExceptionCallEncAsm ($i)
    }

  model HaltInstr (i: InstrWithFunct): IsaDefs = {
    instruction $i.id: SuperVisorCallFormat = {}
    $ExceptionCallEncAsm ($i)
    }

  model ExceptionReturnInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: UndefinedInstrFormat = {
      $ReturnFromException()
      }
    encoding $i.id = {op = $i.opcode, imm16 = 0b0000'0011'1110'0000}
    assembly $i.id = ($i.mnemo)
    }

  model NopInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: UndefinedInstrFormat = {}
    encoding $i.id = {op = 0b1101'0101'0000'0011, imm16 = $i.opcode}
    assembly $i.id = ($i.mnemo)
    }

  function btiOp2(bti: Bits2) -> String = match bti with
    { 0b01 => "c"
    , 0b10 => "j"
    , 0b11 => "jc"
    , _    => ""
    }

  model BTIInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: BTIFormat = {}
    encoding $i.id = {op = 0b1101'0101'0000'0011, opc = $i.opcode}
    assembly $i.id = ($i.mnemo, btiOp2(bti))
    }

  model UndefinedInstr (i: InstrNoFunct): IsaDefs = {
    instruction $i.id: UndefinedInstrFormat =
      raise $UndefinedException ()
    encoding $i.id = {op = $i.opcode}
    assembly $i.id = ($i.mnemo)
    }

  $MsrRegInstr           ((MSR    ; "msr"   ; 0b1101'0101'0001                             ))
  $MrsRegInstr           ((MRS    ; "mrs"   ; 0b1101'0101'0011                             ))
  $ExceptionCallInstr    ((BRK    ; "brk"   ; 0b1101'0100'0010'0000   ; SoftwareBreakpoint ))
  $ExceptionCallInstr    ((SVC    ; "svc"   ; 0b1101'0100'0000'0001   ; SupervisorCall     ))
  $ExceptionReturnInstr  ((ERET   ; "eret"  ; 0b1101'0110'1001'1111                        ))
  $HaltInstr             ((HLT    ; "hlt"   ; 0b1101'0100'0100'0000                        ))
  $NopInstr              ((NOP    ; "nop"   ; 0b0010'0000'0001'1111                        ))
  $NopInstr              ((YIELD  ; "yield" ; 0b0010'0000'0011'1111                        ))
  $BTIInstr              ((BTI    ; "bti"   ; 0b0010'0100'''01'1111                        ))
  $UndefinedInstr        ((UDF    ; "udf"   ; 0b0000'0000'0000'0000                        ))

}
