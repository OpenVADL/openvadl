$package=vadl.ast
import java.util.ArrayList;
import java.util.List;

import vadl.ast.Ast;
import vadl.ast.Expr;
import vadl.ast.Stmt;
import static vadl.ast.IndexDefinitionStmt.IndexKind.GROUP;
import static vadl.ast.IndexDefinitionStmt.IndexKind.PROGRAM;

import vadl.types.BitsType;
import vadl.types.BoolType;
import vadl.types.Type;
import vadl.types.SIntType;
import vadl.types.UIntType;


COMPILER vadl
    Ast ast = new Ast();
    SymbolTable symbolTable = new SymbolTable();

    Location locationFromToken(Token token) {
        return new Location("unknown.vadl", token.line,  token.line, token.col, token.col + token.val.length());
    }



CHARACTERS
    digit = '0' .. '9'.
    letter = 'a' .. 'z' + 'A' .. 'Z'.

TOKENS
    number = digit {digit}.
    identifierToken = letter {letter | digit | '_'}.

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
    vadl =
    {
        definition<out Definition definition>   (. ast.definitions.add(definition); .)
    }.

    // -- DEFINITIONS --------------------------------------------------------------------------------------------------
    definition<out Definition definition>                               (. definition = null; .)
    = instructionsetDefinition<out InstructionSetDefinition isaDef>     (. definition = isaDef; .)
    | commonDefinition<out CommonDefinition commonDef>                  (. definition = commonDef; .)
    .

    commonDefinition<out CommonDefinition common>   (.common = null;.)
    = constantStatement<out Stmt stmt>              (. common = new CommonDefinition(stmt); .)
    | formatStatement<out Stmt stmt>                (. common = new CommonDefinition(stmt); .)
    .

    instructionsetDefinition<out InstructionSetDefinition isaDef> (. var statements = new ArrayList<Stmt>(); .)
    = "instruction" (. var startLocation = locationFromToken(t);.)
       "set" "architecture" identifier<out Identifier identifier>
       "=" "{"
      {
        // FIXME: In the future this will be wrong as not all statements should be accepted here.
        isaStatement<out Stmt stmt>    (. statements.add(stmt); .)
      }
      "}"   (. isaDef = new InstructionSetDefinition(identifier, statements, new Location(startLocation, locationFromToken(t))); .)
      .

    isaStatement<out Stmt stmt>                         (. stmt = null; .)
    = constantStatement<out Stmt s1>                    (. stmt = s1; .)
    | formatStatement<out Stmt s1>                      (. stmt = s1; .)
    | indexStatement<out Stmt s1>                       (. stmt = s1; .)
    | memoryStatement<out Stmt s1>                      (. stmt = s1; .)
    | registerAndRegisterFileStatement<out Stmt s1>     (. stmt = s1; .)
    .


    // -- STATEMENTS ---------------------------------------------------------------------------------------------------
    constantStatement<out ConstantDefinitionStmt stmt>                (. TypeLiteral type = null; .)
    = "constant"                            (. var startLocation = locationFromToken(t); .)
        identifier<out Identifier id>       (. symbolTable.addDefinition(id); .)
        [
            ':' typeLiteral<out TypeLiteral t1>    (. type = t1; .)
        ]
        '=' expression<out Expr expr>       (. stmt = new ConstantDefinitionStmt(id, type, expr, new Location(startLocation, locationFromToken(t))); .)
    .

    formatStatement<out FormatDefinitionStmt stmt>  (. List<FormatDefinitionStmt.FormatField> fields = new ArrayList<>();.)
    = "format"                                      (. var startLoc = locationFromToken(t); .)
    identifier<out Identifier id>
    ":" typeLiteral<out TypeLiteral type>
    ["=" "{"
        formatField<out FormatDefinitionStmt.FormatField f1>              (. fields.add(f1); .)
        {
        "," formatField<out FormatDefinitionStmt.FormatField f2>          (. fields.add(f2); .)
        }
    "}"]                                            (. stmt = new FormatDefinitionStmt(id, type, fields, new Location(startLoc, locationFromToken(t))); .)
    .

    // FIXME: more versions are missing here
    formatField<out FormatDefinitionStmt.FormatField field>
    = identifier<out Identifier id>  "["         (. List<RangeExpr> ranges = new ArrayList<>();.)
        rangeExpression<out RangeExpr e1>           (. ranges.add(e1); .)
        {
            "," rangeExpression<out RangeExpr e2>   (. ranges.add(e2); .)
        }
    "]"                                             (. field = new FormatDefinitionStmt.FormatField(id, ranges); .)
    .

    indexStatement<out IndexDefinitionStmt stmt>    (. IndexDefinitionStmt.IndexKind kind = null; .)
    = ("program"                                    (. kind = PROGRAM; .)
    |  "group"                                      (. kind = GROUP; .)
    )                                               (. var startLocation = locationFromToken(t); .)
    "counter"
        identifier<out Identifier id>               (. symbolTable.addDefinition(id); .)
        ":" typeLiteral<out TypeLiteral t1>         (. stmt = new IndexDefinitionStmt(kind, id, t1, new Location(startLocation, locationFromToken(t))); .)
    .

    memoryStatement<out MemoryDefinitionStmt stmt>
    = "memory"                              (. var startLocation = locationFromToken(t); .)
        identifier<out Identifier id>       (. symbolTable.addDefinition(id); .)
        ":" typeLiteral<out TypeLiteral t1>
        "->" typeLiteral<out TypeLiteral t2> (. stmt = new MemoryDefinitionStmt(id, t1, t2, new Location(startLocation, t2.location())); .)
    .

    registerAndRegisterFileStatement<out Stmt stmt> (. stmt = null; .)
        = "register"                                (. var startLocation = locationFromToken(t); .)
        (
            "file"
            identifier<out Identifier id>           (. symbolTable.addDefinition(id); .)
            ":" typeLiteral<out TypeLiteral t1>
            "->" typeLiteral<out TypeLiteral t2>    (. stmt = new RegisterFileDefinitionStmt(id, t1, t2, new Location(startLocation, t2.location())); .)
        |
            identifier<out Identifier id>           (. symbolTable.addDefinition(id); .)
            ":" typeLiteral<out TypeLiteral t1>     (. stmt = new RegisterDefinitionStmt(id, t1, new Location(startLocation, t1.location())); .)
        )
    .

    // -- EXPRESSIONS ---------------------------------------------------------------------------------------------------

    typeLiteral<out TypeLiteral type>       (. type = null; Expr sizeExpr = null; .)
    =
    "Bool"                                  (. var loc = locationFromToken(t); type = new TypeLiteral(new Identifier(t.val, loc), null, loc); .)
    |
     (
        identifier<out Identifier id>
        [ "<"
            term<out Expr expr>             (. sizeExpr = expr; .)
        ">" ]                               (. type = new TypeLiteral(id, sizeExpr, new Location(id.location(), locationFromToken(t))) ;.)
    )
    .

    expression<out Expr expr>
    = term<out Expr expr1>  (. expr = expr1; .)
    .

    term<out Expr expr>
    = factor<out Expr expr1>                   (. expr = expr1; .)
        {
            '+' factor<out Expr expr2>         (. expr = new BinaryExpr(expr, BinaryExpr.Operation.ADD, expr2); .)
        |   '-' factor<out Expr expr2>         (. expr = new BinaryExpr(expr, BinaryExpr.Operation.SUBTRACT, expr2); .)
        }
    .

    factor<out Expr expr>
    = primary<out Expr expr1>                 (. expr = expr1; .)
        {
            '*' primary<out Expr expr2>       (. expr = new BinaryExpr(expr, BinaryExpr.Operation.MULTIPLY, expr2); .)
        |   '/' primary<out Expr expr2>       (. expr = new BinaryExpr(expr, BinaryExpr.Operation.DIVIDE, expr2); .)
        }
    .

    primary<out Expr expr>                  (. expr = null; .)
    = number                                (. expr = new IntegerLiteral(Integer.parseInt(t.val), locationFromToken(t)); .)
    | identifier<out Identifier id>         (. expr = new Variable(id); symbolTable.addUsage(id); .)
    | '(' expression<out Expr expr1> ')'    (. expr = expr1; .)
    .

    rangeExpression<out RangeExpr expr>
    = expression<out Expr e1> ".." expression<out Expr e2> (. expr = new RangeExpr(e1, e2);.)
    .

    identifier<out Identifier identifier> = identifierToken (. identifier = new Identifier(t.val, locationFromToken(t)); .)
    .


END vadl.
