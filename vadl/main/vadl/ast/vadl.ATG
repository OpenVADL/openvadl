$package=vadl.ast
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.annotation.Nullable;

import vadl.ast.Ast;
import vadl.ast.Expr;
import vadl.ast.Definition;
import static vadl.ast.CounterDefinition.CounterKind.GROUP;
import static vadl.ast.CounterDefinition.CounterKind.PROGRAM;
import vadl.utils.SourceLocation;

import vadl.types.BitsType;
import vadl.types.BoolType;
import vadl.types.Type;
import vadl.types.SIntType;
import vadl.types.UIntType;


COMPILER vadl
    boolean insideMacro = false;
    Ast ast = new Ast();
    NestedSymbolTable symbolTable = new NestedSymbolTable();
    Ungrouper ungrouper = new Ungrouper();

    /**
    * Converts a coco token to a vadl location.
    */
    SourceLocation locationFromToken(Token token) {
        return new SourceLocation(
            SourceLocation.INVALID_SOURCE_LOCATION.uri(),
            new SourceLocation.Position(token.line, token.col),
            new SourceLocation.Position(token.line, token.col + t.val.length()));
    }

    /**
    *   Reorders wrongly parsed binary expressions
    */
    Expr reorderBinary(Expr expr) {
        // Only if not inside model parsing.
        // Cause there we don't know yet what the order is.
        if (insideMacro || !(expr instanceof BinaryExpr)) {
            return expr;
        }

        // FIXME: This doesn't completely work for model instantiation
        return BinaryExpr.reorder((BinaryExpr) expr);
    }

    /**
    * Removes all group expressions.
    */
    Expr ungroup(Expr expr) {
        //  Only if not inside model parsing.
        if (insideMacro) {
          return expr;
        }

        return ungrouper.ungroup(expr);
    }

    /**
    * Expands a macro.
    */
    @Nullable Node expandMacro(Identifier identifier, List<Node> args, SyntaxType requiredReturnType) {
        var unexpanded = new PlaceHolderExpr(identifier, args, identifier.location());
        if (insideMacro) {
            return unexpanded;
        }

        var macro = symbolTable.getMacro(identifier.name);
        if (macro == null) {
           errors.SemErr(t.line, t.col, "No macro named `%s` exists.".formatted(identifier.name));
           return unexpanded;
        }

        // The macro itself was invalid but an error for it was already issued so we silently abort the expansion here.
        if (macro.returnType() == CoreType.Invalid()) {
           return unexpanded;
        }

        boolean hasError = false;

        // Verify the arguments
        if (macro.params().size() != args.size()) {
           errors.SemErr(t.line, t.col, "The macro `%s` expects %d arguments but %d were provided.".formatted(identifier.name, macro.params().size(), args.size()));
           hasError = true;
        }

        var argMap = new HashMap<String, Node>();
        if (!hasError)
        {
            for (int i = 0; i < args.size(); i ++) {
                var arg = args.get(i);
                var param = macro.params().get(i);
                var argType = arg.syntaxType();

                if (!argType.isSubTypeOf(param.type())) {
                    errors.SemErr(t.line, t.col, "The macro's `%s` parameter `%s` expects a `%s` but the argument provided is of type `%s`.".formatted(identifier.name, param.name().name, param.type(), argType));
                    hasError = true;
                }
                argMap.put(param.name().name, arg);
            }
        }

        // Verify the return type
        if (!macro.returnType().isSubTypeOf(requiredReturnType)) {
           errors.SemErr(t.line, t.col, "The macro `%s` returns `%s` but here a macro returning `%s` is expected.".formatted(identifier.name, macro.returnType(), requiredReturnType));
           hasError = true;
        }

        if (hasError) {
           return unexpanded;
        }

         // FIXME: There should be a real instantiator here
         var body = macro.body();
         if (body instanceof Expr expr) {
            var expander = new MacroExpander(argMap, symbolTable);
            body = expander.expandExpr(expr);
            body = new GroupExpr((Expr) body);
         } else if (body instanceof Definition def) {
            var expander = new MacroExpander(argMap, symbolTable);
            body = expander.expandDefinition(def);
         } else {
            throw new RuntimeException("Expanding non expressions are not yet implemented");
         }
         return body;
    }


    /**
    * A simple lookahead helper that returns true if the token at the nth position matches the provided string.
    *
    * @param lookAheadPos the position to lookahead 0 is the next token.
    * @param value to match
    */
    boolean matchN(int lookAheadPos, String value) {
        for(int i = 0; i <= lookAheadPos -2; i++) {
            var t = scanner.Peek();
            System.out.println("token %s".formatted(t.val));
        }
        return scanner.Peek().val.equals(value);
    }

    void pushScope() {
        symbolTable = symbolTable.createChild();
    }

    void pushFormatScope(Node formatId) {
        if (formatId instanceof Identifier id) {
            symbolTable = symbolTable.createFormatScope(id);
        } else {
            pushScope();
        }
    }

    void pushInstructionScope(Node instrId) {
        if (instrId instanceof Identifier id) {
            symbolTable = symbolTable.createInstructionScope(id);
        } else {
            pushScope();
        }
    }

    void popScope() {
        symbolTable = symbolTable.parent;
    }

    SourceLocation loc() {
        return locationFromToken(t);
    }

CHARACTERS
    digit = '0' .. '9'.
    binDigit = '0' .. '1'.
    hexDigit = '0' .. '9' + 'A' .. 'F' + 'a' .. 'f'.
    letter = 'a' .. 'z' + 'A' .. 'Z'.
    validDQStringCharacters = ANY - '"' - "\\".
    validSQStringCharacters = ANY - "'" - "\\".

TOKENS
    number = digit {digit | "'"}
           | "0x" hexDigit {hexDigit | "'"}
           | "0b" binDigit {binDigit | "'"}
           .
    identifierToken = letter {letter | digit | "_"}.
    string =
    ( '"' { ("\\" letter | '"' | "'" | "\\") | validDQStringCharacters } '"') |
    ( "'" { ("\\" letter | '"' | "'" | "\\") | validSQStringCharacters } "'").

    T_STATS = "Stats".
    T_STAT = "Stat".
    T_ENCS = "Encs".
    T_ISA_DEFS = "IsaDefs".
    T_EX = "Ex".
    T_LIT = "Lit".
    T_STR = "Str".
    T_VAL = "Val".
    T_BOOL = "Bool".
    T_INT = "Int".
    T_BIN = "Bin".
    T_CALL_EX = "CallEx".
    T_SYM_EX = "SymEx".
    T_ID = "Id".
    T_BIN_OP = "BinOp".
    T_UN_OP = "UnOp".

    INSTRUCTION = "instruction".
    SET = "set".
    ARCHITECTURE = "architecture".
    CONSTANT = "constant".
    FORMAT = "format".
    PROGRAM = "program".
    GROUP = "group".
    COUNTER = "counter".
    ENCODING = "encoding".
    ASSEMBLY = "assembly".
    MNEMONIC = "mnemonic".
    MEMORY = "memory".
    REGISTER = "register".
    MODEL = "model".
    FILE = "file".
    LET = "let".
    IN = "in".
    KW_IF = "if".
    THEN = "then".
    ELSE = "else".

    SYM_EQ = "=".
    SYM_GT = ">".
    SYM_LT = "<".
    SYM_NEQ = "!=".
    SYM_GTE = ">=".
    SYM_LTE = "<=".
    SYM_MUL = "*".
    SYM_DIV = "/".
    SYM_MOD = "%".
    SYM_DOT = ".".
    SYM_SHR = ">>".
    SYM_SHL = "<<".
    SYM_ROTR = "<>>".
    SYM_ROTL = "<<>".
    SYM_EXCL = "!".
    SYM_PLUS = "+".
    SYM_MINUS = "-".
    SYM_TILDE = "~".
    SYM_COLON = ":".
    SYM_COMMA = ",".
    SYM_CARET = "^".
    SYM_BINOR = "|".
    SYM_LOGOR = "||".
    SYM_ARROW = "->".
    SYM_RANGE = "..".
    SYM_BINAND = "&".
    SYM_LOGAND = "&&".
    SYM_ASSIGN = ":=".
    SYM_DOLLAR = "$".
    SYM_SEMICOLON = ";".
    SYM_PAREN_OPEN = "(".
    SYM_BRACK_OPEN = "[".
    SYM_BRACE_OPEN = "{".
    SYM_PAREN_CLOSE = ")".
    SYM_BRACK_CLOSE = "]".
    SYM_BRACE_CLOSE = "}".

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
    vadl =
    {
        topLevelDefinitions<out Definition d>   (. ast.definitions.add(d); .)
        | macroDef
    }.

    // -- DEFINITIONS --------------------------------------------------------------------------------------------------
    topLevelDefinitions<out Definition definition>                      (. definition = null; .)
    = instructionsetDefinition<out InstructionSetDefinition isaDef>        (. definition  = isaDef; .)
    | commonDefinitionSection<out Definition def>                       (. definition  = def; .)
    .

    commonDefinitionSection<out Definition definition>              (. definition = null; .)
    = constantDefinition<out Definition def>                        (. definition = def; def.accept(symbolTable); .)
    | formatDefinition<out Definition def>                          (. definition = def; def.accept(symbolTable); .)
    .

    instructionsetDefinition<out InstructionSetDefinition isaDef>   (. var children = new ArrayList<Definition>(); pushScope(); .)
    = INSTRUCTION                                                   (. var startLocation = loc(); .)
      SET ARCHITECTURE identifier<out Identifier identifier>
      SYM_EQ SYM_BRACE_OPEN
      {(
        isaDefinition<out Definition def>                           (. children.add(def); def.accept(symbolTable); .)
        | macroDef
        | macroInstance<out Node b, CoreType.IsaDefs()>             (. children.add((Definition) b); .)
      )}
      SYM_BRACE_CLOSE                                               (. isaDef = new InstructionSetDefinition(identifier, children, startLocation.join(loc()));
                                                                       popScope();
                                                                       isaDef.accept(symbolTable);
                                                                    .)
      .

    isaDefinition<out Definition def>          (. def = null; .)
    = constantDefinition<out Definition d>     (. def = d; .)
    | formatDefinition<out Definition d>       (. def = d; .)
    | counterDefinition<out Definition d>      (. def = d; .)
    | instructionDefinition<out Definition d>  (. def = d; .)
    | encodingDefinition<out Definition d>     (. def = d; .)
    | assemblyDefinition<out Definition d>     (. def = d; .)
    | memoryDefinition<out Definition d>       (. def = d; .)
    | IF (la.kind == _REGISTER && scanner.Peek().kind == _FILE)
      registerFileDefinition<out Definition d> (. def = d; .)
    | registerDefinition<out Definition d>     (. def = d; .)
    .

    constantDefinition<out ConstantDefinition def>      (. TypeLiteral type = null; .)
    = CONSTANT                                          (. var startLocation = loc(); .)
        identifier<out Identifier id>
        [ SYM_COLON typeLiteral<out TypeLiteral t1>     (. type = t1; .) ]
        SYM_EQ expression<out Expr expr>                (. def = new ConstantDefinition(id, type, expr, startLocation.join(loc())); .)
    .

    formatDefinition<out FormatDefinition def>                      (. List<FormatDefinition.FormatField> fields = new ArrayList<>();.)
    = FORMAT                                                        (. var startLoc = loc(); .)
    identifier<out Identifier id>
    SYM_COLON typeLiteral<out TypeLiteral type>
    [SYM_EQ SYM_BRACE_OPEN
        formatField<out FormatDefinition.FormatField f1>            (. fields.add(f1); .)
        {
        SYM_COMMA formatField<out FormatDefinition.FormatField f2>  (. fields.add(f2); .)
        }
    SYM_BRACE_CLOSE]                                                (. def = new FormatDefinition(id, type, fields, startLoc.join(loc())); .)
    .

    // FIXME: more versions are missing here
    formatField<out FormatDefinition.FormatField field>                    (. field = null; .)
    = identifier<out Identifier id>
      ( formatFieldRange<out FormatDefinition.FormatField rangeField, id>  (. field = rangeField; .)
        | formatFieldType<out FormatDefinition.FormatField typedField, id> (. field = typedField; .)
      )
    .

    formatFieldRange<out FormatDefinition.FormatField field, Identifier id>
    = SYM_BRACK_OPEN                      (. List<RangeExpr> ranges = new ArrayList<>();.)
      rangeExpression<out RangeExpr e1>   (. ranges.add(e1); .)
      {
        SYM_COMMA
        rangeExpression<out RangeExpr e2> (. ranges.add(e2); .)
      }
      SYM_BRACK_CLOSE                     (. field = new FormatDefinition.RangeFormatField(id, ranges); .)
    .

    formatFieldType<out FormatDefinition.FormatField field, Identifier id>
    = SYM_COLON
      typeLiteral<out TypeLiteral type>   (. field = new FormatDefinition.TypedFormatField(id, type, symbolTable); .)
    .

    counterDefinition<out CounterDefinition def>    (. CounterDefinition.CounterKind kind = null; .)
    = ( PROGRAM                                     (. kind = PROGRAM; .)
      | GROUP                                       (. kind = GROUP; .)
    )                                               (. var startLocation = loc(); .)
    COUNTER
        identifier<out Identifier id>
        SYM_COLON typeLiteral<out TypeLiteral t1>   (. def = new CounterDefinition(kind, id, t1, startLocation.join(loc())); .)
    .

    instructionDefinition<out InstructionDefinition def> (. var startLocation = loc(); .)
    = INSTRUCTION instructionIdentifier<out Node id>
      SYM_COLON instructionIdentifier<out Node formatId> (. pushFormatScope(formatId); .)
      SYM_EQ blockStatement<out BlockStatement behavior> (. def = new InstructionDefinition(id, formatId, behavior, startLocation.join(loc()));
                                                            popScope(); .)
    .

    instructionIdentifier<out Node n>         (. n = null; .)
    = identifier<out Identifier id>           (. n = id; .)
    | placeHolder<out Node ph, CoreType.Id()> (. n = ph; .)
    .

    encodingDefinition<out EncodingDefinition def>               (. var startLocation = loc(); var entries = new ArrayList<EncodingDefinition.Entry>(); .)
    = ENCODING identifier<out Identifier instrId>
      SYM_EQ SYM_BRACE_OPEN
      encodingEntry<out EncodingDefinition.Entry e1>             (. entries.add(e1); .)
      { SYM_COMMA encodingEntry<out EncodingDefinition.Entry e2> (. entries.add(e2); .) }
      SYM_BRACE_CLOSE                                            (. def = new EncodingDefinition(instrId, entries, startLocation.join(loc())); .)
    .

    encodingEntry<out EncodingDefinition.Entry e>
    = identifier<out Identifier id>
      SYM_EQ number                                        (. e = new EncodingDefinition.Entry(id, new IntegerLiteral(t.val, loc())); .)
    .

    assemblyDefinition<out AssemblyDefinition def>         (. List<Identifier> ids = new ArrayList<>(); var start = loc(); .)
    = ASSEMBLY identifier<out Identifier id>               (. ids.add(id); pushInstructionScope(id); .)
      { SYM_COMMA identifier <out Identifier additionalId> (. ids.add(additionalId); pushInstructionScope(id); .) }
      SYM_EQ SYM_PAREN_OPEN                                (. var isMnemonic = false; List<Node> segments = new ArrayList<>(); .)
      (  MNEMONIC                                          (. isMnemonic = true; .)
        | stringLit<out StringLiteral lit1>                (. segments.add(lit1); .)
      ) { SYM_COMMA (
        stringLit<out StringLiteral lit2>                  (. segments.add(lit2); .)
        | term<out Expr expr>                              (. segments.add(expr); .)
      )} SYM_PAREN_CLOSE                                   (. def = new AssemblyDefinition(ids, isMnemonic, segments, start.join(loc()));
                                                              popScope(); .)
    .

    stringLit<out StringLiteral lit>
    = string                                               (. lit = new StringLiteral(t.val, loc()); .)
    .

    memoryDefinition<out MemoryDefinition def>
    = MEMORY                                    (. var startLocation = loc(); .)
      identifier<out Identifier id>
      SYM_COLON typeLiteral<out TypeLiteral t1>
      SYM_ARROW typeLiteral<out TypeLiteral t2> (. def = new MemoryDefinition(id, t1, t2, startLocation.join(t2.location())); .)
    .

    registerDefinition<out RegisterDefinition def>
    = REGISTER                                          (. var startLocation = loc(); .)
      identifier<out Identifier id>
      SYM_COLON typeLiteral<out TypeLiteral t1>         (. def = new RegisterDefinition(id, t1, startLocation.join(t1.location())); .)
    .

    registerFileDefinition<out Definition def>
    = REGISTER                                          (. var startLocation = loc(); .)
      FILE
      identifier<out Identifier id>
      SYM_COLON typeLiteral<out TypeLiteral t1>
      SYM_ARROW typeLiteral<out TypeLiteral t2>         (. def = new RegisterFileDefinition(id, t1, t2, startLocation.join(t2.location())); .)
    .


    // -- STATEMENTS ---------------------------------------------------------------------------------------------------

    statement<out Statement statement>         (. statement = null; .)
    = letStatement<out Statement letStatement> (. statement = letStatement; .)
    | ifStatement<out Statement ifStatement>   (. statement = ifStatement; .)
    | assignment<out Statement assignment>     (. statement = assignment; .)
    | blockStatement<out Statement block>      (. statement = block; .)
    .

    blockStatement<out BlockStatement block>   (. block = new BlockStatement(); pushScope(); .)
    = SYM_BRACE_OPEN {
        statement<out Statement statement>     (. block.add(statement); .)
     } SYM_BRACE_CLOSE                         (. popScope(); .)
    .

    assignment<out Statement statement>        (. Expr target = null; .)
    = (
        IF (scanner.Peek().kind != _SYM_PAREN_OPEN)
        variableAccess<out VariableAccess var> (. target = var; .)
      | callExpression<out CallExpr call>      (. target = call; .)
      )
      SYM_ASSIGN
      expression<out Expr expr>                (. statement = new AssignmentStatement(target, expr); .)
    .

    letStatement<out Statement letStatement>
    = LET identifier<out Identifier id>   (. pushScope(); symbolTable.defineConstant(id.name, loc()); .)
      SYM_EQ expression<out Expr valueExpr>
      IN statement<out Statement body>    (. letStatement = new LetStatement(id, valueExpr, body); popScope(); .)
    .

    ifStatement<out Statement ifStatement>
    = KW_IF expression<out Expr condition>
      THEN statement<out Statement thenStmt>                         (. ifStatement = new IfStatement(condition, thenStmt, null);     .)
      [ IF (la.kind == _ELSE) ELSE statement<out Statement elseStmt> (. ifStatement = new IfStatement(condition, thenStmt, elseStmt); .) ]
    .

    // -- EXPRESSIONS --------------------------------------------------------------------------------------------------

    expression<out Expr expr>               (. expr = null; .)
    = term<out Expr expr1>                  (. expr = expr1; .)
      {
          binaryOperator <out Operator op>
          term<out Expr expr2>              (. expr = new BinaryExpr(expr, op, expr2); .)
      }                                     (. expr = ungroup(reorderBinary(expr)); .)
    .

    binaryOperator <out Operator op>    (.op = null;.)
    = SYM_LOGOR  (. op = Operator.LogicalOr(); .)
    | SYM_LOGAND (. op = Operator.LogicalAnd(); .)
    | SYM_BINOR  (. op = Operator.Or(); .)
    | SYM_CARET  (. op = Operator.Xor(); .)
    | SYM_BINAND (. op = Operator.And(); .)
    | SYM_EQ     (. op = Operator.Equal(); .)
    | SYM_NEQ    (. op = Operator.NotEqual(); .)
    | SYM_GTE    (. op = Operator.GreaterEqual(); .)
    | SYM_GT     (. op = Operator.Greater(); .)
    | SYM_LTE    (. op = Operator.LessEqual(); .)
    | SYM_LT     (. op = Operator.Less(); .)
    | SYM_ROTR   (. op = Operator.RotateRight(); .)
    | SYM_ROTL   (. op = Operator.RotateLeft(); .)
    | SYM_SHR    (. op = Operator.ShiftRight(); .)
    | SYM_SHL    (. op = Operator.ShiftLeft(); .)
    | SYM_PLUS   (. op = Operator.Add(); .)
    | SYM_MINUS  (. op = Operator.Subtract(); .)
    | SYM_MUL    (. op = Operator.Multiply(); .)
    | SYM_DIV    (. op = Operator.Divide(); .)
    | SYM_MOD    (. op = Operator.Modulo(); .)
    .

    unary<out Expr expr>
    = unaryOperator<out UnaryOperator op> term<out Expr operand> (. expr = new UnaryExpr(op, operand); .)
    .

    unaryOperator<out UnaryOperator op> (. op = null; .)
    = SYM_MINUS (. op = UnaryOperator.NEGATIVE; .)
    | SYM_EXCL  (. op = UnaryOperator.LOG_NOT; .)
    | SYM_TILDE (. op = UnaryOperator.COMPLEMENT; .)
    .

    term<out Expr expr>                                         (. expr = null; .)
    = number                                                    (. expr = new IntegerLiteral(t.val, loc()); .)
    | IF (la.kind == _identifierToken && scanner.Peek().kind != _SYM_PAREN_OPEN)
      variableAccess<out VariableAccess var>                    (. expr = var; if (!insideMacro) symbolTable.requireValue(var); .)
    | callExpression<out CallExpr call>                         (. expr = call; .)
    | SYM_PAREN_OPEN expression<out Expr expr1> SYM_PAREN_CLOSE (. expr = new GroupExpr(expr1); .)
    | unary<out Expr unary>                                     (. expr = unary; .)
    | macroInstanceOrPlaceholder<out Node node1, CoreType.Ex()> (. expr = (Expr)node1; .)
    .

    variableAccess<out VariableAccess var>
    = identifier<out Identifier id>                     (. var = new VariableAccess(id, null); .)
      [ SYM_DOT variableAccess<out VariableAccess next> (. var = new VariableAccess(id, next); .)]
    .

    callExpression<out CallExpr call>
    = identifier<out Identifier id>
      SYM_PAREN_OPEN
      expression<out Expr argument>        (. call = new CallExpr(id, argument); .)
      SYM_PAREN_CLOSE
    .

    rangeExpression<out RangeExpr expr>
    = expression<out Expr e1> SYM_RANGE expression<out Expr e2> (. expr = new RangeExpr(e1, e2);.)
    .

    // -- PRIMETIVES ---------------------------------------------------------------------------------------------------

    typeLiteral<out TypeLiteral type>       (. type = null; Expr sizeExpr = null; .)
    =
    T_BOOL                                  (. var loc = loc(); type = new TypeLiteral(new Identifier(t.val, loc), null, loc); .)
    |
     (
        identifier<out Identifier id>
        [ SYM_LT
            // FIXME: There is a LL(1) conflict if switching ot expression
            term<out Expr expr>             (. sizeExpr = expr; .)
        SYM_GT ]                            (. type = new TypeLiteral(id, sizeExpr, id.location().join(loc())) ;.)
    )
    .

    identifier<out Identifier identifier> = identifierToken (. identifier = new Identifier(t.val, loc()); .)
    .

    // -- MACROS -------------------------------------------------------------------------------------------------------
    macroInstanceOrPlaceholder<out Node body, SyntaxType requiredType>      (. body = null; .)
    = IF (!insideMacro) macroInstance<out Node b, requiredType>             (. body = b; .)
    | placeHolder<out Node b, requiredType>                                 (. body = b;.)
    .

    placeHolder<out Node body, SyntaxType requiredType>
    = SYM_DOLLAR                                            (. var startloc = loc(); var args = new ArrayList<Node>(); .)
    identifier<out Identifier id>
    [
        SYM_PAREN_OPEN
            [
                expression<out Expr arg1>                   (. args.add(arg1); .)
                {
                    SYM_SEMICOLON expression<out Expr arg2> (.args.add(arg2); .)
                }
            ]
        SYM_PAREN_CLOSE
    ]                                                       (. body = new PlaceHolderExpr(id, args, startloc.join(loc())); .)
    .


    macroInstance<out Node body, SyntaxType requiredType>       (. var args = new ArrayList<Node>(); .)
    = SYM_DOLLAR identifier<out Identifier id>
    SYM_PAREN_OPEN
        [
            macroInstanceParam<out Node arg1>                   (. args.add(arg1); .)
            {
                SYM_SEMICOLON macroInstanceParam<out Node arg2> (. args.add(arg2); .)
            }
        ]
    SYM_PAREN_CLOSE                                             (. body = expandMacro(id, args, requiredType); .)
    .

    macroInstanceParam<out Node arg>                                 (. arg = null; .)
    = IF (la.kind == _identifierToken) identifier<out Identifier id> (. arg = id; .)
    | expression<out Expr expr>                                      (. arg = expr; .)
    .

    macroDef
    = MODEL                                         (. var startLoc = loc(); .)
    identifier<out Identifier id>
    SYM_PAREN_OPEN                                  (. var params = new ArrayList<MacroParam>(); .)
        [
            identifier<out Identifier paramId1>
            SYM_COLON
            syntaxType<out SyntaxType synType1>     (. params.add(new MacroParam(paramId1, synType1)); .)
            {
                SYM_COMMA
                identifier<out Identifier paramId2>
                SYM_COLON
                syntaxType<out SyntaxType synType2> (. params.add(new MacroParam(paramId2, synType2)); .)
            }
        ]
     SYM_PAREN_CLOSE
    SYM_COLON syntaxType<out SyntaxType returnType> SYM_EQ
    SYM_BRACE_OPEN                        (. Node body = null; insideMacro = true; .)
        ( expression<out Expr bodyEx>     (. body = bodyEx; .)
        | isaDefinition<out Definition d> (. body = d; .)
        )
    SYM_BRACE_CLOSE                       (.
                                            insideMacro = false;
                                            var bodyType = body.syntaxType();
                                            if (!bodyType.isSubTypeOf(returnType)) {
                                                errors.SemErr(t.line, t.col, "The macro signature promises to return `%s` but it's body is of type `%s`.".formatted(returnType, bodyType));
                                                symbolTable.addMacro(new Macro(id, params, body, CoreType.Invalid()), startLoc.join(loc()));
                                            } else {
                                                symbolTable.addMacro(new Macro(id, params, body, returnType), startLoc.join(loc()));
                                            }
                                           .)
    .

    syntaxType<out SyntaxType typ> = syntaxCoreType<out CoreType coreType> (. typ = coreType; .)
    .

    syntaxCoreType<out CoreType typ>  (. typ = null; .)
    = T_STATS        (. typ = CoreType.Stats(); .)
    | T_STAT         (. typ = CoreType.Stat(); .)
    | T_ENCS         (. typ = CoreType.Encs(); .)
    | T_ISA_DEFS     (. typ = CoreType.IsaDefs(); .)
    | T_EX           (. typ = CoreType.Ex(); .)
    | T_LIT          (. typ = CoreType.Lit(); .)
    | T_STR          (. typ = CoreType.Str(); .)
    | T_VAL          (. typ = CoreType.Val(); .)
    | T_BOOL         (. typ = CoreType.Bool(); .)
    | T_INT          (. typ = CoreType.Int(); .)
    | T_BIN          (. typ = CoreType.Bin(); .)
    | T_CALL_EX      (. typ = CoreType.CallEx(); .)
    | T_SYM_EX       (. typ = CoreType.SymEx(); .)
    | T_ID           (. typ = CoreType.Id(); .)
    | T_BIN_OP       (. typ = CoreType.BinOp(); .)
    | T_UN_OP        (. typ = CoreType.UnOp(); .)
    .



END vadl.
