$package=vadl.ast
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;

import vadl.utils.SourceLocation;

import static vadl.ast.CounterDefinition.CounterKind.GROUP;
import static vadl.ast.CounterDefinition.CounterKind.PROGRAM;
import static vadl.ast.ParserUtils.*;

COMPILER vadl
  java.net.URI sourceFile = SourceLocation.INVALID_SOURCE_LOCATION.uri();
  @Nullable java.net.URI resolutionUri;
  Deque<List<MacroParam>> macroContext = new ArrayDeque<>();
  Ast ast = new Ast();
  SymbolTable macroTable = new SymbolTable();
  Map<String, Identifier> macroOverrides = new HashMap<>();

  {
    ast.rootSymbolTable = new SymbolTable();
    ast.rootSymbolTable.loadBuiltins();
  }

  SourceLocation loc() {
    return locationFromToken(this, t);
  }

  SourceLocation lookaheadLoc() {
    return locationFromToken(this, la);
  }

CHARACTERS
  digit = '0' .. '9'.
  binDigit = '0' .. '1'.
  hexDigit = '0' .. '9' + 'A' .. 'F' + 'a' .. 'f'.
  letter = 'a' .. 'z' + 'A' .. 'Z'.
  validDQStringCharacters = ANY - '"' - "\\".
  validSQStringCharacters = ANY - "'" - "\\".
  validSourceCharacters = ANY.

TOKENS
  hexLit = "0x" hexDigit {hexDigit | "'"}.
  binLit = "0b" binDigit {binDigit | "'"}.
  decLit = digit {digit | "'"}.
  embeddedSource = "-<{" {validSourceCharacters} "}>-".

  identifierToken = letter {letter | digit | "_"}.
  string =
  ( '"' { "\\" (letter | '"' | "'" | "\\") | validDQStringCharacters } '"') |
  ( "'" { "\\" (letter | '"' | "'" | "\\") | validSQStringCharacters } "'").

  T_BIN         = "Bin".
  T_BIN_OP      = "BinOp".
  T_BOOL        = "Bool".
  T_CALL_EX     = "CallEx".
  T_COMMON_DEFS = "CommonDefs".
  T_ENCS        = "Encs".
  T_EX          = "Ex".
  T_ID          = "Id".
  T_INT         = "Int".
  T_ISA_DEFS    = "IsaDefs".
  T_LIT         = "Lit".
  T_STAT        = "Stat".
  T_STATS       = "Stats".
  T_STR         = "Str".
  T_SYM_EX      = "SymEx".
  T_UN_OP       = "UnOp".
  T_VAL         = "Val".

  ADDRESS      = "address".
  ALIAS        = "alias".
  APPEND       = "append".
  APPLICATION  = "application".
  ARCHITECTURE = "architecture".
  ARGUMENT     = "argument".
  ASSEMBLY     = "assembly".
  BINARY       = "binary".
  CACHE        = "cache".
  CALL         = "call".
  CALLEE       = "callee".
  CALLER       = "caller".
  COMPILER_KW  = "compiler".
  CONSTANT     = "constant".
  COUNTER      = "counter".
  DECODER      = "decoder".
  DO           = "do".
  ELSE         = "else".
  ENCODE       = "encode".
  ENCODING     = "encoding".
  ENUMERATION  = "enumeration".
  EXCEPTION    = "exception".
  EXISTS       = "exists".
  EXTEND_ID    = "ExtendId".
  EXTENDING    = "extending".
  FALSE        = "false".
  FETCH        = "fetch".
  FILE         = "file".
  FIRMWARE     = "firmware".
  FOLD         = "fold".
  FOR          = "for".
  FORALL       = "forall".
  FORMAT       = "format".
  FRAME        = "frame".
  FUNCTION     = "function".
  GLOBAL       = "global".
  GROUP        = "group".
  HIT          = "hit".
  ID_TO_STR    = "IdToStr".
  IF_KW        = "if".
  IMPLEMENTS   = "implements".
  IMPORT       = "import".
  INSTRUCTION  = "instruction".
  INTERFACE    = "interface".
  LET          = "let".
  LOCK         = "lock".
  LOGIC        = "logic".
  MATCH        = "match".
  MEMORY       = "memory".
  MICRO        = "micro".
  MISS         = "miss".
  MODEL        = "model".
  MODEL_TYPE   = "model-type".
  NONE         = "none".
  NOP          = "nop".
  OPERATION    = "operation".
  PATCH        = "patch".
  PIPELINE     = "pipeline".
  POINTER      = "pointer".
  PREDICATE    = "predicate".
  PREDICTION   = "prediction".
  PROCESS      = "process".
  PROCESSOR    = "processor".
  PROGRAM      = "program".
  PSEUDO       = "pseudo".
  RAISE        = "raise".
  READ         = "read".
  RECORD       = "record".
  REGISTER     = "register".
  RELOCATION   = "relocation".
  RETURN       = "return".
  SAVED        = "saved".
  SEQUENCE     = "sequence".
  SET          = "set".
  SIGNAL       = "signal".
  SOURCE       = "source".
  STACK        = "stack".
  STAGE        = "stage".
  START        = "start".
  STARTUP      = "startup".
  STOP         = "stop".
  TENSOR       = "tensor".
  THEN         = "then".
  TRANSLATION  = "translation".
  TRUE         = "true".
  USING        = "using".
  VALUE        = "value".
  WITH         = "with".
  WRITE        = "write".

  SYM_ARROW       = "->".
  SYM_AS          = "as".
  SYM_ASSIGN      = ":=".
  SYM_AT          = "@".
  SYM_BIGARROW    = "=>".
  SYM_BINAND      = "&".
  SYM_BINOR       = "|".
  SYM_BRACE_CLOSE = "}".
  SYM_BRACE_OPEN  = "{".
  SYM_BRACK_CLOSE = "]".
  SYM_BRACK_OPEN  = "[".
  SYM_CARET       = "^".
  SYM_COLON       = ":".
  SYM_COMMA       = ",".
  SYM_DIV         = "/".
  SYM_DOLLAR      = "$".
  SYM_DOT         = ".".
  SYM_ELEM_OF     = "∈".
  SYM_EQ          = "=".
  SYM_EXCL        = "!".
  SYM_GT          = ">".
  SYM_GTE         = ">=".
  SYM_IN          = "in".
  SYM_LOGAND      = "&&".
  SYM_LOGOR       = "||".
  SYM_LONG_MUL    = "*#".
  SYM_LT          = "<".
  SYM_LTE         = "<=".
  SYM_MINUS       = "-".
  SYM_MOD         = "%".
  SYM_MUL         = "*".
  SYM_NAMESPACE   = "::".
  SYM_NEQ         = "!=".
  SYM_NIN         = "!in".
  SYM_NOT_ELEM_OF = "∉".
  SYM_PAREN_CLOSE = ")".
  SYM_PAREN_OPEN  = "(".
  SYM_PLUS        = "+".
  SYM_RANGE       = "..".
  SYM_ROTL        = "<<>".
  SYM_ROTR        = "<>>".
  SYM_SAT_ADD     = "+|".
  SYM_SAT_SUB     = "-|".
  SYM_SEMICOLON   = ";".
  SYM_SHL         = "<<".
  SYM_SHR         = ">>".
  SYM_TILDE       = "~".
  SYM_UNDERSCORE  = "_".

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
  vadl =
  {
    topLevelDefinitions<out Definition def> (. addDef(ast.definitions, def); SymbolTable.SymbolCollector.collectSymbols(ast.rootSymbolTable(), def); .)
    | macroDef<out ModelDefinition def>     (. addDef(ast.definitions, def); SymbolTable.SymbolCollector.collectSymbols(ast.rootSymbolTable(), def); macroTable.addModelDefinition(def); .)
  }.

  // -- DEFINITIONS --------------------------------------------------------------------------------------------------
  topLevelDefinitions<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<out Annotations annotations>
  ( instructionsetDefinition<out def>
  | applicationBinaryInterfaceDefinition<out def>
  | IF (la.kind == _MICRO && scanner.Peek().kind == _PROCESSOR)
    microProcessorDefinition<out def>
  | microArchitectureDefinition<out def>
  | commonDefinition<out def>
  | importDefinition<out def>
  )                                       (. def.withAnnotations(annotations); .)
  .

  commonDefinitionList<.out List<Definition> definitions.> (. definitions = new ArrayList<>(); .)
  = {
    annotations<out Annotations annotations>
    commonDefinition<out Definition def>                   (. def.withAnnotations(annotations); definitions.add(def); .)
  | macroDef<out ModelDefinition def>                      (. addDef(definitions, def); macroTable.addModelDefinition(def); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>                           (. var def = castCommonDef(this, n);
                                                              if (def instanceof DefinitionList list) {
                                                                readMacroSymbols(macroTable, list.items);
                                                              }
                                                              addDef(definitions, def); .)
  }
  .

  commonDefinition<out Definition def>    (. def = DUMMY_DEF; .)
  = constantDefinition<out def>
  | formatDefinition<out def>
  | usingDefinition<out def>
  | functionDefinition<out def>
  | recordDefinition<out def>
  | modelTypeDefinition<out def>
  .

  instructionsetDefinition<out InstructionSetDefinition isaDef> (. macroTable = macroTable.createChild(); .)
  = INSTRUCTION SET ARCHITECTURE                                (. var startLocation = loc(); .)
    identifier<out Identifier identifier>                       (. Identifier extending = null; .)
    [
      EXTENDING
      identifier<out extending>                                 (. var extendingIsa = macroTable.requireIsa(extending);
                                                                   if (extendingIsa != null)
                                                                     readMacroSymbols(macroTable, extendingIsa.definitions);
                                                                .)
    ]
    SYM_EQ SYM_BRACE_OPEN
    isaDefinitionList<.out List<Definition> definitions.>       (. macroTable = Objects.requireNonNull(macroTable.parent); .)
    SYM_BRACE_CLOSE                                             (. isaDef = new InstructionSetDefinition(identifier, extending, definitions, startLocation.join(loc()));
                                                                   macroTable.defineSymbol(new SymbolTable.IsaSymbol(identifier.name, isaDef), identifier.location()); .)
  .

  isaDefinitionList<.out List<Definition> definitions.> (. definitions = new ArrayList<>(); .)
  = {
    annotations<out Annotations annotations>
    isaDefinition<out Definition def>                   (. def.withAnnotations(annotations); definitions.add(def); .)
  | macroDef<out ModelDefinition def>                   (. addDef(definitions, def); macroTable.addModelDefinition(def); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.ISA_DEFS))
    macroReplacement<out Node n>                        (. var def = castIsaDef(this, n);
                                                           if (def instanceof DefinitionList list) {
                                                             readMacroSymbols(macroTable, list.items);
                                                           }
                                                           addDef(definitions, def); .)
  }
  .

  annotations<out Annotations annotations> (. var list = new ArrayList<Annotation>(); .)
  = {
    annotation<out Annotation annotation>  (. list.add(annotation); .)
  }                                        (. annotations = new Annotations(list); .)
  .

  annotation<out Annotation annotation> (. TypeLiteral type = null; IdentifierOrPlaceholder property = null; .)
  = SYM_BRACK_OPEN
    expression<out Expr expr, BIN_OPS>
    [ (SYM_COLON typeLiteral<out type>)
    | identifierOrPlaceholder<out property>
    ]
    SYM_BRACK_CLOSE                     (. annotation = new Annotation(expr, type, property); .)
  .

  isaDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = commonDefinition<out def>
  | IF (la.kind == _GROUP && scanner.Peek().kind != _COUNTER)
    groupDefinition<out def>
  | counterDefinition<out def>
  | instructionDefinition<out def>
  | pseudoInstructionDefinition<out def>
  | relocationDefinition<out def>
  | encodingDefinition<out def>
  | assemblyDefinition<out def>
  | memoryDefinition<out def>
  | IF (la.kind == _REGISTER && scanner.Peek().kind == _FILE)
    registerFileDefinition<out def>
  | registerDefinition<out def>
  | aliasDefinition<out def>
  | enumerationDefinition<out def>
  | exceptionDefinition<out def>
  | processDefinition<out def>
  | operationDefinition<out def>
  .

  constantDefinition<out ConstantDefinition def> (. TypeLiteral type = null; .)
  = CONSTANT                                     (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out type> ]
    SYM_EQ
    expression<out Expr expr, BIN_OPS>           (. def = new ConstantDefinition(id, type, expr, startLocation.join(loc())); .)
  .

  formatDefinition<out FormatDefinition def>
  = FORMAT                                                       (. var startLoc = loc(); .)
  identifierOrPlaceholder<out IdentifierOrPlaceholder id>        (. var fields = new ArrayList<FormatDefinition.FormatField>();.)
  SYM_COLON typeLiteral<out TypeLiteral type>                    (. var auxFields = new ArrayList<FormatDefinition.AuxiliaryField>();.)
  [
    SYM_EQ SYM_BRACE_OPEN
    formatField<out FormatDefinition.FormatField f1>             (. fields.add(f1); .)
    {
      SYM_COMMA formatField<out FormatDefinition.FormatField f2> (. fields.add(f2); .)
    | SYM_COLON
      auxiliaryField<out FormatDefinition.AuxiliaryField aux>    (. auxFields.add(aux); .)
    }
    SYM_BRACE_CLOSE
  ]                                                              (. def = new FormatDefinition(id, type, fields, auxFields, startLoc.join(loc())); .)
  .

  formatField<out FormatDefinition.FormatField field> (. field = null; .)
  = identifier<out Identifier id>
    ( formatFieldRange<out field, id>
    | formatFieldType<out field, id>
    | formatFieldDerived<out field, id>
    )
  .

  auxiliaryField<out FormatDefinition.AuxiliaryField auxField> (. FormatDefinition.AuxiliaryFieldKind kind = null; .)
  = (
    PREDICATE                                                  (. kind = FormatDefinition.AuxiliaryFieldKind.PREDICATE; .)
  | ENCODE                                                     (. kind = FormatDefinition.AuxiliaryFieldKind.ENCODE; .)
  )
    SYM_BRACE_OPEN                                             (. var auxEntries = new ArrayList<FormatDefinition.AuxiliaryFieldEntry>(); .)
    identifier<out Identifier fieldId>
    SYM_BIGARROW
    expression<out Expr fieldExpr, BIN_OPS>                    (. auxEntries.add(new FormatDefinition.AuxiliaryFieldEntry(fieldId, fieldExpr)); .)
    {
      SYM_COMMA
      identifier<out fieldId>
      SYM_BIGARROW
      expression<out fieldExpr, BIN_OPS>                       (. auxEntries.add(new FormatDefinition.AuxiliaryFieldEntry(fieldId, fieldExpr)); .)
    }
    SYM_BRACE_CLOSE                                            (. auxField = new FormatDefinition.AuxiliaryField(kind, auxEntries); .)
  .

  formatFieldRange<out FormatDefinition.FormatField field, Identifier id>
  = SYM_BRACK_OPEN                      (. List<Expr> ranges = new ArrayList<>();.)
    rangeExpression<out Expr e1>        (. ranges.add(e1); .)
    {
      SYM_COMMA
      rangeExpression<out Expr e2>      (. ranges.add(e2); .)
    }
    SYM_BRACK_CLOSE                     (. TypeLiteral type = null; .)
    [
      IF (la.kind == _SYM_COLON && !AUX_FIELD_TOKENS[la.kind])
      SYM_COLON
      typeLiteral<out type>
    ]                                   (. field = new FormatDefinition.RangeFormatField(id, ranges, type); .)
  .

  formatFieldType<out FormatDefinition.FormatField field, Identifier id>
  = SYM_COLON
    typeLiteral<out TypeLiteral type> (. field = new FormatDefinition.TypedFormatField(id, type); .)
  .

  formatFieldDerived<out FormatDefinition.FormatField field, Identifier id>
  = SYM_EQ
    expression<out Expr expr, BIN_OPS> (. field = new FormatDefinition.DerivedFormatField(id, expr); .)
  .

  counterDefinition<out CounterDefinition def>  (. CounterDefinition.CounterKind kind = null; .)
  = ( PROGRAM                                   (. kind = PROGRAM; .)
    | GROUP                                     (. kind = GROUP; .)
    )                                           (. var startLocation = loc(); .)
    COUNTER
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral type> (. def = new CounterDefinition(kind, id, type, startLocation.join(loc())); .)
  .

  instructionDefinition<out InstructionDefinition def>                      (. var startLocation = loc(); .)
  = INSTRUCTION identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON identifierOrPlaceholder<out IdentifierOrPlaceholder formatId>
    SYM_EQ statement<out Statement behavior>                                (. def = new InstructionDefinition(id, formatId, behavior, startLocation.join(loc())); .)
  .

  pseudoInstructionDefinition<out Definition def>            (. PseudoInstructionDefinition.PseudoInstrKind kind = null; .)
  = ( PSEUDO                                                 (. kind = PseudoInstructionDefinition.PseudoInstrKind.PSEUDO; .)
    | COMPILER_KW                                            (. kind = PseudoInstructionDefinition.PseudoInstrKind.COMPILER; .)
    )                                                        (. var start = loc(); .)
    INSTRUCTION
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>  (. List<Parameter> params = new ArrayList<>(); .)
    [ parameters<out params> ]
    SYM_EQ
    SYM_BRACE_OPEN                                           (. var stmts = new ArrayList<InstructionCallStatement>(); .)
    {
      instructionCallStmt<out InstructionCallStatement stmt> (. stmts.add(stmt); .)
    }
    SYM_BRACE_CLOSE                                          (. def = new PseudoInstructionDefinition(id, kind, params, stmts, start.join(loc())); .)
  .

  relocationDefinition<out Definition def>
  = RELOCATION                         (. var start = loc(); .)
    identifier<out Identifier id>
    parameters<.out List<Parameter> params.>
    SYM_ARROW
    typeLiteral<out TypeLiteral resultType>
    SYM_EQ
    expression<out Expr expr, BIN_OPS> (. def = new RelocationDefinition(id, params, resultType, expr, start.join(loc())); .)
  .

  identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. id = DUMMY_ID; .)
  = identifier<out id>
  | macroReplacement<out Node node>                       (. id = castId(this, node); .)
  .

  encodingDefinition<out EncodingDefinition def>
  = ENCODING         (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder instrId>
    SYM_EQ SYM_BRACE_OPEN
    encodingDefinitionList<out EncodingDefinition.EncsNode encodings>
    SYM_BRACE_CLOSE  (. def = new EncodingDefinition(instrId, encodings, startLocation.join(loc())); .)
  .

  encodingDefinitionList<out EncodingDefinition.EncsNode encs> (. var start = lookaheadLoc(); var entries = new ArrayList<IsEncs>(); .)
  = encodingEntry<out IsEncs enc>                              (. addEncs(entries, enc); .)
    {
      // In a macro match, commas are used for separating multiple pattern alternatives
      // In the unlikely event that someone uses macro match with Encs literals,
      // we interpret commas as part of the Encs body, not the macro match alternatives.
      // Instead, the specification author can use multiple macro match productions with the same effect.
      IF (la.kind == _SYM_COMMA)
      SYM_COMMA
      encodingEntry<out enc>                                   (. addEncs(entries, enc); .)
    }                                                          (. encs = new EncodingDefinition.EncsNode(entries, start.join(loc())); .)
  .

  encodingEntry<out IsEncs enc>        (. enc = null; .)
  = IF (la.kind == _NONE)
    NONE
  | macroReplacement<out Node node>    (. enc = castEncs(this, node); .)
  | identifier<out Identifier id>
    SYM_EQ
    expression<out Expr expr, BIN_OPS> (. enc = new EncodingDefinition.EncodingField(id, expr); .)
  .

  assemblyDefinition<out AssemblyDefinition def>                        (. List<IdentifierOrPlaceholder> ids = new ArrayList<>(); var start = loc(); .)
  = ASSEMBLY
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>             (. ids.add(id); .)
    {
      SYM_COMMA
      identifierOrPlaceholder<out IdentifierOrPlaceholder additionalId> (. ids.add(additionalId); .)
    }
    SYM_EQ
    expression<out Expr expr, BIN_OPS>                                  (. def = new AssemblyDefinition(ids, expr, start.join(loc())); .)
  .

  stringLiteral<out StringLiteral lit>
  = string                                               (. lit = new StringLiteral(t.val, loc()); .)
  .

  memoryDefinition<out MemoryDefinition def>
  = MEMORY                                    (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2> (. def = new MemoryDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  registerDefinition<out RegisterDefinition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>         (. def = new RegisterDefinition(id, t1, startLocation.join(t1.location())); .)
  .

  registerFileDefinition<out Definition def>
  = REGISTER                                                   (. var startLocation = loc(); .)
    FILE
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON
    relationType<out RegisterFileDefinition.RelationType type> (. def = new RegisterFileDefinition(id, type, startLocation.join(loc())); .)
  .

  relationType<out RegisterFileDefinition.RelationType type> (. var argTypes = new ArrayList<TypeLiteral>(); .)
  = typeLiteral<out TypeLiteral argType>                     (. argTypes.add(argType); .)
    {
      SYM_MUL
      typeLiteral<out argType>                               (. argTypes.add(argType); .)
    }
    SYM_ARROW
    typeLiteral<out TypeLiteral resultType>                  (. type = new RegisterFileDefinition.RelationType(argTypes, resultType); .)
  .

  aliasDefinition<out Definition def>
  = ALIAS                                             (. var startLocation = loc(); AliasDefinition.AliasKind kind = null;
                                                         TypeLiteral aliasType = null; TypeLiteral targetType = null;
                                                         IdentifierOrPlaceholder id = null;
                                                      .)
    (
      REGISTER                                        (. kind = AliasDefinition.AliasKind.REGISTER; .)
      [ FILE                                          (. kind = AliasDefinition.AliasKind.REGISTER_FILE; .) ]
      identifierOrPlaceholder<out id>
      [
        SYM_COLON
        typeLiteral<out aliasType>
        [
          SYM_ARROW
          typeLiteral<out targetType>
        ]
      ]
    | PROGRAM COUNTER                                 (. kind = AliasDefinition.AliasKind.PROGRAM_COUNTER; .)
      identifierOrPlaceholder<out id>
      [
        SYM_COLON
        typeLiteral<out aliasType>
      ]
    )
    SYM_EQ
    callOrBinaryExpression<out Expr value, false>     (. def = new AliasDefinition(id, kind, aliasType, targetType, value, startLocation.join(loc())); .)
  .

  usingDefinition<out Definition def>
  = USING                             (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_EQ
    typeLiteral<out TypeLiteral type> (. def = new UsingDefinition(id, type, start.join(loc())); .)
  .

  functionDefinition<out Definition def>
  = FUNCTION                           (. var start = loc(); List<Parameter> params = new ArrayList<>(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    [ parameters<out params> ]
    SYM_ARROW
    typeLiteral<out TypeLiteral retType>
    SYM_EQ
    expression<out Expr expr, BIN_OPS> (. def = new FunctionDefinition(name, params, retType, expr, start.join(loc())); .)
  .

  parameters<.out List<Parameter> params.>
  = SYM_PAREN_OPEN                  (. params = new ArrayList<>(); .)
    parameter<out Parameter param>  (. params.add(param); .)
    {
      SYM_COMMA
      parameter<out Parameter next> (. params.add(next); .)
    }
    SYM_PAREN_CLOSE
  .

  parameter<out Parameter param>
  = identifier<out Identifier name>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. param = new Parameter(name, type); .)
  .

  enumerationDefinition<out Definition def> (. TypeLiteral enumType = null; .)
  = ENUMERATION                             (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out enumType> ]
    SYM_EQ                                  (. var entries = new ArrayList<EnumerationDefinition.Entry>(); .)
    SYM_BRACE_OPEN                          (. Expr value = null; Expr behavior = null; .)
    identifier<out Identifier name>
    [
      SYM_EQ
      valLiteral<out value>
    ]
    [
      SYM_BIGARROW
      callOrBinaryExpression<out behavior, false>
    ]                                       (. entries.add(new EnumerationDefinition.Entry(name, value, behavior)); .)
    {
      SYM_COMMA
      identifier<out name>
      [
        SYM_EQ
        valLiteral<out value>
      ]
      [
        SYM_BIGARROW
        callOrBinaryExpression<out behavior, false>
      ]                                     (. entries.add(new EnumerationDefinition.Entry(name, value, behavior)); .)
    }
    SYM_BRACE_CLOSE                         (. def = new EnumerationDefinition(id, enumType, entries, start.join(loc())); .)
  .

  exceptionDefinition<out Definition def>
  = EXCEPTION                          (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_EQ
    statement<out Statement statement> (. def = new ExceptionDefinition(id, statement, start.join(loc())); .)
  .

  recordDefinition<out RecordTypeDefinition def>
  = RECORD                          (. var start = loc(); .)
    identifier<out Identifier recordName>
    SYM_PAREN_OPEN
    identifier<out Identifier paramName>
    SYM_COLON                       (. var entries = new ArrayList<RecordType.Entry>(); .)
    syntaxType<out SyntaxType type> (. entries.add(new RecordType.Entry(paramName.name, type)); .)
    {
      SYM_COMMA
      identifier<out paramName>
      SYM_COLON
      syntaxType<out type>          (. entries.add(new RecordType.Entry(paramName.name, type)); .)
    }                               (. var recordType = new RecordType(recordName.name, entries); .)
    SYM_PAREN_CLOSE                 (. def = new RecordTypeDefinition(recordName, recordType, start.join(loc()));
                                       macroTable.addRecord(def); .)
  .

  modelTypeDefinition<out ModelTypeDefinition def>
  = MODEL_TYPE                              (. var start = loc(); .)
    identifier<out Identifier name>
    SYM_EQ
    projectionType<out ProjectionType type> (. def = new ModelTypeDefinition(name, type, start.join(loc()));
                                               macroTable.addModelType(def); .)
  .

  importDefinition<out Definition def>     (. var importPaths = new ArrayList<IsId>(); Identifier fileId = null; StringLiteral filePath = null; .)
  = IMPORT                                 (. var start = loc(); .)
    ( identifier<out fileId>
    | stringLiteral<out filePath>
    )                                      (. var segments = new ArrayList<Identifier>(); .)
    {
      IF (la.kind == _SYM_NAMESPACE && scanner.Peek().kind != _SYM_BRACE_OPEN)
      SYM_NAMESPACE
      identifier<out Identifier segment>   (. segments.add(segment); .)
    }                                      (. var symbolList = new ArrayList<List<Identifier>>(); .)
    [
      SYM_NAMESPACE
      SYM_BRACE_OPEN                       (. var list = new ArrayList<Identifier>(); .)
      identifier<out Identifier symbol>    (. list.add(symbol); .)
      {
        SYM_NAMESPACE
        identifier<out symbol>             (. list.add(symbol); .)
      }                                    (. symbolList.add(List.copyOf(list)); .)
      {
        SYM_COMMA                          (. list.clear(); .)
        identifier<out symbol>             (. list.add(symbol); .)
        {
          SYM_NAMESPACE
          identifier<out symbol>           (. list.add(symbol); .)
        }                                  (. symbolList.add(List.copyOf(list)); .)
      }
      SYM_BRACE_CLOSE
    ]                                      (. var args = new ArrayList<StringLiteral>(); .)
    [
      WITH
      SYM_PAREN_OPEN
      stringLiteral<out StringLiteral arg> (. args.add(arg); .)
      {
        SYM_COMMA
        stringLiteral<out arg>             (. args.add(arg); .)
      }
      SYM_PAREN_CLOSE
    ]                                      (. def = importModules(this, fileId, filePath, importedSymbols(segments, symbolList), args, start.join(loc())); .)
  .

  processDefinition<out Definition def>
  = PROCESS                       (. var start = loc();
                                     List<ProcessDefinition.TemplateParam> templateParams = new ArrayList<>();
                                     List<Parameter> inputs = new ArrayList<>();
                                     List<Parameter> outputs = new ArrayList<>(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    [ processTemplateParameters<.out templateParams.> ]
    [ parameters<.out inputs.> ]
    [ SYM_ARROW parameters<.out outputs.> ]
    SYM_EQ
    statement<out Statement stmt> (. def = new ProcessDefinition(name, templateParams, inputs, outputs, stmt, start.join(loc())); .)
  .

  processTemplateParameters<.out List<ProcessDefinition.TemplateParam> templateParams.>
  = SYM_LT                            (. templateParams = new ArrayList<>(); .)
    identifier<out Identifier id>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. Expr value = null; .)
    [
      SYM_EQ
      expression<out value, BIN_OPS_EXCEPT_GT>
    ]                                 (. templateParams.add(new ProcessDefinition.TemplateParam(id, type, value)); .)
    {
        identifier<out id>
        SYM_COLON
        typeLiteral<out type>         (. value = null; .)
        [
          SYM_EQ
          expression<out value, BIN_OPS_EXCEPT_GT>
        ]                             (. templateParams.add(new ProcessDefinition.TemplateParam(id, type, value)); .)
    }
    SYM_GT
  .

  operationDefinition<out Definition def>
  = OPERATION                       (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    SYM_EQ
    SYM_BRACE_OPEN                  (. var resources = new ArrayList<IsId>(); .)
    [
      identifierPath<out IsId path> (. resources.add(path); .)
      {
        SYM_COMMA
        identifierPath<out path>    (. resources.add(path); .)
      }
    ]
    SYM_BRACE_CLOSE                 (. def = new OperationDefinition(name, resources, start.join(loc())); .)
  .

  groupDefinition<out Definition def>     (. TypeLiteral type = null; .)
  = GROUP                                 (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [
      SYM_COLON
      typeLiteral<out type>
    ]
    SYM_EQ
    groupSequence<out Group.Sequence seq> (. def = new GroupDefinition(id, type, seq, start.join(loc())); .)
  .

  groupSequence<out Group.Sequence seq> (. var groups = new ArrayList<Group>(); .)
  = group<out Group group>              (. var start = loc(); groups.add(group); .)
    {
      SYM_DOT
      group<out group>                  (. groups.add(group); .)
    }                                   (. seq = new Group.Sequence(groups, start.join(loc())); .)
  .

  group<out Group group> (. group = null; .)
  = groupLiteral<out group>
  | groupAlternative<out group>
  | groupPermutation<out group>
  .

  groupLiteral<out Group group>
  = identifierPath<out IsId path>    (. var start = loc(); Expr size = null; .)
    [
      SYM_LT
      intLiteral<out size>
      [
        SYM_RANGE
        intLiteral<out Expr rangeTo> (. size = new RangeExpr(size, rangeTo); .)
      ]
      SYM_GT
    ]                                (. group = new Group.Literal(path, size, start.join(loc())); .)
  .

  groupAlternative<out Group group>
  = SYM_PAREN_OPEN                        (. var start = loc(); var sequences = new ArrayList<Group.Sequence>(); .)
    groupSequence<out Group.Sequence seq> (. sequences.add(seq); .)
    {
      SYM_BINOR
      groupSequence<out seq>              (. sequences.add(seq); .)
    }
    SYM_PAREN_CLOSE                       (. group = new Group.Alternative(sequences, start.join(loc())); .)
  .

  groupPermutation<out Group group>
  = SYM_BRACE_OPEN                        (. var start = loc(); var sequences = new ArrayList<Group.Sequence>(); .)
    groupSequence<out Group.Sequence seq> (. sequences.add(seq); .)
    {
      SYM_COMMA
      groupSequence<out seq>              (. sequences.add(seq); .)
    }
    SYM_BRACE_CLOSE                       (. group = new Group.Permutation(sequences, start.join(loc())); .)
  .

  // -- ABI DEFINITIONS-----------------------------------------------------------------------------------------------

  applicationBinaryInterfaceDefinition<out Definition def>
  = APPLICATION                                 (. var start = loc(); .)
    BINARY
    INTERFACE
    identifier<out Identifier id>
    FOR
    identifierPath<out IsId isaPath>
    SYM_EQ
    SYM_BRACE_OPEN                              (. var elements = new ArrayList<Definition>(); .)
    {
      abiElementDefinition<out Definition elem> (. addDef(elements, elem); .)
    }
    SYM_BRACE_CLOSE                             (. def = new ApplicationBinaryInterfaceDefinition(id, isaPath, elements, start.join(loc())); .)
  .

  abiElementDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<out Annotations annotations>
    ( IF (scanner.Peek().kind == _SEQUENCE) // RETURN can be followed by both SEQUENCE and VALUE / ADDRESS
      abiSequenceDef<out def>
    | specialPurposeRegisterDef<out def>
    | aliasDefinition<out def>
 // | commonDefinition<out def> TODO conflict between FUNCTION ARGUMENT and function definition
    )                                      (. def.withAnnotations(annotations); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>           (. def = castCommonDef(this, n);
                                              if (def instanceof DefinitionList list) {
                                                readMacroSymbols(macroTable, list.items);
                                              } .)
  .

  specialPurposeRegisterDef<out Definition def>              (. var start = lookaheadLoc(); .)
  =                                                          (. SpecialPurposeRegisterDefinition.Purpose purpose = null; .)
  ( RETURN
    ( ADDRESS                                                (. purpose = SpecialPurposeRegisterDefinition.Purpose.RETURN_ADDRESS; .)
    | VALUE                                                  (. purpose = SpecialPurposeRegisterDefinition.Purpose.RETURN_VALUE; .)
  )
  | STACK POINTER                                            (. purpose = SpecialPurposeRegisterDefinition.Purpose.STACK_POINTER; .)
  | GLOBAL POINTER                                           (. purpose = SpecialPurposeRegisterDefinition.Purpose.GLOBAL_POINTER; .)
  | FRAME POINTER                                            (. purpose = SpecialPurposeRegisterDefinition.Purpose.FRAME_POINTER; .)
  | FUNCTION ARGUMENT                                        (. purpose = SpecialPurposeRegisterDefinition.Purpose.FUNCTION_ARGUMENT; .)
  | CALLER SAVED                                             (. purpose = SpecialPurposeRegisterDefinition.Purpose.CALLER_SAVED; .)
  | CALLEE SAVED                                             (. purpose = SpecialPurposeRegisterDefinition.Purpose.CALLEE_SAVED; .)
  )
    SYM_EQ
    sequenceCallExprList<.out List<SequenceCallExpr> calls.> (. def = new SpecialPurposeRegisterDefinition(purpose, calls, start.join(loc())); .)
  .

  abiSequenceDef<out Definition def>                         (. var start = lookaheadLoc(); .)
  =                                                          (. AbiSequenceDefinition.SeqKind kind = null; .)
  ( ADDRESS                                                  (. kind = AbiSequenceDefinition.SeqKind.ADDRESS; .)
  | CALL                                                     (. kind = AbiSequenceDefinition.SeqKind.CALL; .)
  | CONSTANT                                                 (. kind = AbiSequenceDefinition.SeqKind.CONSTANT; .)
  | NOP                                                      (. kind = AbiSequenceDefinition.SeqKind.NOP; .)
  | RETURN                                                   (. kind = AbiSequenceDefinition.SeqKind.RETURN; .)
  )
    SEQUENCE                                                 (. List<Parameter> params = new ArrayList<>(); .)
    [ parameters<.out params.> ]
    SYM_EQ
    SYM_BRACE_OPEN                                           (. var stmts = new ArrayList<InstructionCallStatement>(); .)
    {
      instructionCallStmt<out InstructionCallStatement stmt> (. stmts.add(stmt); .)
    }
    SYM_BRACE_CLOSE                                          (. def = new AbiSequenceDefinition(kind, params, stmts, start.join(loc())); .)
  .


  // -- CPU DEFINITIONS-----------------------------------------------------------------------------------------------
  microProcessorDefinition<out Definition def>
  = MICRO                                  (. var start = loc(); .)
    PROCESSOR
    identifier<out Identifier id>
    IMPLEMENTS                             (. var implementedIsas = new ArrayList<IsId>(); .)
    identifierPath<out IsId isa>           (. implementedIsas.add(isa); .)
    {
      SYM_COMMA
      identifierPath<out isa>              (. implementedIsas.add(isa); .)
    }
    WITH
    identifierPath<out IsId abi>
    SYM_EQ
    SYM_BRACE_OPEN                         (. var definitions = new ArrayList<Definition>(); .)
    {
      cpuDefinition<out Definition cpuDef> (. addDef(definitions, cpuDef); .)
    }
    SYM_BRACE_CLOSE                        (. def = new MicroProcessorDefinition(id, implementedIsas, abi, definitions, start.join(loc())); .)
  .

  cpuDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<out Annotations annotations>
    ( commonDefinition<out def>
    | patchDefinition<out def>
    | sourceDefinition<out def>
    | exceptionDefinition<out def>
    | cpuFunctionDefinition<out def>
    | cpuProcessDefinition<out def>
    )                               (. def.withAnnotations(annotations); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>    (. def = castCommonDef(this, n);
                                       if (def instanceof DefinitionList list) {
                                         readMacroSymbols(macroTable, list.items);
                                       } .)
  .

  patchDefinition<out Definition def>
  = PATCH                                (. var start = loc(); .)
    identifier<out Identifier generator>
    identifier<out Identifier handle>
    SYM_EQ                               (. IsId reference = null; String source = null; .)
    ( identifierPath<out reference>
    | sourceLiteral<out source> )        (. def = new PatchDefinition(generator, handle, reference, source, start.join(loc())); .)
  .

  sourceDefinition<out Definition def>
  = SOURCE                           (. var start = loc(); .)
    identifier<out Identifier id>
    SYM_EQ
    sourceLiteral<out String source> (. def = new SourceDefinition(id, source, start.join(loc())); .)
  .

  sourceLiteral<out String source>
  = embeddedSource (. source = t.val.substring(3, t.val.length() - 3); .)
  .

  cpuFunctionDefinition<out Definition def> (. var start = lookaheadLoc(); .)
  =                                         (. CpuFunctionDefinition.BehaviorKind kind = null; IsId stopWithRef = null; .)
  ( START                                   (. kind = CpuFunctionDefinition.BehaviorKind.START; .)
  | STOP                                    (. kind = CpuFunctionDefinition.BehaviorKind.STOP; .)
    [ WITH referenceLiteral<out stopWithRef> ]
    /* TODO Verify if "redirect" is needed - "redirect is unstable and must not be used"
    | REDIRECT
      parameters<out redirectParams>
      SYM_ARROW
      typeLiteral<out redirectType>
    */
  )
    SYM_EQ
    expression<out Expr expr, BIN_OPS>      (. def = new CpuFunctionDefinition(kind, stopWithRef, expr, start.join(loc())); .)
  .

  cpuProcessDefinition<out Definition def> (. var start = lookaheadLoc(); .)
  =                                        (. CpuProcessDefinition.ProcessKind kind = null; List<Parameter> startupOutputs = List.of(); .)
  ( FIRMWARE                               (. kind = CpuProcessDefinition.ProcessKind.FIRMWARE; .)
  | STARTUP                                (. kind = CpuProcessDefinition.ProcessKind.STARTUP; .)
    SYM_ARROW
    parameters<out startupOutputs>
  )
    SYM_EQ
    statement<out Statement stmt>          (. def = new CpuProcessDefinition(kind, startupOutputs, stmt, start.join(loc())); .)
  .

  // -- MiA DEFINITIONS-----------------------------------------------------------------------------------------------

  microArchitectureDefinition<out Definition def>
  = MICRO                                 (. var start = loc(); .)
    ARCHITECTURE
    identifier<out Identifier id>
    IMPLEMENTS
    identifierPath<out IsId processor>
    SYM_EQ
    SYM_BRACE_OPEN                        (. var definitions = new ArrayList<Definition>(); .)
    {
      miaDefinition<out Definition child> (. addDef(definitions, child); .)
    }
    SYM_BRACE_CLOSE                       (. def = new MicroArchitectureDefinition(id, processor, definitions, start.join(loc())); .)
  .

  miaDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<out Annotations annotations>
    ( macroInstructionDefinition<out def>
    | portBehaviorDefinition<out def>
    | pipelineDefinition<out def>
    | stageDefinition<out def>
    | cacheDefinition<out def>
    | logicDefinition<out def>
    | signalDefinition<out def>
    | memoryDefinition<out def>
    | IF (la.kind == _REGISTER && scanner.Peek().kind == _FILE)
      registerFileDefinition<out def> // TODO Pass type MIA_DEFS - currently only ISA_DEFS
    | registerDefinition<out def>     // TODO Pass type MIA_DEFS - currently only ISA_DEFS
    | processDefinition<out def>
    | operationDefinition<out def>
    | commonDefinition<out def>
    )                               (. def.withAnnotations(annotations); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>    (. def = castCommonDef(this, n);
                                       if (def instanceof DefinitionList list) {
                                         readMacroSymbols(macroTable, list.items);
                                       } .)
  .

  macroInstructionDefinition<out Definition def> (. var start = lookaheadLoc(); .)
  =                                              (. MacroInstructionDefinition.MacroBehaviorKind kind = null; List<Parameter> inputs = List.of(); .)
  ( TRANSLATION                                  (. kind = MacroInstructionDefinition.MacroBehaviorKind.TRANSLATION; .)
  | PREDICTION                                   (. kind = MacroInstructionDefinition.MacroBehaviorKind.PREDICTION; .)
  | FETCH                                        (. kind = MacroInstructionDefinition.MacroBehaviorKind.FETCH; .)
  | DECODER                                      (. kind = MacroInstructionDefinition.MacroBehaviorKind.DECODER; .)
  | STARTUP                                      (. kind = MacroInstructionDefinition.MacroBehaviorKind.STARTUP; .)
  )
    [ parameters<out inputs> ]
    SYM_ARROW
    parameters<.out List<Parameter> outputs.>
    SYM_EQ
    statement<out Statement stmt>                (. def = new MacroInstructionDefinition(kind, inputs, outputs, stmt, start.join(loc())); .)
  .

  portBehaviorDefinition<out Definition def> (. var start = lookaheadLoc(); .)
  =                                          (. PortBehaviorDefinition.PortKind kind = null; .)
  ( READ                                     (. kind = PortBehaviorDefinition.PortKind.READ; .)
  | WRITE                                    (. kind = PortBehaviorDefinition.PortKind.WRITE; .)
  | HIT                                      (. kind = PortBehaviorDefinition.PortKind.HIT; .)
  | MISS                                     (. kind = PortBehaviorDefinition.PortKind.MISS; .)
  )
    identifier<out Identifier id>
    parameters<.out List<Parameter> inputs.>
    SYM_ARROW
    parameters<.out List<Parameter> outputs.>
    SYM_EQ
    statement<out Statement stmt>            (. def = new PortBehaviorDefinition(id, kind, inputs, outputs, stmt, start.join(loc())); .)
  .

  pipelineDefinition<out Definition def>
  = PIPELINE                      (. var start = loc(); .)
    identifier<out Identifier id> (. List<Parameter> outputs = List.of(); .)
    [ SYM_ARROW parameters<out outputs> ]
    SYM_EQ
    statement<out Statement stmt> (. def = new PipelineDefinition(id, outputs, stmt, start.join(loc())); .)
  .

  stageDefinition<out Definition def>
  = STAGE                         (. var start = loc(); .)
    identifier<out Identifier id> (. List<Parameter> outputs = List.of(); .)
    [ SYM_ARROW parameters<out outputs> ]
    SYM_EQ
    statement<out Statement stmt> (. def = new StageDefinition(id, outputs, stmt, start.join(loc())); .)
  .

  cacheDefinition<out Definition def>
  = CACHE                                   (. var start = loc(); .)
    identifier<out Identifier id>
    SYM_COLON
    typeLiteral<out TypeLiteral sourceType>
    SYM_ARROW
    typeLiteral<out TypeLiteral targetType> (. def = new CacheDefinition(id, sourceType, targetType, start.join(loc())); .)
  .

  logicDefinition<out Definition def>
  = LOGIC                         (. var start = loc(); .)
    identifier<out Identifier id> (. def = new LogicDefinition(id, start.join(loc())); .)
  .

  signalDefinition<out Definition def>
  = SIGNAL                            (. var start = loc(); .)
    identifier<out Identifier id>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. def = new SignalDefinition(id, type, start.join(loc())); .)
  .

  // -- STATEMENTS ---------------------------------------------------------------------------------------------------

  statement<out Statement statement> (. statement = DUMMY_STAT; .)
  = letStatement<out statement>
  | ifStatement<out statement>
  | blockStatement<out statement>
  | raiseStatement<out statement>
  | IF (la.kind == _MATCH && scanner.Peek().kind != _SYM_COLON)
    matchStatement<out statement>
  | IF (isMacroReplacementOfType(this, BasicSyntaxType.STAT))
    macroReplacement<out Node n>     (. statement = castStat(this, n); .)
  | assignmentOrCallStmt<out statement>
  | lockStatement<out statement>
  | forallStatement<out statement>
  .

  blockStatement<out BlockStatement block>     (. var start = loc(); .)
  = SYM_BRACE_OPEN
    statementList<.out List<Statement> stmts.>
    SYM_BRACE_CLOSE                            (. block = new BlockStatement(stmts, start.join(loc())); .)
  .

  statementList<.out List<Statement> stmts.> (. stmts = new ArrayList<>(); .)
  = {
      IF (isMacroReplacementOfType(this, BasicSyntaxType.STATS))
      macroReplacement<out Node n>           (. addStats(stmts, castStats(this, n)); .)
    | statement<out Statement statement>     (. addStats(stmts, statement); .)
    }
  .

  assignmentOrCallStmt<out Statement statement> (. statement = DUMMY_STAT; .)
  = callOrBinaryExpression<out Expr target, false>
    [
      SYM_ASSIGN
      expression<out Expr expr, BIN_OPS>        (. statement = new AssignmentStatement(target, expr); .)
    ]                                           (. if (statement.equals(DUMMY_STAT)) statement = new CallStatement(target); .)
  .

  instructionCallStmt<out InstructionCallStatement statement> (. var namedArguments = new ArrayList<InstructionCallStatement.NamedArgument>(); .)
  = identifierOrPlaceholder<out IdentifierOrPlaceholder id>   (. var start = loc(); .)
    [
      SYM_BRACE_OPEN
      identifier<out Identifier argName>
      SYM_EQ
      expression<out Expr argExpr, BIN_OPS>                   (. namedArguments.add(new InstructionCallStatement.NamedArgument(argName, argExpr)); .)
      {
        SYM_COMMA
        identifier<out argName>
        SYM_EQ
        expression<out argExpr, BIN_OPS>                      (. namedArguments.add(new InstructionCallStatement.NamedArgument(argName, argExpr)); .)
      }
      SYM_BRACE_CLOSE
    ]                                                         (. var unnamedArguments = new ArrayList<Expr>(); .)
    [
      SYM_PAREN_OPEN
      expression<out Expr argExpr, BIN_OPS>                   (. unnamedArguments.add(argExpr); .)
      {
        SYM_COMMA
        expression<out argExpr, BIN_OPS>                      (. unnamedArguments.add(argExpr); .)
      }
      SYM_PAREN_CLOSE
    ]                                                         (. statement = new InstructionCallStatement(id, namedArguments, unnamedArguments, start.join(loc())); .)
  .

  letStatement<out Statement letStatement>
  = LET                                 (. var start = loc(); var identifiers = new ArrayList<Identifier>(); .)
    identifier<out Identifier id>       (. identifiers.add(id); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); .)
    }
    SYM_EQ                              (. Expr valueExpr = DUMMY_EXPR; .)
    ( IF (la.kind == _IF_KW)
      ifExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | IF (la.kind == _FORALL)
      forallExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | expression<out valueExpr, BIN_OPS_EXCEPT_IN>
    )
    SYM_IN
    statement<out Statement body>       (. letStatement = new LetStatement(identifiers, valueExpr, body, start.join(loc())); .)
  .

  ifStatement<out Statement ifStatement> (. Statement elseStmt = null; var start = loc(); .)
  = IF_KW expression<out Expr condition, BIN_OPS>
    THEN statement<out Statement thenStmt>
    [ IF (la.kind == _ELSE)
      ELSE statement<out elseStmt>
    ]                                    (. ifStatement = new IfStatement(condition, thenStmt, elseStmt, start.join(loc())); .)
  .

  raiseStatement<out Statement raise>
  = RAISE                              (. var start = loc(); .)
    statement<out Statement statement> (. raise = new RaiseStatement(statement, start.join(loc())); .)
  .

  matchStatement<out Statement match>
  = MATCH                                   (. var start = loc(); .)
    expression<out Expr candidate, BIN_OPS> (. var cases = new ArrayList<MatchStatement.Case>(); .)
    WITH                                    (. var patterns = new ArrayList<Expr>(); .)
    SYM_BRACE_OPEN                          (. Expr pattern; .)
    ( expression<out pattern, BIN_OPS>      (. patterns.add(pattern); .)
      {
        SYM_COMMA
        expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
      }
    | SYM_BRACE_OPEN
      expression<out pattern, BIN_OPS>      (. patterns.add(pattern); .)
      {
        SYM_COMMA
        expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
      }
      SYM_BRACE_CLOSE
    )
    SYM_BIGARROW
    statement<out Statement result>         (. cases.add(new MatchStatement.Case(new ArrayList<>(patterns), result)); .)
    {
      IF (la.kind == _SYM_COMMA && scanner.Peek().kind != _SYM_UNDERSCORE)
      SYM_COMMA                             (. patterns.clear(); .)
      ( expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>  (. patterns.add(pattern); .)
        }
      | SYM_BRACE_OPEN
        expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>  (. patterns.add(pattern); .)
        }
        SYM_BRACE_CLOSE
      )
      SYM_BIGARROW
      statement<out result>                 (. cases.add(new MatchStatement.Case(new ArrayList<>(patterns), result)); .)
    }                                       (. Statement defaultResult = null; .)
    [
      SYM_COMMA
      SYM_UNDERSCORE
      SYM_BIGARROW
      statement<out defaultResult>
    ]
    SYM_BRACE_CLOSE                         (. match = new MatchStatement(candidate, cases, defaultResult, start.join(loc())); .)
  .

  lockStatement<out Statement lock>
  = LOCK (. var start = loc(); .)
    callOrBinaryExpression<out Expr expr, false>
    SYM_IN
    statement<out Statement statement> (. lock = new LockStatement(expr, statement, start.join(loc())); .)
  .

  forallStatement<out Statement forall> (. var start = lookaheadLoc(); .)
  = FORALL                              (. var indices = new ArrayList<ForallStatement.Index>(); .)
    identifier<out Identifier indexName>
    SYM_IN
    rangeExpression<out Expr domain>    (. indices.add(new ForallStatement.Index(indexName, domain)); .)
    {
      SYM_COMMA
      identifier<out indexName>
      SYM_IN
      rangeExpression<out domain>       (. indices.add(new ForallStatement.Index(indexName, domain)); .)
    }
    DO
    statement<out Statement statement>  (. forall = new ForallStatement(indices, statement, start.join(loc())); .)
  .

  // -- EXPRESSIONS --------------------------------------------------------------------------------------------------

  expression<out Expr expr, boolean[] allowedOps>
  = term<out expr>
    {
      IF (allowedOps[la.kind] || la.kind == _SYM_AS || isMacroReplacementOfType(this, BasicSyntaxType.BIN_OP))
      (
        binaryOperator<out Operator op>           (. var operator = new BinOp(op, loc()); .)
        term<out Expr right>                      (. expr = new BinaryExpr(expr, operator, right); .)
      | macroReplacement<out Node node>
        term<out Expr right>                      (. expr = new BinaryExpr(expr, castBinOp(this, node), right); .)
      | SYM_AS                                    (. var typeStart = loc(); .)
        identifierPath<out IsId path>             (. TypeLiteral castTarget = new TypeLiteral(path, new ArrayList<>(), typeStart.join(loc()));
                                                     expr = new CastExpr(expr, castTarget); .)
        { IF (expr instanceof CastExpr && la.kind == _SYM_LT)
          SYM_LT                                  (. var lessLoc = loc(); .)
          term<out Expr term>                     (. var isSize = false; .)
          [
            IF (!allowedOps[_SYM_LT] || la.kind == _SYM_GT) (. isSize = true; .)
            SYM_GT                                (. castTarget.sizeIndices.add(List.of(term)); .)
          ]                                       (. if (!isSize) expr = new BinaryExpr(reorderCastExpr(expr), new BinOp(Operator.Less(), lessLoc), term); .)
        }                                         (. if (expr instanceof CastExpr) expr = reorderCastExpr(expr); .)
      )
    }                                             (. expr = reorderBinaryExpr(expr); .)
  .

  /// Call expressions of form "a::b<3>().c()".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  callOrBinaryExpression<out Expr expr, boolean allowLtOp> (. expr = DUMMY_EXPR; .)
  = IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.SYM_EX))
    symbolOrBinaryExpression<out expr, allowLtOp>          (. List<List<Expr>> argsIndices = new ArrayList<>(); .)
    {
      // Check if we received a symbol expression -> collect arguments
      // Otherwise, just return the collected binary expression
      IF (la.kind == _SYM_PAREN_OPEN && expr instanceof IsSymExpr)
      arguments<.out List<Expr> args.>                     (. argsIndices.add(args); .)
    }                                                      (. List<CallExpr.SubCall> subCalls = new ArrayList<>(); .)
    {
      IF (la.kind == _SYM_DOT && expr instanceof IsSymExpr)
      SYM_DOT                                              (. var subCallArgsIndices = new ArrayList<List<Expr>>(); .)
      identifier<out Identifier id>
      {
        IF (la.kind == _SYM_PAREN_OPEN)
        arguments<.out List<Expr> args.>                   (. subCallArgsIndices.add(args); .)
      }                                                    (. subCalls.add(new CallExpr.SubCall(id, subCallArgsIndices)); .)
    }                                                      (. if (expr instanceof IsSymExpr symExpr && (!argsIndices.isEmpty() || !subCalls.isEmpty()))
                                                                expr = new CallExpr(symExpr, argsIndices, subCalls, expr.location().join(loc()));
                                                           .)
  | macroReplacement<out Node node>                        (. expr = castExpr(this, node); .)
  .

  /// Represents one set of invocation arguments.
  /// Multiple invocations (e.g. multi-dimensional access) will need multiple #arguments
  arguments<.out List<Expr> args.>
  = SYM_PAREN_OPEN                            (. args = new ArrayList<>(); .)
    expression<out Expr arg, BIN_OPS>         (. args.add(arg); .)
    ( SYM_RANGE
      expression<out Expr rangeTo, BIN_OPS>   (. args.set(0, new RangeExpr(arg, rangeTo)); .)
    | {
      SYM_COMMA
      expression<out Expr nextArg, BIN_OPS>   (. args.add(nextArg); .)
    })
    SYM_PAREN_CLOSE
  .

  /// Symbol expressions of form "a::b<3>".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  symbolOrBinaryExpression<out Expr expr, boolean allowLtOp> (. expr = DUMMY_EXPR; .)
  = IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.ID))
    identifierPath<out IsId path>
    [
      IF (la.kind == _SYM_LT)
      SYM_LT                                                 (. var lessLoc = loc(); .)
      term<out Expr term>
      [
        IF (!allowLtOp || la.kind == _SYM_GT)
        SYM_GT                                               (. expr = new SymbolExpr(path, term, path.location().join(loc())); .)
      ]                                                      (. if (expr.equals(DUMMY_EXPR)) expr = new BinaryExpr((Expr) path, new BinOp(Operator.Less(), lessLoc), term); .)
    ]                                                        (. if (expr.equals(DUMMY_EXPR)) expr = (Expr) path; .)
  | macroReplacement<out Node node>                          (. expr = castExpr(this, node); .)
  .

  binaryOperator<out Operator op> (. op = null; .)
  = SYM_BINAND                    (. op = Operator.And(); .)
  | SYM_BINOR                     (. op = Operator.Or(); .)
  | SYM_CARET                     (. op = Operator.Xor(); .)
  | SYM_DIV                       (. op = Operator.Divide(); .)
  | SYM_ELEM_OF                   (. op = Operator.ElementOf(); .)
  | SYM_EQ                        (. op = Operator.Equal(); .)
  | SYM_GT                        (. op = Operator.Greater(); .)
  | SYM_GTE                       (. op = Operator.GreaterEqual(); .)
  | SYM_IN                        (. op = Operator.In(); .)
  | SYM_LOGAND                    (. op = Operator.LogicalAnd(); .)
  | SYM_LOGOR                     (. op = Operator.LogicalOr(); .)
  | SYM_LONG_MUL                  (. op = Operator.LongMultiply(); .)
  | SYM_LT                        (. op = Operator.Less(); .)
  | SYM_LTE                       (. op = Operator.LessEqual(); .)
  | SYM_MINUS                     (. op = Operator.Subtract(); .)
  | SYM_MOD                       (. op = Operator.Modulo(); .)
  | SYM_MUL                       (. op = Operator.Multiply(); .)
  | SYM_NEQ                       (. op = Operator.NotEqual(); .)
  | SYM_NIN                       (. op = Operator.NotIn(); .)
  | SYM_NOT_ELEM_OF               (. op = Operator.NotElementOf(); .)
  | SYM_PLUS                      (. op = Operator.Add(); .)
  | SYM_ROTL                      (. op = Operator.RotateLeft(); .)
  | SYM_ROTR                      (. op = Operator.RotateRight(); .)
  | SYM_SAT_ADD                   (. op = Operator.SaturatedAdd(); .)
  | SYM_SAT_SUB                   (. op = Operator.SaturatedSubtract(); .)
  | SYM_SHL                       (. op = Operator.ShiftLeft(); .)
  | SYM_SHR                       (. op = Operator.ShiftRight(); .)
  // When adding a new operator here, it must also be added to the "BIN_OPS" list in ParserUtils.java!
  .

  unary<out Expr expr>
  = unaryOperator<out IsUnOp op>
    term<out Expr operand> (. if (operand instanceof BinaryExpr binExpr) {
                                expr = new BinaryExpr(new UnaryExpr(op, binExpr.left), binExpr.operator, binExpr.right);
                              } else {
                                expr = new UnaryExpr(op, operand);
                              }
                           .)
  .

  unaryOperator<out IsUnOp op>   (. op = null; .)
  = SYM_MINUS                    (. op = new UnOp(UnaryOperator.NEGATIVE, loc()); .)
  | SYM_EXCL                     (. op = new UnOp(UnaryOperator.LOG_NOT, loc()); .)
  | SYM_TILDE                    (. op = new UnOp(UnaryOperator.COMPLEMENT, loc()); .)
  // When adding a new operator here, it must also be added to the "UN_OPS" list in ParserUtils.java!
  | macroReplacement<out Node n> (. op = (IsUnOp) n; .)
  .

  term<out Expr expr>            (. expr = DUMMY_EXPR; .)
  = literal<out expr>
  | IF (la.kind == _MATCH && scanner.Peek().kind != _SYM_COLON) // Disambiguate from macro match
    matchExpression<out expr>
  | IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.CALL_EX))
    callOrBinaryExpression<out expr, true>
  | groupedExpression<out expr>
  | IF(isUnaryOperator(la) || isMacroReplacementOfType(this, BasicSyntaxType.UN_OP))
    unary<out expr>
  | ifExpression<out expr, BIN_OPS>
  | letExpression<out expr>
  | existsExpression<out expr>
  | forallExpression<out expr, BIN_OPS>
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.EX))
    macroReplacement<out Node n> (. expr = castExpr(this, n); .)
  .

  groupedExpression<out GroupedExpr expr> (. expr = new GroupedExpr(new ArrayList<>(), loc()); .)
  = SYM_PAREN_OPEN
    expression<out Expr inner, BIN_OPS>   (. expr.expressions.add(inner); .)
    {
      SYM_COMMA
      expression<out Expr next, BIN_OPS>  (. expr.expressions.add(next); .)
    }
    SYM_PAREN_CLOSE                       (. expr.loc = expr.loc.join(loc()); .)
  .

  literal<out Expr expr> (. expr = DUMMY_EXPR; .)
  = valLiteral<out expr>
  | stringLiteral<out expr>
  .

  valLiteral<out Expr expr> (. expr = DUMMY_EXPR; .)
  = boolLiteral<out expr>
  | intLiteral<out expr>
  | binLiteral<out expr>
  .

  intLiteral<out Expr expr>
  = decLit (. expr = new IntegerLiteral(t.val, loc()); .)
  .

  binLiteral<out Expr expr>
  = (hexLit | binLit) (. expr = new BinaryLiteral(t.val, loc()); .)
  .

  boolLiteral<out Expr expr> (. expr = DUMMY_EXPR; .)
  = TRUE                     (. expr = new BoolLiteral(true, loc()); .)
  | FALSE                    (. expr = new BoolLiteral(false, loc()); .)
  .

  referenceLiteral<out IsId reference>
  = SYM_AT
    identifierPath<out reference>
  .

  identifierPath<out IsId path>                                 (. List<IdentifierOrPlaceholder> segments = new ArrayList<>(); .)
  = identifierOrPlaceholder<out IdentifierOrPlaceholder id>     (. segments.add(id); .)
    {
      SYM_NAMESPACE
      identifierOrPlaceholder<out IdentifierOrPlaceholder next> (. segments.add(next); .)
    }                                                           (. if (segments.size() == 1) path = id;
                                                                   else path = new IdentifierPath(segments); .)
  .

  rangeExpression<out Expr expr>
  = expression<out expr, BIN_OPS>
    [ SYM_RANGE expression<out Expr to, BIN_OPS> (. expr = new RangeExpr(expr, to); .) ]
  .

  letExpression<out Expr expr>
  = LET                                 (. var start = loc(); var identifiers = new ArrayList<Identifier>(); .)
    identifier<out Identifier id>       (. identifiers.add(id); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); .)
    }
    SYM_EQ                              (. Expr valueExpr = DUMMY_EXPR; .)
    ( IF (la.kind == _IF_KW)
      ifExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | IF (la.kind == _FORALL)
      forallExpression<out expr, BIN_OPS_EXCEPT_IN>
    | expression<out valueExpr, BIN_OPS_EXCEPT_IN>
    )
    SYM_IN
    expression<out Expr body, BIN_OPS>  (. expr = new LetExpr(identifiers, valueExpr, body, start.join(loc())); .)
  .

  ifExpression<out Expr expr, boolean[] allowedElseOps>
  = IF_KW                                              (. var startLoc = loc(); .)
    expression<out Expr condition, BIN_OPS>
    THEN expression<out Expr thenExpr, BIN_OPS>
    ELSE expression<out Expr elseExpr, allowedElseOps> (. expr = new IfExpr(condition, thenExpr, elseExpr, startLoc.join(loc())); .)
  .

  matchExpression<out Expr expr>
  = MATCH                                     (. var start = loc(); .)
    expression<out Expr candidate, BIN_OPS>
    WITH
    SYM_BRACE_OPEN                            (. var cases = new ArrayList<MatchExpr.Case>();  .)
    {                                         (. var patterns = new ArrayList<Expr>(); .)
      ( expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        }
      | SYM_BRACE_OPEN
        expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        }
        SYM_BRACE_CLOSE
      )
      SYM_BIGARROW
      expression<out Expr result, BIN_OPS>    (. cases.add(new MatchExpr.Case(patterns, result)); .)
      SYM_COMMA
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    expression<out Expr defaultResult, BIN_OPS>
    SYM_BRACE_CLOSE                           (. expr = new MatchExpr(candidate, cases, defaultResult, start.join(loc())); .)
  .

  existsExpression<out Expr expr>                   (. expr = DUMMY_EXPR; .)
  = EXISTS                                          (. var start = loc(); .)
    ( IF (la.kind == _SYM_IN)
      SYM_IN
      operationsList<.out List<IsId> operations.>   (. expr = new ExistsInExpr(operations, start.join(loc())); .)
    | identifierOrPlaceholder<out IdentifierOrPlaceholder id>
      SYM_IN                                        (. var conditions = new ArrayList<ExistsInThenExpr.Condition>(); .)
      operationsList<.out List<IsId> operations.>   (. conditions.add(new ExistsInThenExpr.Condition(id, operations)); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out id>
        SYM_IN
        operationsList<out operations>              (. conditions.add(new ExistsInThenExpr.Condition(id, operations)); .)
      }
      THEN
      expression<out Expr thenExpr, BIN_OPS>        (. expr = new ExistsInThenExpr(conditions, thenExpr, start.join(loc())); .)
    )
  .

  operationsList<.out List<IsId> operations.>
  = SYM_BRACE_OPEN                (. operations = new ArrayList<>(); .)
    identifierPath<out IsId path> (. operations.add(path); .)
    {
      SYM_COMMA
      identifierPath<out path>    (. operations.add(path); .)
    }
    SYM_BRACE_CLOSE
  .

  forallExpression<out Expr forallExpr, boolean[] allowedOps> (. forallExpr = DUMMY_EXPR; .)
  = FORALL                                                    (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_IN
    (                                                         (. var indices = new ArrayList<ForallThenExpr.Index>(); .)
      operationsList<.out List<IsId> operations.>             (. indices.add(new ForallThenExpr.Index(id, operations)); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out id>
        SYM_IN
        operationsList<out operations>                        (. indices.add(new ForallThenExpr.Index(id, operations)); .)
      }
      THEN
      expression<out Expr thenExpr, allowedOps>               (. forallExpr = new ForallThenExpr(indices, thenExpr, start.join(loc())); .)
    |                                                         (. var indices = new ArrayList<ForallExpr.Index>(); .)
      rangeExpression<out Expr domain>                        (. indices.add(new ForallExpr.Index(id, domain)); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out id>
        SYM_IN
        rangeExpression<out domain>                           (. indices.add(new ForallExpr.Index(id, domain)); .)
      }                                                       (. ForallExpr.Operation operation = null; Operator foldAction = null; .)
      ( APPEND                                                (. operation = ForallExpr.Operation.APPEND; .)
      | TENSOR                                                (. operation = ForallExpr.Operation.TENSOR; .)
      | FOLD                                                  (. operation = ForallExpr.Operation.FOLD; .)
        binaryOperator<out foldAction>
        WITH
      )
      expression<out Expr expr, allowedOps>                   (. forallExpr = new ForallExpr(indices, operation, foldAction, expr, start.join(loc())); .)
    )
  .

  // -- PRIMITIVES ---------------------------------------------------------------------------------------------------

  typeLiteral<out TypeLiteral type>
  = identifierPath<out IsId path>                        (. List<List<Expr>> sizeIndices = new ArrayList<>(); .)
    {
      SYM_LT                                             (. List<Expr> sizes = new ArrayList<>(); .)
      expression<out Expr sizeExpr, BIN_OPS_EXCEPT_GT>   (. sizes.add(sizeExpr); .)
      {
        SYM_COMMA
        expression<out Expr nextSize, BIN_OPS_EXCEPT_GT> (. sizes.add(nextSize); .)
      }
      SYM_GT                                             (. sizeIndices.add(sizes); .)
    }                                                    (. type = new TypeLiteral(path, sizeIndices, path.location().join(loc())); .)
  .

  identifier<out Identifier identifier>
  = (identifierToken | allowedIdentifierKeywords) (. identifier = new Identifier(t.val, loc()); .)
  .

  /// Must be kept in sync with ParserUtils.ID_TOKENS.
  allowedIdentifierKeywords
  = ADDRESS
  | ALIAS
  // | ASSERT
  | APPEND
  | BINARY
  | CALL
  | CONSTANT
  // | DESCRIPTION
  | ENCODE
  | EXCEPTION
  | FETCH
  | FIRMWARE
  | GROUP
  | INSTRUCTION
  // | INVALID
  // | LABEL
  | MEMORY
  // | MNEMONIC
  // | MODE
  // | MODIFIER
  | NONE
  | NOP
  // | OPERAND
  | OPERATION
  | PREDICATE
  | PREDICTION
  // | PROCEDURE
  | READ
  // | REDIRECT
  | REGISTER
  | RETURN
  | SEQUENCE
  | STAGE
  | START
  | STARTUP
  | STOP
  // | SYMBOL
  | SYM_IN
  | T_BIN
  | T_BIN_OP
  | T_BOOL
  | T_CALL_EX
  | T_COMMON_DEFS
  | T_ENCS
  | T_ID
  | T_INT
  | T_ISA_DEFS
  | T_LIT
  | T_STAT
  | T_STATS
  | T_STR
  | T_SYM_EX
  | T_UN_OP
  | T_VAL
  | TRANSLATION
  // | UNIT
  // | USER
  | WRITE
  // TODO Add all allowed keywords
  .

  sequenceCallExprList<.out List<SequenceCallExpr> list.> (. list = new ArrayList<>(); .)
  = ( sequenceCallExpr<out SequenceCallExpr call>         (. list.add(call); .)
    | SYM_BRACK_OPEN
      sequenceCallExpr<out SequenceCallExpr call>         (. list.add(call); .)
      {
        SYM_COMMA
        sequenceCallExpr<out call>                        (. list.add(call); .)
      }
      SYM_BRACK_CLOSE
    )                                                     (. list = expandSequenceCalls(this, list); .)
  .

  sequenceCallExpr<out SequenceCallExpr call> (. var start = lookaheadLoc(); .)
  = identifier<out Identifier id>             (. Expr range = null; .)
    [
      SYM_BRACE_OPEN
      rangeExpression<out range>
      SYM_BRACE_CLOSE
    ]                                         (. call = new SequenceCallExpr(id, range, start.join(loc())); .)
  .

  // -- MACROS -------------------------------------------------------------------------------------------------------

  macroReplacement<out Node body> (. body = DUMMY_ID; .)
  = ( macroMatch<out body>
    | maximumMacroExpr<out body>
    | extendId<out body>
    | idToStr<out body>
    )                             (. body = expandNode(this, body); .)
  .

  extendId<out Node body>
  = EXTEND_ID                               (. var start = loc(); .)
    groupedExpression<out GroupedExpr expr> (. body = new ExtendIdExpr(expr, start.join(loc())); .)
  .

  idToStr<out Node body>
  = ID_TO_STR       (. var start = loc(); .)
    SYM_PAREN_OPEN
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_PAREN_CLOSE (. body = new IdToStrExpr(id, start.join(loc())); .)
  .

  macroMatch<out Node node>
  = MATCH                                             (. var start = loc(); .)
    SYM_COLON
    basicSyntaxType<out SyntaxType type>
    SYM_PAREN_OPEN                                    (. var choices = new ArrayList<MacroMatch.Choice>(); .)
    macroReplacement<out Node candidate>              (. var patterns = new ArrayList<MacroMatch.Pattern>(); .)
    (SYM_EQ | SYM_NEQ )                               (. var comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
    macroBody<out Node match, candidate.syntaxType()> (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
    {
      SYM_COMMA
      macroReplacement<out candidate>
      (SYM_EQ | SYM_NEQ )                             (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
      macroBody<out match, candidate.syntaxType()>    (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
    }
    SYM_BIGARROW
    macroBody<out Node result, type>                  (. choices.add(new MacroMatch.Choice(patterns, result)); .)
    SYM_SEMICOLON
    {                                                 (. patterns = new ArrayList<MacroMatch.Pattern>(); .)
      macroReplacement<out candidate>
      (SYM_EQ | SYM_NEQ )                             (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
      macroBody<out match, candidate.syntaxType()>    (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
      {
        SYM_COMMA
        macroReplacement<out candidate>
        (SYM_EQ | SYM_NEQ )                           (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
        macroBody<out match, candidate.syntaxType()>  (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
      }
      SYM_BIGARROW
      macroBody<out result, type>                     (. choices.add(new MacroMatch.Choice(patterns, result)); .)
      SYM_SEMICOLON
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    macroBody<out Node defaultChoice, type>
    SYM_PAREN_CLOSE                                   (. node = createMacroMatch(type, choices, defaultChoice, start.join(loc())); .)
  .

  /// Parses the longest macro expression (either instance or placeholder) from the parser.
  maximumMacroExpr<out Node node>                 (. node = null; .)
  = SYM_DOLLAR                                    (. var segments = new ArrayList<String>(); var startLoc = loc();.)
    identifier<out Identifier id>                 (. var macro = macroTable.getMacro(id.name);
                                                     var paramType = paramSyntaxType(this, id.name);
                                                     segments.add(id.name); .)
    { IF (macro == null && la.kind == _SYM_DOT && paramType instanceof RecordType record)
      SYM_DOT
      identifier<out Identifier next>             (. paramType = record.findEntry(next.name); segments.add(next.name); .)
    }
    [
      IF (la.kind == _SYM_PAREN_OPEN && (macro != null || paramType instanceof ProjectionType))
      SYM_PAREN_OPEN                              (. var macroOrPlaceholder = macroOrPlaceholder(macro, paramType, segments);
                                                     var params = instanceParamTypes(macroOrPlaceholder);
                                                     var args = new ArrayList<Node>(); .)
      (
        IF (!params.hasNext())
        SYM_PAREN_CLOSE
      | macroBody<out Node arg1, params.next()>   (. args.add(arg1); .)
        {
          SYM_SEMICOLON
          macroBody<out Node arg2, params.next()> (. args.add(arg2); .)
        }
        SYM_PAREN_CLOSE
      )                                           (. node = createMacroInstance(macroOrPlaceholder, args, startLoc.join(loc())); .)
    ]                                             (. node = Objects.requireNonNullElse(node, createPlaceholder(paramType, segments, startLoc.join(loc()))); .)
  .

  macroDef<out ModelDefinition def>
  = MODEL                                   (. var startLoc = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_PAREN_OPEN                          (. var params = new ArrayList<MacroParam>(); .)
    [
      identifier<out Identifier paramId1>
      SYM_COLON
      syntaxType<out SyntaxType synType1>   (. params.add(new MacroParam(paramId1, synType1)); .)
      {
        SYM_COMMA
        identifier<out Identifier paramId2>
        SYM_COLON
        syntaxType<out SyntaxType synType2> (. params.add(new MacroParam(paramId2, synType2)); .)
      }
    ]
    SYM_PAREN_CLOSE                         (. macroContext.addFirst(params); .)
    SYM_COLON
    basicSyntaxType<out SyntaxType returnType>
    SYM_EQ
    SYM_BRACE_OPEN
    macroBody<out Node body, returnType>
    SYM_BRACE_CLOSE                         (. macroContext.removeFirst();
                                               SyntaxType macroType = assertSyntaxType(this, body, returnType, "Macro body does not match signature")
                                                 ? returnType : BasicSyntaxType.INVALID;
                                               def = new ModelDefinition(id, params, body, macroType, startLoc.join(loc()));
                                            .)
  .

  macroBody<out Node body, SyntaxType type>                 (. body = DUMMY_ID; var start = lookaheadLoc(); .)
  = (
    IF (type == BasicSyntaxType.STATS)
    statementList<.out List<Statement> stmts.>              (. body = new StatementList(stmts, start.join(loc())); .)
  | IF (type == BasicSyntaxType.STAT)
    statement<out body>
  | IF (type == BasicSyntaxType.ENCS)
    encodingDefinitionList<out body>
  | IF (type == BasicSyntaxType.ISA_DEFS)                   (. macroTable = macroTable.createChild(); .)
    isaDefinitionList<.out List<Definition> defs.>          (. body = new DefinitionList(defs, start.join(loc())); macroTable = macroTable.parent; .)
  | IF (type == BasicSyntaxType.COMMON_DEFS)
    commonDefinitionList<.out List<Definition> defs.>       (. body = new DefinitionList(defs, start.join(loc())); macroTable = macroTable.parent; .)
  | IF (type == BasicSyntaxType.EX)
    expression<out body, BIN_OPS>
  | IF (type == BasicSyntaxType.LIT)
    ( literal<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.STR)
    ( stringLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.VAL)
    ( valLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.BOOL)
    ( boolLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.INT)
    ( intLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.BIN)
    ( binLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.CALL_EX)
    callOrBinaryExpression<out body, false>
  | IF (type == BasicSyntaxType.SYM_EX)
    symbolOrBinaryExpression<out body, false>
  | IF (type == BasicSyntaxType.ID)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. body = (Node) id; .)
  | IF (type == BasicSyntaxType.BIN_OP)
    ( binaryOperator<out Operator op>                       (. body = new BinOp(op, loc()); .)
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.UN_OP)
    unaryOperator<out IsUnOp op>                            (. body = (Node) op; .)
  | IF (type instanceof RecordType recordType)
    ( SYM_PAREN_OPEN                                        (. var entries = new ArrayList<Node>(recordType.entries.size()); var nextEntry = recordType.entries.iterator(); .)
      macroBody<out Node entry, nextEntry.next().type()>    (. entries.add(entry); .)
      {
        SYM_SEMICOLON
        macroBody<out entry, nextEntry.next().type()>       (. entries.add(entry); .)
      }
      SYM_PAREN_CLOSE                                       (. body = new RecordInstance(recordType, entries, start.join(loc())); .)
    | macroReplacement<out body>
    )
  | IF (type instanceof ProjectionType projection)
    ( identifier<out Identifier id>                         (. body = new MacroReference(macroTable.getMacro(id.name), projection, id.location()); .)
    | macroReplacement<out body>
    )
  | internalError<"Unhandled syntax type " + type>
  )                                                         (. assertSyntaxType(this, body, type, "Mismatched node type"); .)
  .

  syntaxType<out SyntaxType type> (. type = BasicSyntaxType.INVALID; .)
  = IF (la.kind == _identifierToken)
    identifier<out Identifier id> (. type = macroTable.findType(id); .)
  | projectionType<out type>
  | basicSyntaxType<out type>
  .

  projectionType<out ProjectionType type>     (. var arguments = new ArrayList<SyntaxType>(); .)
  = SYM_PAREN_OPEN
    [
      syntaxType<out SyntaxType argType>      (. arguments.add(argType); .)
      { SYM_COMMA syntaxType<out argType>     (. arguments.add(argType); .) }
    ]
    SYM_PAREN_CLOSE
    SYM_ARROW
    syntaxType<out SyntaxType resultType>     (. type = new ProjectionType(arguments, resultType); .)
  .

  basicSyntaxType<out BasicSyntaxType type> (. type = BasicSyntaxType.INVALID; .)
  = T_BIN                                   (. type = BasicSyntaxType.BIN; .)
  | T_BIN_OP                                (. type = BasicSyntaxType.BIN_OP; .)
  | T_BOOL                                  (. type = BasicSyntaxType.BOOL; .)
  | T_CALL_EX                               (. type = BasicSyntaxType.CALL_EX; .)
  | T_COMMON_DEFS                           (. type = BasicSyntaxType.COMMON_DEFS; .)
  | T_ENCS                                  (. type = BasicSyntaxType.ENCS; .)
  | T_EX                                    (. type = BasicSyntaxType.EX; .)
  | T_ID                                    (. type = BasicSyntaxType.ID; .)
  | T_INT                                   (. type = BasicSyntaxType.INT; .)
  | T_ISA_DEFS                              (. type = BasicSyntaxType.ISA_DEFS; .)
  | T_LIT                                   (. type = BasicSyntaxType.LIT; .)
  | T_STAT                                  (. type = BasicSyntaxType.STAT; .)
  | T_STATS                                 (. type = BasicSyntaxType.STATS; .)
  | T_STR                                   (. type = BasicSyntaxType.STR; .)
  | T_SYM_EX                                (. type = BasicSyntaxType.SYM_EX; .)
  | T_UN_OP                                 (. type = BasicSyntaxType.UN_OP; .)
  | T_VAL                                   (. type = BasicSyntaxType.VAL; .)
  .

  internalError<String message>             (. var position = t.line + ":" + t.col; .)
  = ANY                                     (. throw new IllegalStateException("Internal error in grammar at token (" + position + "): " + message); .)
  .

END vadl.
