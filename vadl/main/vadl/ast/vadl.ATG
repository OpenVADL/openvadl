$package=vadl.ast
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import vadl.ast.EncodingDefinition.FieldEncoding;
import vadl.ast.FunctionDefinition.Parameter;
import vadl.utils.SourceLocation;

import static vadl.ast.CounterDefinition.CounterKind.GROUP;
import static vadl.ast.CounterDefinition.CounterKind.PROGRAM;
import static vadl.ast.ParserUtils.*;

COMPILER vadl
  java.net.URI sourceFile = SourceLocation.INVALID_SOURCE_LOCATION.uri();
  boolean insideMacro = false;
  Deque<List<MacroParam>> macroContext = new ArrayDeque<>();
  Ast ast = new Ast();
  SymbolTable symbolTable = new SymbolTable();
  Map<String, Identifier> macroOverrides = new HashMap<>();

  { symbolTable.loadBuiltins(); }

  SourceLocation loc() {
    return locationFromToken(this, t);
  }

  SourceLocation lookaheadLoc() {
    return locationFromToken(this, la);
  }

CHARACTERS
  digit = '0' .. '9'.
  binDigit = '0' .. '1'.
  hexDigit = '0' .. '9' + 'A' .. 'F' + 'a' .. 'f'.
  letter = 'a' .. 'z' + 'A' .. 'Z'.
  validDQStringCharacters = ANY - '"' - "\\".
  validSQStringCharacters = ANY - "'" - "\\".

TOKENS
  hexLit = "0x" hexDigit {hexDigit | "'"}.
  binLit = "0b" binDigit {binDigit | "'"}.
  decLit = digit {digit | "'"}.

  identifierToken = letter {letter | digit | "_"}.
  string =
  ( '"' { "\\" (letter | '"' | "'" | "\\") | validDQStringCharacters } '"') |
  ( "'" { "\\" (letter | '"' | "'" | "\\") | validSQStringCharacters } "'").

  T_STATS = "Stats".
  T_STAT = "Stat".
  T_ENCS = "Encs".
  T_ISA_DEFS = "IsaDefs".
  T_EX = "Ex".
  T_LIT = "Lit".
  T_STR = "Str".
  T_VAL = "Val".
  T_BOOL = "Bool".
  T_INT = "Int".
  T_BIN = "Bin".
  T_CALL_EX = "CallEx".
  T_SYM_EX = "SymEx".
  T_ID = "Id".
  T_BIN_OP = "BinOp".
  T_UN_OP = "UnOp".

  INSTRUCTION = "instruction".
  SET = "set".
  ARCHITECTURE = "architecture".
  CONSTANT = "constant".
  FORMAT = "format".
  PROGRAM = "program".
  GROUP = "group".
  COUNTER = "counter".
  ENCODING = "encoding".
  ASSEMBLY = "assembly".
  MEMORY = "memory".
  REGISTER = "register".
  MODEL = "model".
  FILE = "file".
  ALIAS = "alias".
  LET = "let".
  KW_IF = "if".
  THEN = "then".
  ELSE = "else".
  USING = "using".
  FUNCTION = "function".
  TRUE = "true".
  FALSE = "false".
  EXTENDING = "extending".
  MATCH = "match".
  ENUMERATION = "enumeration".
  WITH = "with".
  RAISE = "raise".
  EXCEPTION = "exception".
  RECORD = "record".
  MODEL_TYPE = "model-type".
  EXTEND_ID = "ExtendId".
  ID_TO_STR = "IdToStr".
  PSEUDO = "pseudo".
  KW_COMPILER = "compiler".
  PREDICATE = "predicate".
  ENCODE = "encode".

  SYM_IN = "in".
  SYM_AS = "as".
  SYM_EQ = "=".
  SYM_GT = ">".
  SYM_LT = "<".
  SYM_NIN = "!in".
  SYM_NEQ = "!=".
  SYM_GTE = ">=".
  SYM_LTE = "<=".
  SYM_MUL = "*".
  SYM_DIV = "/".
  SYM_MOD = "%".
  SYM_DOT = ".".
  SYM_SHR = ">>".
  SYM_SHL = "<<".
  SYM_ROTR = "<>>".
  SYM_ROTL = "<<>".
  SYM_EXCL = "!".
  SYM_PLUS = "+".
  SYM_MINUS = "-".
  SYM_TILDE = "~".
  SYM_COLON = ":".
  SYM_COMMA = ",".
  SYM_CARET = "^".
  SYM_BINOR = "|".
  SYM_LOGOR = "||".
  SYM_ARROW = "->".
  SYM_RANGE = "..".
  SYM_BINAND = "&".
  SYM_LOGAND = "&&".
  SYM_ASSIGN = ":=".
  SYM_DOLLAR = "$".
  SYM_BIGARROW = "=>".
  SYM_SEMICOLON = ";".
  SYM_NAMESPACE = "::".
  SYM_UNDERSCORE = "_".
  SYM_PAREN_OPEN = "(".
  SYM_BRACK_OPEN = "[".
  SYM_BRACE_OPEN = "{".
  SYM_PAREN_CLOSE = ")".
  SYM_BRACK_CLOSE = "]".
  SYM_BRACE_CLOSE = "}".

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
  vadl =
  {
    topLevelDefinitions<out Definition d>   (. ast.definitions.add(d); .)
    | macroDef
    | recordDefinition
    | modelTypeDef
  }.

  // -- DEFINITIONS --------------------------------------------------------------------------------------------------
  topLevelDefinitions<out Definition def> (. def = null; .)
  = instructionsetDefinition<out def>
  | commonDefinition<out def>
  .

  commonDefinition<out Definition def>    (. def = null; .)
  = constantDefinition<out def>
  | formatDefinition<out def>
  | usingDefinition<out def>
  | functionDefinition<out def>
  .

  instructionsetDefinition<out InstructionSetDefinition isaDef>
  = INSTRUCTION SET ARCHITECTURE                                (. var startLocation = loc(); .)
    identifier<out Identifier identifier>                       (. Identifier extending = null; .)
    [
      EXTENDING
      identifier<out extending>
    ]
    SYM_EQ SYM_BRACE_OPEN
    isaDefinitionList<.out List<Definition> definitions.>
    SYM_BRACE_CLOSE                                             (. isaDef = new InstructionSetDefinition(identifier, extending, definitions, startLocation.join(loc())); .)
  .

  isaDefinitionList<. out List<Definition> definitions .>             (. definitions = new ArrayList<>(); .)
  = {
    annotations<.out List<Annotation> annotations.>
    isaDefinition<out Definition def>                                 (. def.annotations.annotations().addAll(annotations); definitions.add(def); .)
  | macroDef
  | recordDefinition
  | modelTypeDef
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.ISA_DEFS))
    macroReplacement<out Node n>                                      (. if (n instanceof DefinitionList defs) definitions.addAll(defs.items);
                                                                         else definitions.add((Definition) n); .)
  }
  .

  annotations<.out List<Annotation> annotations.> (. annotations = new ArrayList<>(); .)
  = {
    annotation<out Annotation annotation>         (. annotations.add(annotation); .)
  }
  .

  annotation<out Annotation annotation> (. TypeLiteral type = null; Identifier property = null; .)
  = SYM_BRACK_OPEN
    expression<out Expr expr, BIN_OPS>
    [ (SYM_COLON typeLiteral<out type>)
    | identifier<out property>
    ]
    SYM_BRACK_CLOSE                     (. annotation = new Annotation(expr, type, property); .)
  .

  isaDefinition<out Definition def> (. def = null; .)
  = commonDefinition<out def>
  | counterDefinition<out def>
  | instructionDefinition<out def>
  | pseudoInstructionDefinition<out def>
  | encodingDefinition<out def>
  | assemblyDefinition<out def>
  | memoryDefinition<out def>
  | IF (la.kind == _REGISTER && scanner.Peek().kind == _FILE)
    registerFileDefinition<out def>
  | registerDefinition<out def>
  | aliasDefinition<out def>
  | enumerationDefinition<out def>
  | exceptionDefinition<out def>
  .

  constantDefinition<out ConstantDefinition def> (. TypeLiteral type = null; .)
  = CONSTANT                                     (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out type> ]
    SYM_EQ
    expression<out Expr expr, BIN_OPS>           (. def = new ConstantDefinition(id, type, expr, startLocation.join(loc())); .)
  .

  formatDefinition<out FormatDefinition def>
  = FORMAT                                                       (. var startLoc = loc(); .)
  identifierOrPlaceholder<out IdentifierOrPlaceholder id>        (. var fields = new ArrayList<FormatDefinition.FormatField>();.)
  SYM_COLON typeLiteral<out TypeLiteral type>                    (. var auxFields = new ArrayList<FormatDefinition.AuxiliaryField>();.)
  [
    SYM_EQ SYM_BRACE_OPEN
    formatField<out FormatDefinition.FormatField f1>             (. fields.add(f1); .)
    {
      SYM_COMMA formatField<out FormatDefinition.FormatField f2> (. fields.add(f2); .)
    }
    {
      SYM_COLON
      auxiliaryField<out FormatDefinition.AuxiliaryField aux>    (. auxFields.add(aux); .)
    }
    SYM_BRACE_CLOSE
  ]                                                              (. def = new FormatDefinition(id, type, fields, auxFields, startLoc.join(loc())); .)
  .

  formatField<out FormatDefinition.FormatField field>             (. field = null; .)
  = identifier<out Identifier id>
    ( formatFieldRange<out field, id>
    | formatFieldType<out field, id>
    | formatFieldDerived<out field, id>
    )
  .

  auxiliaryField<out FormatDefinition.AuxiliaryField auxField> (. FormatDefinition.AuxiliaryFieldKind kind = null; .)
  = (
    PREDICATE                                                  (. kind = FormatDefinition.AuxiliaryFieldKind.PREDICATE; .)
  | ENCODE                                                     (. kind = FormatDefinition.AuxiliaryFieldKind.ENCODE; .)
  )
    SYM_BRACE_OPEN                                             (. var auxEntries = new ArrayList<FormatDefinition.AuxiliaryFieldEntry>(); .)
    identifier<out Identifier fieldId>
    SYM_BIGARROW
    expression<out Expr fieldExpr, BIN_OPS>                    (. auxEntries.add(new FormatDefinition.AuxiliaryFieldEntry(fieldId, fieldExpr)); .)
    {
      SYM_COMMA
      identifier<out fieldId>
      SYM_BIGARROW
      expression<out fieldExpr, BIN_OPS>                       (. auxEntries.add(new FormatDefinition.AuxiliaryFieldEntry(fieldId, fieldExpr)); .)
    }
    SYM_BRACE_CLOSE                                            (. auxField = new FormatDefinition.AuxiliaryField(kind, auxEntries); .)
  .

  formatFieldRange<out FormatDefinition.FormatField field, Identifier id>
  = SYM_BRACK_OPEN                      (. List<Expr> ranges = new ArrayList<>();.)
    rangeExpression<out Expr e1>        (. ranges.add(e1); .)
    {
      SYM_COMMA
      rangeExpression<out Expr e2>      (. ranges.add(e2); .)
    }
    SYM_BRACK_CLOSE                     (. field = new FormatDefinition.RangeFormatField(id, ranges); .)
  .

  formatFieldType<out FormatDefinition.FormatField field, Identifier id>
  = SYM_COLON
    typeLiteralOrPlaceholder<out TypeLiteralOrPlaceholder type> (. field = new FormatDefinition.TypedFormatField(id, type); .)
  .

  formatFieldDerived<out FormatDefinition.FormatField field, Identifier id>
  = SYM_EQ
    expression<out Expr expr, BIN_OPS> (. field = new FormatDefinition.DerivedFormatField(id, expr); .)
  .

  counterDefinition<out CounterDefinition def>  (. CounterDefinition.CounterKind kind = null; .)
  = ( PROGRAM                                   (. kind = PROGRAM; .)
    | GROUP                                     (. kind = GROUP; .)
    )                                           (. var startLocation = loc(); .)
    COUNTER
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral type> (. def = new CounterDefinition(kind, id, type, startLocation.join(loc())); .)
  .

  instructionDefinition<out InstructionDefinition def>                      (. var startLocation = loc(); .)
  = INSTRUCTION identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON identifierOrPlaceholder<out IdentifierOrPlaceholder formatId>
    SYM_EQ statement<out Statement behavior>                                (. def = new InstructionDefinition(id, formatId, behavior, startLocation.join(loc())); .)
  .

  pseudoInstructionDefinition<out Definition def>           (. PseudoInstructionDefinition.Kind kind = null; .)
  = ( PSEUDO                                                (. kind = PseudoInstructionDefinition.Kind.PSEUDO; .)
    | KW_COMPILER                                           (. kind = PseudoInstructionDefinition.Kind.COMPILER; .)
    )                                                       (. var start = loc(); .)
    INSTRUCTION
    identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. var params = new ArrayList<PseudoInstructionDefinition.Param>(); .)
    [
      SYM_PAREN_OPEN
      identifier<out Identifier paramName>
      SYM_COLON
      typeLiteral<out TypeLiteral paramType>                (. params.add(new PseudoInstructionDefinition.Param(paramName, paramType)); .)
      {
        SYM_COMMA
        identifier<out paramName>
        SYM_COLON
        typeLiteral<out paramType>                          (. params.add(new PseudoInstructionDefinition.Param(paramName, paramType)); .)
      }
      SYM_PAREN_CLOSE
    ]
    SYM_EQ
    statement<out Statement behavior>                       (. def = new PseudoInstructionDefinition(id, kind, params, behavior, start.join(loc())); .)
  .

  identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. id = null; .)
  = identifier<out id>
  | macroReplacement<out Node node>                       (. id = (IdentifierOrPlaceholder) node; .)
  .

  encodingDefinition<out EncodingDefinition def>
  = ENCODING         (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder instrId>
    SYM_EQ SYM_BRACE_OPEN
    encodingDefinitionList<out EncodingDefinition.FieldEncodings encodings>
    SYM_BRACE_CLOSE  (. def = new EncodingDefinition(instrId, encodings, startLocation.join(loc())); .)
  .

  encodingDefinitionList<out EncodingDefinition.FieldEncodings encs> (. var entries = new ArrayList<FieldEncodingOrPlaceholder>(); .)
  = encodingEntry<out FieldEncodingOrPlaceholder enc>                (. entries.add(enc); .)
    {
      SYM_COMMA
      encodingEntry<out enc>                                         (. entries.add(enc); .)
    }                                                                (. encs = new EncodingDefinition.FieldEncodings(entries); .)
  .

  encodingEntry<out FieldEncodingOrPlaceholder enc> (. enc = null; .)
  = macroReplacement<out Node node>                 (. enc = (FieldEncodingOrPlaceholder) node; .)
  | identifier<out Identifier id>
    SYM_EQ
    expression<out Expr expr, BIN_OPS>              (. enc = new FieldEncoding(id, expr); .)
  .

  assemblyDefinition<out AssemblyDefinition def>                        (. List<IdentifierOrPlaceholder> ids = new ArrayList<>(); var start = loc(); .)
  = ASSEMBLY
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>             (. ids.add(id); .)
    {
      SYM_COMMA
      identifierOrPlaceholder<out IdentifierOrPlaceholder additionalId> (. ids.add(additionalId); .)
    }
    SYM_EQ
    expression<out Expr expr, BIN_OPS>                                  (. def = new AssemblyDefinition(ids, expr, start.join(loc())); .)
  .

  stringLiteral<out StringLiteral lit>
  = string                                               (. lit = new StringLiteral(t.val, loc()); .)
  .

  memoryDefinition<out MemoryDefinition def>
  = MEMORY                                    (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2> (. def = new MemoryDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  registerDefinition<out RegisterDefinition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>         (. def = new RegisterDefinition(id, t1, startLocation.join(t1.location())); .)
  .

  registerFileDefinition<out Definition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    FILE
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2>         (. def = new RegisterFileDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  aliasDefinition<out Definition def>
  = ALIAS                                             (. var startLocation = loc(); AliasDefinition.Kind kind = null;
                                                         TypeLiteral aliasType = null; TypeLiteral targetType = null;
                                                         IdentifierOrPlaceholder id = null;
                                                      .)
    (
      REGISTER                                        (. kind = AliasDefinition.Kind.REGISTER; .)
      [ FILE                                          (. kind = AliasDefinition.Kind.REGISTER_FILE; .) ]
      identifierOrPlaceholder<out id>
      [
        SYM_COLON
        typeLiteral<out aliasType>
        [
          SYM_ARROW
          typeLiteral<out targetType>
        ]
      ]
    | PROGRAM COUNTER                                 (. kind = AliasDefinition.Kind.PROGRAM_COUNTER; .)
      identifierOrPlaceholder<out id>
      [
        SYM_COLON
        typeLiteral<out aliasType>
      ]
    )
    SYM_EQ
    callOrBinaryExpression<out Expr value, false>     (. def = new AliasDefinition(id, kind, aliasType, targetType, value, startLocation.join(loc())); .)
  .

  usingDefinition<out Definition def>
  = USING                             (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_EQ
    typeLiteral<out TypeLiteral type> (. def = new UsingDefinition(id, type, start.join(loc())); .)
  .

  functionDefinition<out Definition def>
  = FUNCTION                           (. var start = loc(); List<Parameter> params = new ArrayList<>(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    [ functionParameters<.out params.> ]
    SYM_ARROW
    typeLiteral<out TypeLiteral retType>
    SYM_EQ
    expression<out Expr expr, BIN_OPS> (. def = new FunctionDefinition(name, params, retType, expr, start.join(loc())); .)
  .

  functionParameters<.out List<Parameter> params.>
  = SYM_PAREN_OPEN                  (. params = new ArrayList<>(); .)
    parameter<out Parameter param>  (. params.add(param); .)
    {
      SYM_COMMA
      parameter<out Parameter next> (. params.add(next); .)
    }
    SYM_PAREN_CLOSE
  .

  parameter<out Parameter param>
  = identifier<out Identifier name>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. param = new Parameter(name, type); .)
  .

  enumerationDefinition<out Definition def> (. TypeLiteral enumType = null; .)
  = ENUMERATION                             (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out enumType> ]
    SYM_EQ                                  (. var entries = new ArrayList<EnumerationDefinition.Entry>(); .)
    SYM_BRACE_OPEN                          (. Expr value = null; Expr behavior = null; .)
    identifier<out Identifier name>
    [
      SYM_EQ
      valLiteral<out value>
    ]
    [
      SYM_BIGARROW
      callOrBinaryExpression<out behavior, false>
    ]                                       (. entries.add(new EnumerationDefinition.Entry(name, value, behavior)); .)
    {
      SYM_COMMA
      identifier<out name>
      [
        SYM_EQ
        valLiteral<out value>
      ]
      [
        SYM_BIGARROW
        callOrBinaryExpression<out behavior, false>
      ]                                     (. entries.add(new EnumerationDefinition.Entry(name, value, behavior)); .)
    }
    SYM_BRACE_CLOSE                         (. def = new EnumerationDefinition(id, enumType, entries, start.join(loc())); .)
  .

  exceptionDefinition<out Definition def>
  = EXCEPTION                          (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_EQ
    statement<out Statement statement> (. def = new ExceptionDefinition(id, statement, start.join(loc())); .)
  .

  recordDefinition
  = RECORD
    identifier<out Identifier recordName>
    SYM_PAREN_OPEN
    identifier<out Identifier paramName>
    SYM_COLON                       (. var entries = new ArrayList<RecordType.Entry>(); .)
    syntaxType<out SyntaxType type> (. entries.add(new RecordType.Entry(paramName.name, type)); .)
    {
      SYM_COMMA
      identifier<out paramName>
      SYM_COLON
      syntaxType<out type>          (. entries.add(new RecordType.Entry(paramName.name, type)); .)
    }
    SYM_PAREN_CLOSE                 (. symbolTable.addRecord(recordName, new RecordType(recordName.name, entries)); .)
  .

  modelTypeDef
  = MODEL_TYPE
    identifier<out Identifier name>
    SYM_EQ
    projectionType<out ProjectionType type> (. symbolTable.addModelType(name, type); .)
  .

  // -- STATEMENTS ---------------------------------------------------------------------------------------------------

  statement<out Statement statement> (. statement = null; .)
  = letStatement<out statement>
  | ifStatement<out statement>
  | blockStatement<out statement>
  | raiseStatement<out statement>
  | IF (la.kind == _MATCH && scanner.Peek().kind != _SYM_COLON)
    matchStatement<out statement>
  | IF (isMacroReplacementOfType(this, BasicSyntaxType.STAT))
    macroReplacement<out Node n>     (. statement = (Statement) n; .)
  | assignmentOrCallStmt<out statement>
  .

  blockStatement<out BlockStatement block>     (. var start = loc(); .)
  = SYM_BRACE_OPEN
    statementList<.out List<Statement> stmts.>
    SYM_BRACE_CLOSE                            (. block = new BlockStatement(stmts, start.join(loc())); .)
  .

  statementList<.out List<Statement> stmts.> (. stmts = new ArrayList<>(); .)
  = {
      IF (isMacroReplacementOfType(this, BasicSyntaxType.STATS))
      macroReplacement<out Node n>           (. stmts.add((Statement) n); .)
    | statement<out Statement statement>     (. stmts.add(statement); .)
    }
  .

  assignmentOrCallStmt<out Statement statement> (. statement = null; .)
  = callOrBinaryExpression<out Expr target, false>
    [
      SYM_ASSIGN
      expression<out Expr expr, BIN_OPS>        (. statement = new AssignmentStatement(target, expr); .)
    ]                                           (. if (statement == null) statement = new CallStatement(target); .)
  .

  letStatement<out Statement letStatement>
  = LET                                 (. var start = loc(); var identifiers = new ArrayList<Identifier>(); .)
    identifier<out Identifier id>       (. identifiers.add(id); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); .)
    }
    SYM_EQ                              (. Expr valueExpr = null; .)
    ( IF (la.kind == _KW_IF)
      ifExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | expression<out valueExpr, BIN_OPS_EXCEPT_IN>
    )
    SYM_IN
    statement<out Statement body>       (. letStatement = new LetStatement(identifiers, valueExpr, body, start.join(loc())); .)
  .

  ifStatement<out Statement ifStatement> (. Statement elseStmt = null; var start = loc(); .)
  = KW_IF expression<out Expr condition, BIN_OPS>
    THEN statement<out Statement thenStmt>
    [ IF (la.kind == _ELSE)
      ELSE statement<out elseStmt>
    ]                                    (. ifStatement = new IfStatement(condition, thenStmt, elseStmt, start.join(loc())); .)
  .

  raiseStatement<out Statement raise>
  = RAISE                              (. var start = loc(); .)
    statement<out Statement statement> (. raise = new RaiseStatement(statement, start.join(loc())); .)
  .

  matchStatement<out Statement match>
  = MATCH                                     (. var start = loc(); .)
    expression<out Expr candidate, BIN_OPS>
    WITH
    SYM_BRACE_OPEN                            (. var cases = new ArrayList<MatchStatement.Case>();  .)
    {                                         (. var patterns = new ArrayList<Expr>(); .)
      ( expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
      | SYM_BRACE_OPEN
        expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        }
        SYM_BRACE_CLOSE
      )
      SYM_BIGARROW
      statement<out Statement result>         (. cases.add(new MatchStatement.Case(patterns, result)); .)
      SYM_COMMA
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    statement<out Statement defaultResult>
    SYM_BRACE_CLOSE                           (. match = new MatchStatement(candidate, cases, defaultResult, start.join(loc())); .)
  .

  // -- EXPRESSIONS --------------------------------------------------------------------------------------------------

  expression<out Expr expr, boolean[] allowedOps>
  = term<out expr>
    {
      IF (allowedOps[la.kind] || la.kind == _SYM_AS || (la.kind == _SYM_DOLLAR && isMacroReplacementOfType(this, BasicSyntaxType.BIN_OP)))
      (
        binaryOperator<out Operator op>                     (. var operator = new OperatorExpr(op, loc()); .)
        term<out Expr right>                                (. expr = new BinaryExpr(expr, operator, right); .)
      | macroReplacement<out Node node>
        term<out Expr right>                                (. expr = new BinaryExpr(expr, (OperatorOrPlaceholder) node, right); .)
      | SYM_AS
        symbolOrBinaryExpression<out Expr symOrBin, true> (. expr = reorderCastExpr(expr, symOrBin); .)
      )
    }                                                       (. expr = reorderBinary(this, expr); .)
  .

  /// Call expressions of form "a::b<3>().c()".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  callOrBinaryExpression<out Expr expr, boolean allowLtOp> (. expr = null; .)
  = IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.SYM_EX))
    symbolOrBinaryExpression<out expr, allowLtOp>          (. List<List<Expr>> argsIndices = new ArrayList<>(); List<CallExpr.NamedArgument> namedArguments = new ArrayList<>(); .)
    [
      IF (la.kind == _SYM_BRACE_OPEN && expr instanceof IsSymExpr)
      SYM_BRACE_OPEN
      identifier<out Identifier argName>
      SYM_EQ
      expression<out Expr argExpr, BIN_OPS>              (. namedArguments.add(new CallExpr.NamedArgument(argName, argExpr)); .)
      {
        SYM_COMMA
        identifier<out argName>
        SYM_EQ
        expression<out argExpr, BIN_OPS>                 (. namedArguments.add(new CallExpr.NamedArgument(argName, argExpr)); .)
      }
      SYM_BRACE_CLOSE
    ]
    {
      // Check if we received a symbol expression -> collect arguments
      // Otherwise, just return the collected binary expression
      IF (la.kind == _SYM_PAREN_OPEN && expr instanceof IsSymExpr)
      arguments<.out List<Expr> args.>                     (. argsIndices.add(args); .)
    }                                                      (. List<CallExpr.SubCall> subCalls = new ArrayList<>(); .)
    {
      IF (la.kind == _SYM_DOT && expr instanceof IsSymExpr)
      SYM_DOT                                              (. var subCallArgsIndices = new ArrayList<List<Expr>>(); .)
      identifier<out Identifier id>
      {
        IF (la.kind == _SYM_PAREN_OPEN)
        arguments<.out List<Expr> args.>                   (. subCallArgsIndices.add(args); .)
      }                                                    (. subCalls.add(new CallExpr.SubCall(id, subCallArgsIndices)); .)
    }                                                      (. if (expr instanceof IsSymExpr symExpr && (!namedArguments.isEmpty() || !argsIndices.isEmpty() || !subCalls.isEmpty()))
                                                                expr = new CallExpr(symExpr, namedArguments, argsIndices, subCalls, expr.location().join(loc()));
                                                           .)
  | macroReplacement<out Node node>                        (. expr = (Expr) node; .)
  .

  /// Represents one set of invocation arguments.
  /// Multiple invocations (e.g. multi-dimensional access) will need multiple #arguments
  arguments<.out List<Expr> args.>
  = SYM_PAREN_OPEN                            (. args = new ArrayList<>(); .)
    expression<out Expr arg, BIN_OPS>         (. args.add(arg); .)
    ( SYM_RANGE
      expression<out Expr rangeTo, BIN_OPS>   (. args.set(0, new RangeExpr(arg, rangeTo)); .)
    | {
      SYM_COMMA
      expression<out Expr nextArg, BIN_OPS>   (. args.add(nextArg); .)
    })
    SYM_PAREN_CLOSE
  .

  /// Symbol expressions of form "a::b<3>".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  symbolOrBinaryExpression<out Expr expr, boolean allowLtOp> (. expr = null; .)
  = IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.ID))
    identifierPath<out IsId path>
    [
      IF (la.kind == _SYM_LT)
      SYM_LT                                                 (. var lessLoc = loc(); .)
      term<out Expr term>
      [
        IF (!allowLtOp || la.kind == _SYM_GT)
        SYM_GT                                               (. expr = new SymbolExpr(path, term, path.location().join(loc())); .)
      ]                                                      (. if (expr == null) expr = new BinaryExpr((Expr) path, new OperatorExpr(Operator.Less(), lessLoc), term); .)
    ]                                                        (. if (expr == null) expr = (Expr) path; .)
  | macroReplacement<out Node node>                          (. expr = (Expr) node; .)
  .

  binaryOperator<out Operator op>    (.op = null;.)
  = SYM_LOGOR  (. op = Operator.LogicalOr(); .)
  | SYM_LOGAND (. op = Operator.LogicalAnd(); .)
  | SYM_BINOR  (. op = Operator.Or(); .)
  | SYM_CARET  (. op = Operator.Xor(); .)
  | SYM_BINAND (. op = Operator.And(); .)
  | SYM_EQ     (. op = Operator.Equal(); .)
  | SYM_NEQ    (. op = Operator.NotEqual(); .)
  | SYM_GTE    (. op = Operator.GreaterEqual(); .)
  | SYM_GT     (. op = Operator.Greater(); .)
  | SYM_LTE    (. op = Operator.LessEqual(); .)
  | SYM_LT     (. op = Operator.Less(); .)
  | SYM_ROTR   (. op = Operator.RotateRight(); .)
  | SYM_ROTL   (. op = Operator.RotateLeft(); .)
  | SYM_SHR    (. op = Operator.ShiftRight(); .)
  | SYM_SHL    (. op = Operator.ShiftLeft(); .)
  | SYM_PLUS   (. op = Operator.Add(); .)
  | SYM_MINUS  (. op = Operator.Subtract(); .)
  | SYM_MUL    (. op = Operator.Multiply(); .)
  | SYM_DIV    (. op = Operator.Divide(); .)
  | SYM_MOD    (. op = Operator.Modulo(); .)
  | SYM_IN     (. op = Operator.In(); .)
  | SYM_NIN    (. op = Operator.NotIn(); .)
  // When adding a new operator here, it must also be added to the "BIN_OPS" list in ParserUtils.java!
  .

  unary<out Expr expr>
  = unaryOperator<out UnaryOperator op>
    term<out Expr operand> (. if (operand instanceof BinaryExpr binExpr) {
                                expr = new BinaryExpr(new UnaryExpr(op, binExpr.left), binExpr.operator, binExpr.right);
                              } else {
                                expr = new UnaryExpr(op, operand);
                              }
                           .)
  .

  unaryOperator<out UnaryOperator op> (. op = null; .)
  = SYM_MINUS (. op = UnaryOperator.NEGATIVE; .)
  | SYM_EXCL  (. op = UnaryOperator.LOG_NOT; .)
  | SYM_TILDE (. op = UnaryOperator.COMPLEMENT; .)
  .

  term<out Expr expr>            (. expr = null; .)
  = literal<out expr>
  | IF (la.kind == _MATCH && scanner.Peek().kind != _SYM_COLON) // Disambiguate from macro match
    matchExpression<out expr>
  | IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.CALL_EX))
    callOrBinaryExpression<out expr, true>
  | groupedExpression<out expr>
  | unary<out expr>
  | ifExpression<out expr, BIN_OPS>
  | letExpression<out expr>
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.EX))
    macroReplacement<out Node n> (. expr = (Expr) n; .)
  .

  groupedExpression<out GroupedExpr expr> (. expr = new GroupedExpr(new ArrayList<>(), loc()); .)
  = SYM_PAREN_OPEN
    expression<out Expr inner, BIN_OPS>   (. expr.expressions.add(inner); .)
    {
      SYM_COMMA
      expression<out Expr next, BIN_OPS>  (. expr.expressions.add(next); .)
    }
    SYM_PAREN_CLOSE                       (. expr.loc = expr.loc.join(loc()); .)
  .

  literal<out Expr expr> (. expr = null; .)
  = valLiteral<out expr>
  | stringLiteral<out expr>
  .

  valLiteral<out Expr expr> (. expr = null; .)
  = boolLiteral<out expr>
  | intLiteral<out expr>
  | binLiteral<out expr>
  .

  intLiteral<out Expr expr>
  = decLit (. expr = new IntegerLiteral(t.val, loc()); .)
  .

  binLiteral<out Expr expr>
  = (hexLit | binLit) (. expr = new BinaryLiteral(t.val, loc()); .)
  .

  boolLiteral<out Expr expr> (. expr = null; .)
  = TRUE                     (. expr = new BoolLiteral(true, loc()); .)
  | FALSE                    (. expr = new BoolLiteral(false, loc()); .)
  .

  identifierPath<out IsId path>                                 (. List<IdentifierOrPlaceholder> segments = new ArrayList<>(); .)
  = identifierOrPlaceholder<out IdentifierOrPlaceholder id>     (. segments.add(id); .)
    {
      SYM_NAMESPACE
      identifierOrPlaceholder<out IdentifierOrPlaceholder next> (. segments.add(next); .)
    }                                                           (. if (segments.size() == 1) path = id;
                                                                   else path = new IdentifierPath(segments); .)
  .

  rangeExpression<out Expr expr>
  = expression<out expr, BIN_OPS>
    [ SYM_RANGE expression<out Expr to, BIN_OPS> (. expr = new RangeExpr(expr, to); .) ]
  .

  letExpression<out Expr expr>
  = LET                                 (. var start = loc(); var identifiers = new ArrayList<Identifier>(); .)
    identifier<out Identifier id>       (. identifiers.add(id); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); .)
    }
    SYM_EQ                              (. Expr valueExpr = null; .)
    ( IF (la.kind == _KW_IF)
      ifExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | expression<out valueExpr, BIN_OPS_EXCEPT_IN>
    )
    SYM_IN
    expression<out Expr body, BIN_OPS>  (. expr = new LetExpr(identifiers, valueExpr, body, start.join(loc())); .)
  .

  ifExpression<out Expr expr, boolean[] allowedElseOps>
  = KW_IF                                              (. var startLoc = loc(); .)
    expression<out Expr condition, BIN_OPS>
    THEN expression<out Expr thenExpr, BIN_OPS>
    ELSE expression<out Expr elseExpr, allowedElseOps> (. expr = new IfExpr(condition, thenExpr, elseExpr, startLoc.join(loc())); .)
  .

  matchExpression<out Expr expr>
  = MATCH                                     (. var start = loc(); .)
    expression<out Expr candidate, BIN_OPS>
    WITH
    SYM_BRACE_OPEN                            (. var cases = new ArrayList<MatchExpr.Case>();  .)
    {                                         (. var patterns = new ArrayList<Expr>(); .)
      ( expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
      | SYM_BRACE_OPEN
        expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        }
        SYM_BRACE_CLOSE
      )
      SYM_BIGARROW
      expression<out Expr result, BIN_OPS>    (. cases.add(new MatchExpr.Case(patterns, result)); .)
      SYM_COMMA
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    expression<out Expr defaultResult, BIN_OPS>
    SYM_BRACE_CLOSE                           (. expr = new MatchExpr(candidate, cases, defaultResult, start.join(loc())); .)
  .

  // -- PRIMITIVES ---------------------------------------------------------------------------------------------------

  typeLiteralOrPlaceholder<out TypeLiteralOrPlaceholder type> (. type = null; .)
  = IF (isMacroReplacementOfType(this, BasicSyntaxType.ID))
    macroReplacement<out Node n>                              (. if (n instanceof PlaceholderExpr p) type = p;
                                                                 else type = new TypeLiteral((IsId) n, List.of(), n.location()); .)
  | typeLiteral<out type>
  .

  typeLiteral<out TypeLiteral type>
  = identifierPath<out IsId path>                        (. List<List<Expr>> sizeIndices = new ArrayList<>(); .)
    {
      SYM_LT                                             (. List<Expr> sizes = new ArrayList<>(); .)
      expression<out Expr sizeExpr, BIN_OPS_EXCEPT_GT>   (. sizes.add(sizeExpr); .)
      {
        SYM_COMMA
        expression<out Expr nextSize, BIN_OPS_EXCEPT_GT> (. sizes.add(nextSize); .)
      }
      SYM_GT                                             (. sizeIndices.add(sizes); .)
    }                                                    (. type = new TypeLiteral(path, sizeIndices, path.location().join(loc())); .)
  .

  identifier<out Identifier identifier>
  = (identifierToken | allowedIdentifierKeywords) (. identifier = new Identifier(t.val, loc()); .)
  .

  /// Must be kept in sync with the ParserUtils.isIdentifierToken function.
  allowedIdentifierKeywords
  = T_BOOL
  | REGISTER
  | EXCEPTION
  // TODO Add all allowed keywords
  .

  // -- MACROS -------------------------------------------------------------------------------------------------------

  macroReplacement<out Node body> (. body = null; .)
  = macroMatch<out body>
  | maximumMacroExpr<out body>
  | extendId<out body>
  | idToStr<out body>
  .

  extendId<out Node body>
  = EXTEND_ID                               (. var start = loc(); .)
    groupedExpression<out GroupedExpr expr> (. body = new ExtendIdExpr(expr, start.join(loc())); .)
  .

  idToStr<out Node body>
  = ID_TO_STR       (. var start = loc(); .)
    SYM_PAREN_OPEN
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_PAREN_CLOSE (. body = new IdToStrExpr(id, start.join(loc())); .)
  .

  macroMatch<out Node node>
  = MATCH                                (. var start = loc(); .)
    SYM_COLON
    basicSyntaxType<out SyntaxType type>
    SYM_PAREN_OPEN                       (. var choices = new ArrayList<MacroMatch.Choice>(); .)
    macroReplacement<out Node candidate>
    (SYM_EQ | SYM_NEQ )                  (. var comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
    macroBody<out Node match, candidate.syntaxType()>
    SYM_BIGARROW
    macroBody<out Node result, type>     (. choices.add(new MacroMatch.Choice(candidate, comparison, match, result)); .)
    SYM_SEMICOLON
    {
      macroReplacement<out candidate>
      (SYM_EQ | SYM_NEQ )                (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
      macroBody<out match, candidate.syntaxType()>
      SYM_BIGARROW
      macroBody<out result, type>        (. choices.add(new MacroMatch.Choice(candidate, comparison, match, result)); .)
      SYM_SEMICOLON
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    macroBody<out Node defaultChoice, type>
    SYM_PAREN_CLOSE                      (. node = createMacroMatch(type, choices, defaultChoice, start.join(loc())); .)
  .

  /// Parses the longest macro expression (either instance or placeholder) from the parser.
  maximumMacroExpr<out Node node>                 (. node = null; .)
  = SYM_DOLLAR                                    (. var segments = new ArrayList<String>(); .)
    identifier<out Identifier id>                 (. var macro = symbolTable.getMacro(id.name);
                                                     var paramType = paramSyntaxType(this, id.name);
                                                     segments.add(id.name); .)
    { IF (macro == null && la.kind == _SYM_DOT && paramType instanceof RecordType record)
      SYM_DOT
      identifier<out Identifier next>             (. paramType = record.findEntry(next.name); segments.add(next.name); .)
    }
    [
      IF (la.kind == _SYM_PAREN_OPEN && (macro != null || paramType instanceof ProjectionType))
      SYM_PAREN_OPEN                              (. var macroOrPlaceholder = macroOrPlaceholder(macro, paramType, segments);
                                                     var params = instanceParamTypes(macroOrPlaceholder);
                                                     var args = new ArrayList<Node>(); .)
      (
        IF (!params.hasNext())
        SYM_PAREN_CLOSE
      | macroBody<out Node arg1, params.next()>   (. args.add(arg1); .)
        {
          SYM_SEMICOLON
          macroBody<out Node arg2, params.next()> (. args.add(arg2); .)
        }
        SYM_PAREN_CLOSE
      )                                           (. node = createMacroInstance(macroOrPlaceholder, args, loc()); .)
    ]                                             (. node = Objects.requireNonNullElse(node, createPlaceholder(paramType, segments, loc())); .)
  .

  macroDef
  = MODEL                                   (. var startLoc = loc(); .)
    identifier<out Identifier id>
    SYM_PAREN_OPEN                          (. var params = new ArrayList<MacroParam>(); .)
    [
      identifier<out Identifier paramId1>
      SYM_COLON
      syntaxType<out SyntaxType synType1>   (. params.add(new MacroParam(paramId1, synType1)); .)
      {
        SYM_COMMA
        identifier<out Identifier paramId2>
        SYM_COLON
        syntaxType<out SyntaxType synType2> (. params.add(new MacroParam(paramId2, synType2)); .)
      }
    ]
    SYM_PAREN_CLOSE                         (. macroContext.addFirst(params); .)
    SYM_COLON basicSyntaxType<out SyntaxType returnType> SYM_EQ
    SYM_BRACE_OPEN                          (. insideMacro = true; .)
    macroBody<out Node body, returnType>
    SYM_BRACE_CLOSE                         (.
                                              macroContext.removeFirst();
                                              insideMacro = false;
                                              var bodyType = body.syntaxType();
                                              if (!bodyType.isSubTypeOf(returnType)) {
                                                errors.SemErr(t.line, t.col, "The macro signature promises to return `%s` but it's body is of type `%s`.".formatted(returnType, bodyType));
                                                symbolTable.addMacro(new Macro(id, params, body, BasicSyntaxType.INVALID), startLoc.join(loc()));
                                              } else {
                                                symbolTable.addMacro(new Macro(id, params, body, returnType), startLoc.join(loc()));
                                              }
                                            .)
  .

  macroBody<out Node body, SyntaxType type>                 (. body = null; var start = lookaheadLoc(); .)
  = IF (type == BasicSyntaxType.STATS)
    statementList<.out List<Statement> stmts.>              (. body = new StatementList(stmts, start.join(loc())); .)
  | IF (type == BasicSyntaxType.STAT)
    statement<out body>
  | IF (type == BasicSyntaxType.ENCS)
    encodingDefinitionList<out body>
  | IF (type == BasicSyntaxType.ISA_DEFS)
    isaDefinitionList<.out List<Definition> defs.>          (. body = new DefinitionList(defs, start.join(loc())); .)
  | IF (type == BasicSyntaxType.EX)
    expression<out body, BIN_OPS>
  | IF (type == BasicSyntaxType.LIT)
    literal<out body>
  | // IF (type == BasicSyntaxType.STR)
    stringLiteral<out body>
  | IF (type == BasicSyntaxType.VAL)
    valLiteral<out body>
  | // IF (type == BasicSyntaxType.BOOL)
    boolLiteral<out body>
  | // IF (type == BasicSyntaxType.INT)
    intLiteral<out body>
  | // IF (type == BasicSyntaxType.BIN)
    binLiteral<out body>
  | IF (type == BasicSyntaxType.CALL_EX)
    callOrBinaryExpression<out body, false>
  | IF (type == BasicSyntaxType.SYM_EX)
    symbolOrBinaryExpression<out body, false>
  | IF (type == BasicSyntaxType.ID)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. body = (Node) id; .)
  | // IF (type == BasicSyntaxType.BIN_OP)
    binaryOperator<out Operator op>                         (. body = new OperatorExpr(op, loc()); .)
  | // IF (type instanceof RecordType record)
    SYM_PAREN_OPEN                                          (. var recordType = (RecordType) type;
                                                               var entries = new ArrayList<Node>();
                                                               var nextEntry = recordType.entries.iterator(); .)
    macroBody<out Node entry, nextEntry.next().type()>      (. entries.add(entry); .)
    {
      SYM_SEMICOLON
      macroBody<out entry, nextEntry.next().type()>         (. entries.add(entry); .)
    }
    SYM_PAREN_CLOSE                                         (. body = new Tuple(recordType, entries, start.join(loc())); .)
  | identifier<out Identifier id>                           (. body = new MacroReference(symbolTable.getMacro(id.name), (ProjectionType) type, id.location()); .)
  | macroReplacement<out body>
  .

  syntaxType<out SyntaxType type> (. type = null; .)
  = IF (la.kind == _identifierToken)
    identifier<out Identifier id> (. type = symbolTable.findType(id); .)
  | projectionType<out type>
  | basicSyntaxType<out type>
  .

  projectionType<out ProjectionType type>     (. var arguments = new ArrayList<SyntaxType>(); .)
  = SYM_PAREN_OPEN
    [
      syntaxType<out SyntaxType argType>      (. arguments.add(argType); .)
      { SYM_COMMA syntaxType<out argType>     (. arguments.add(argType); .) }
    ]
    SYM_PAREN_CLOSE
    SYM_ARROW
    syntaxType<out SyntaxType resultType>     (. type = new ProjectionType(arguments, resultType); .)
  .

  basicSyntaxType<out BasicSyntaxType type> (. type = null; .)
  = T_STATS                                 (. type = BasicSyntaxType.STATS; .)
  | T_STAT                                  (. type = BasicSyntaxType.STAT; .)
  | T_ENCS                                  (. type = BasicSyntaxType.ENCS; .)
  | T_ISA_DEFS                              (. type = BasicSyntaxType.ISA_DEFS; .)
  | T_EX                                    (. type = BasicSyntaxType.EX; .)
  | T_LIT                                   (. type = BasicSyntaxType.LIT; .)
  | T_STR                                   (. type = BasicSyntaxType.STR; .)
  | T_VAL                                   (. type = BasicSyntaxType.VAL; .)
  | T_BOOL                                  (. type = BasicSyntaxType.BOOL; .)
  | T_INT                                   (. type = BasicSyntaxType.INT; .)
  | T_BIN                                   (. type = BasicSyntaxType.BIN; .)
  | T_CALL_EX                               (. type = BasicSyntaxType.CALL_EX; .)
  | T_SYM_EX                                (. type = BasicSyntaxType.SYM_EX; .)
  | T_ID                                    (. type = BasicSyntaxType.ID; .)
  | T_BIN_OP                                (. type = BasicSyntaxType.BIN_OP; .)
  | T_UN_OP                                 (. type = BasicSyntaxType.UN_OP; .)
  .

END vadl.
