$package=vadl.ast
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import vadl.ast.EncodingDefinition.FieldEncoding;
import vadl.ast.FunctionDefinition.Parameter;
import vadl.utils.SourceLocation;

import static vadl.ast.CounterDefinition.CounterKind.GROUP;
import static vadl.ast.CounterDefinition.CounterKind.PROGRAM;
import static vadl.ast.ParserUtils.*;

COMPILER vadl
  java.net.URI sourceFile = SourceLocation.INVALID_SOURCE_LOCATION.uri();
  boolean insideMacro = false;
  boolean disableSymbolChecking = false;
  Deque<Boolean> disableSymbolStack = new ArrayDeque<>();
  Ast ast = new Ast();
  SymbolTable symbolTable = new SymbolTable();
  Map<String, Identifier> macroOverrides = new HashMap<>();

  { symbolTable.loadBuiltins(); }

  SourceLocation loc() {
    return locationFromToken(this, t);
  }

  SourceLocation lookaheadLoc() {
    return locationFromToken(this, la);
  }

  boolean isMacroParamType(SyntaxType syntaxType) {
    // TODO Analyze next few tokens to determine syntax type of parameter
    var name = scanner.Peek().val;
    return name.equals("targetReg") || name.equals("memEx");
  }

  void disableSymbolChecking() {
    disableSymbolStack.addFirst(disableSymbolChecking);
    disableSymbolChecking = true;
  }

  void enableSymbolChecking() {
    disableSymbolChecking = disableSymbolStack.removeFirst();
  }

CHARACTERS
  digit = '0' .. '9'.
  binDigit = '0' .. '1'.
  hexDigit = '0' .. '9' + 'A' .. 'F' + 'a' .. 'f'.
  letter = 'a' .. 'z' + 'A' .. 'Z'.
  validDQStringCharacters = ANY - '"' - "\\".
  validSQStringCharacters = ANY - "'" - "\\".

TOKENS
  hexLit = "0x" hexDigit {hexDigit | "'"}.
  binLit = "0b" binDigit {binDigit | "'"}.
  decLit = digit {digit | "'"}.

  identifierToken = letter {letter | digit | "_"}.
  string =
  ( '"' { "\\" (letter | '"' | "'" | "\\") | validDQStringCharacters } '"') |
  ( "'" { "\\" (letter | '"' | "'" | "\\") | validSQStringCharacters } "'").

  T_STATS = "Stats".
  T_STAT = "Stat".
  T_ENCS = "Encs".
  T_ISA_DEFS = "IsaDefs".
  T_EX = "Ex".
  T_LIT = "Lit".
  T_STR = "Str".
  T_VAL = "Val".
  T_BOOL = "Bool".
  T_INT = "Int".
  T_BIN = "Bin".
  T_CALL_EX = "CallEx".
  T_SYM_EX = "SymEx".
  T_ID = "Id".
  T_BIN_OP = "BinOp".
  T_UN_OP = "UnOp".

  INSTRUCTION = "instruction".
  SET = "set".
  ARCHITECTURE = "architecture".
  CONSTANT = "constant".
  FORMAT = "format".
  PROGRAM = "program".
  GROUP = "group".
  COUNTER = "counter".
  ENCODING = "encoding".
  ASSEMBLY = "assembly".
  MEMORY = "memory".
  REGISTER = "register".
  MODEL = "model".
  FILE = "file".
  LET = "let".
  KW_IF = "if".
  THEN = "then".
  ELSE = "else".
  USING = "using".
  FUNCTION = "function".
  TRUE = "true".
  FALSE = "false".

  SYM_IN = "in".
  SYM_AS = "as".
  SYM_EQ = "=".
  SYM_GT = ">".
  SYM_LT = "<".
  SYM_NIN = "!in".
  SYM_NEQ = "!=".
  SYM_GTE = ">=".
  SYM_LTE = "<=".
  SYM_MUL = "*".
  SYM_DIV = "/".
  SYM_MOD = "%".
  SYM_DOT = ".".
  SYM_SHR = ">>".
  SYM_SHL = "<<".
  SYM_ROTR = "<>>".
  SYM_ROTL = "<<>".
  SYM_EXCL = "!".
  SYM_PLUS = "+".
  SYM_MINUS = "-".
  SYM_TILDE = "~".
  SYM_COLON = ":".
  SYM_COMMA = ",".
  SYM_CARET = "^".
  SYM_BINOR = "|".
  SYM_LOGOR = "||".
  SYM_ARROW = "->".
  SYM_RANGE = "..".
  SYM_BINAND = "&".
  SYM_LOGAND = "&&".
  SYM_ASSIGN = ":=".
  SYM_DOLLAR = "$".
  SYM_SEMICOLON = ";".
  SYM_NAMESPACE = "::".
  SYM_PAREN_OPEN = "(".
  SYM_BRACK_OPEN = "[".
  SYM_BRACE_OPEN = "{".
  SYM_PAREN_CLOSE = ")".
  SYM_BRACK_CLOSE = "]".
  SYM_BRACE_CLOSE = "}".

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
  vadl =
  {
    topLevelDefinitions<out Definition d>   (. ast.definitions.add(d); .)
    | macroDef
  }.

  // -- DEFINITIONS --------------------------------------------------------------------------------------------------
  topLevelDefinitions<out Definition def> (. def = null; .)
  = instructionsetDefinition<out def>
  | commonDefinition<out def>             (. def.accept(symbolTable); .)
  .

  commonDefinition<out Definition def>    (. def = null; .)
  = constantDefinition<out def>
  | formatDefinition<out def>
  | usingDefinition<out def>
  | functionDefinition<out def>
  .

  instructionsetDefinition<out InstructionSetDefinition isaDef> (. pushScope(this); .)
  = INSTRUCTION                                                 (. var startLocation = loc(); .)
    SET ARCHITECTURE identifier<out Identifier identifier>
    SYM_EQ SYM_BRACE_OPEN
    isaDefinitionList<.out List<Definition> definitions.>
    SYM_BRACE_CLOSE                                             (. isaDef = new InstructionSetDefinition(identifier, definitions, startLocation.join(loc()));
                                                                   popScope(this);
                                                                   isaDef.accept(symbolTable);
                                                                .)
  .

  isaDefinitionList<. out List<Definition> definitions .>             (. definitions = new ArrayList<>(); .)
  = {(
    annotations<.out List<Annotation> annotations.>
    isaDefinition<out Definition def>                                 (. def.annotations.annotations().addAll(annotations); definitions.add(def); if (!disableSymbolChecking) def.accept(symbolTable); .)
  | macroDef
  | macroInstanceOrPlaceholder<out Node n, BasicSyntaxType.IsaDefs()> (. if (n instanceof DefinitionList defs) definitions.addAll(defs.items);
                                                                         else definitions.add((Definition) n); .)
  )}
  .

  annotations<.out List<Annotation> annotations.> (. annotations = new ArrayList<>(); disableSymbolChecking(); .)
  = {
    annotation<out Annotation annotation>         (. annotations.add(annotation); .)
  }                                               (. enableSymbolChecking(); .)
  .

  annotation<out Annotation annotation> (. TypeLiteral type = null; Identifier property = null; .)
  = SYM_BRACK_OPEN
    expression<out Expr expr, BIN_OPS>
    [ (SYM_COLON typeLiteral<out type>)
    | identifier<out property>
    ]
    SYM_BRACK_CLOSE                     (. annotation = new Annotation(expr, type, property); .)
  .

  isaDefinition<out Definition def> (. def = null; .)
  = commonDefinition<out def>
  | counterDefinition<out def>
  | instructionDefinition<out def>
  | encodingDefinition<out def>
  | assemblyDefinition<out def>
  | memoryDefinition<out def>
  | IF (la.kind == _REGISTER && scanner.Peek().kind == _FILE)
    registerFileDefinition<out def>
  | registerDefinition<out def>
  .

  constantDefinition<out ConstantDefinition def> (. TypeLiteral type = null; .)
  = CONSTANT                                     (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out type> ]
    SYM_EQ
    expression<out Expr expr, BIN_OPS>           (. def = new ConstantDefinition(id, type, expr, startLocation.join(loc())); .)
  .

  formatDefinition<out FormatDefinition def>                      (. List<FormatDefinition.FormatField> fields = new ArrayList<>();.)
  = FORMAT                                                        (. var startLoc = loc(); .)
  identifierOrPlaceholder<out IdentifierOrPlaceholder id>
  SYM_COLON typeLiteral<out TypeLiteral type>
  [SYM_EQ SYM_BRACE_OPEN                                          (. pushFormatScope(this, id); .)
      formatField<out FormatDefinition.FormatField f1>            (. fields.add(f1); popScope(this); .)
      {                                                           (. pushFormatScope(this, id); .)
      SYM_COMMA formatField<out FormatDefinition.FormatField f2>  (. fields.add(f2); popScope(this); .)
      }
  SYM_BRACE_CLOSE]                                                (. def = new FormatDefinition(id, type, fields, startLoc.join(loc())); .)
  .

  // TODO Auxiliary fields ": predicate" and ": encode" are missing
  formatField<out FormatDefinition.FormatField field>             (. field = null; .)
  = identifier<out Identifier id>
    ( formatFieldRange<out field, id>
    | formatFieldType<out field, id>
    | formatFieldDerived<out field, id>
    )
  .

  formatFieldRange<out FormatDefinition.FormatField field, Identifier id>
  = SYM_BRACK_OPEN                      (. List<Expr> ranges = new ArrayList<>();.)
    rangeExpression<out Expr e1>        (. ranges.add(e1); .)
    {
      SYM_COMMA
      rangeExpression<out Expr e2>      (. ranges.add(e2); .)
    }
    SYM_BRACK_CLOSE                     (. field = new FormatDefinition.RangeFormatField(id, ranges); .)
  .

  formatFieldType<out FormatDefinition.FormatField field, Identifier id>
  = SYM_COLON
    typeLiteralOrPlaceholder<out TypeLiteralOrPlaceholder type> (. field = new FormatDefinition.TypedFormatField(id, type, symbolTable); .)
  .

  formatFieldDerived<out FormatDefinition.FormatField field, Identifier id>
  = SYM_EQ
    expression<out Expr expr, BIN_OPS> (. field = new FormatDefinition.DerivedFormatField(id, expr); .)
  .

  counterDefinition<out CounterDefinition def>  (. CounterDefinition.CounterKind kind = null; .)
  = ( PROGRAM                                   (. kind = PROGRAM; .)
    | GROUP                                     (. kind = GROUP; .)
    )                                           (. var startLocation = loc(); .)
    COUNTER
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral type> (. def = new CounterDefinition(kind, id, type, startLocation.join(loc())); .)
  .

  instructionDefinition<out InstructionDefinition def>                      (. var startLocation = loc(); .)
  = INSTRUCTION identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON identifierOrPlaceholder<out IdentifierOrPlaceholder formatId> (. pushFormatScope(this, formatId); .)
    SYM_EQ statement<out Statement behavior>                                (. def = new InstructionDefinition(id, formatId, behavior, startLocation.join(loc()));
                                                                               popScope(this); .)
  .

  identifierOrPlaceholder<out IdentifierOrPlaceholder id>           (. id = null; .)
  = identifier<out id>
  | macroInstanceOrPlaceholder<out Node node, BasicSyntaxType.Id()> (. id = (IdentifierOrPlaceholder) node; .)
  .

  encodingDefinition<out EncodingDefinition def>                     (. var startLocation = loc(); .)
  = ENCODING                                                         (. FieldEncodingsOrPlaceholder encodings = null; .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder instrId>
    SYM_EQ SYM_BRACE_OPEN
    (
      encodingDefinitionList<out encodings>
    | macroInstanceOrPlaceholder<out Node n, BasicSyntaxType.Encs()> (. encodings = (FieldEncodingsOrPlaceholder) n; .)
    )
    SYM_BRACE_CLOSE                                                  (. def = new EncodingDefinition(instrId, encodings, startLocation.join(loc())); .)
  .

  encodingDefinitionList<out EncodingDefinition.FieldEncodings encs> (. var entries = new ArrayList<EncodingDefinition.FieldEncoding>(); .)
  = encodingEntry<out FieldEncoding e1>                              (. entries.add(e1); .)
    {
      SYM_COMMA
      encodingEntry<out FieldEncoding e2>                            (. entries.add(e2); .)
    }                                                                (. encs = new EncodingDefinition.FieldEncodings(entries); .)
  .

  encodingEntry<out FieldEncoding enc>                  (. Expr expr = null; .)
  = identifier<out Identifier id>
    SYM_EQ (
      valLiteral<out expr>
    | placeholder<out Node node, BasicSyntaxType.Val()> (. expr = (Expr) node; .)
    )                                                   (. enc = new FieldEncoding(id, expr); .)
  .

  assemblyDefinition<out AssemblyDefinition def>                        (. List<IdentifierOrPlaceholder> ids = new ArrayList<>(); var start = loc(); .)
  = ASSEMBLY
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>             (. ids.add(id); pushInstructionScope(this, id); .)
    {
      SYM_COMMA
      identifierOrPlaceholder<out IdentifierOrPlaceholder additionalId> (. ids.add(additionalId); pushInstructionScope(this, id); .)
    }
    SYM_EQ
    expression<out Expr expr, BIN_OPS>                                  (. def = new AssemblyDefinition(ids, expr, start.join(loc()));
                                                                           popScope(this); .)
  .

  stringLiteral<out StringLiteral lit>
  = string                                               (. lit = new StringLiteral(t.val, loc()); .)
  .

  memoryDefinition<out MemoryDefinition def>
  = MEMORY                                    (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2> (. def = new MemoryDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  registerDefinition<out RegisterDefinition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>         (. def = new RegisterDefinition(id, t1, startLocation.join(t1.location())); .)
  .

  registerFileDefinition<out Definition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    FILE
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2>         (. def = new RegisterFileDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  usingDefinition<out Definition def>
  = USING                             (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_EQ
    typeLiteral<out TypeLiteral type> (. def = new UsingDefinition(id, type, start.join(loc())); .)
  .

  functionDefinition<out Definition def>
  = FUNCTION                           (. var start = loc(); .)
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    functionParameters<.out List<Parameter> params.>
    SYM_ARROW
    typeLiteral<out TypeLiteral retType>
    SYM_EQ                             (. pushFunctionScope(this, params); .)
    expression<out Expr expr, BIN_OPS> (. def = new FunctionDefinition(name, params, retType, expr, start.join(loc())); popScope(this); .)
  .

  functionParameters<.out List<Parameter> params.>
  = SYM_PAREN_OPEN                  (. params = new ArrayList<>(); .)
    parameter<out Parameter param>  (. params.add(param); .)
    {
      SYM_COMMA
      parameter<out Parameter next> (. params.add(next); .)
    }
    SYM_PAREN_CLOSE
  .

  parameter<out Parameter param>
  = identifier<out Identifier name>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. param = new Parameter(name, type); .)
  .

  // -- STATEMENTS ---------------------------------------------------------------------------------------------------

  statement<out Statement statement> (. statement = null; .)
  = letStatement<out statement>
  | ifStatement<out statement>
  | blockStatement<out statement>
  | IF (la.kind == _identifierToken || isMacroParamType(BasicSyntaxType.CallEx()))
    assignment<out statement>
  | macroInstanceOrPlaceholder<out Node s, BasicSyntaxType.Stats()> (. if (s instanceof Statement stmt) statement = stmt;
                                                                       else if (s instanceof StatementList stmts) statement = new BlockStatement(stmts.items, stmts.location());
                                                                    .)
  .

  blockStatement<out BlockStatement block>     (. var start = loc(); pushScope(this); .)
  = SYM_BRACE_OPEN
    statementList<.out List<Statement> stmts.>
    SYM_BRACE_CLOSE                            (. popScope(this); block = new BlockStatement(stmts, start.join(loc())); .)
  .

  statementList<.out List<Statement> stmts.> (. stmts = new ArrayList<>(); .)
  = { statement<out Statement statement>     (. stmts.add(statement); .) }
  .

  assignment<out Statement statement>                                    (. Expr target = null; .)
  = ( callOrBinaryExpression<out target, false>
    | macroInstanceOrPlaceholder<out Node t, BasicSyntaxType.CallEx()>   (. target = (Expr) t; .)
    )
    SYM_ASSIGN
    expression<out Expr expr, BIN_OPS>                                   (. statement = new AssignmentStatement(target, expr); .)
  .

  letStatement<out Statement letStatement>
  = LET                                 (. var start = loc(); var identifiers = new ArrayList<Identifier>(); .)
    identifier<out Identifier id>       (. pushScope(this); identifiers.add(id); symbolTable.defineConstant(id.name, loc()); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); symbolTable.defineConstant(nextId.name, loc()); .)
    }
    SYM_EQ expression<out Expr valueExpr, BIN_OPS_EXCEPT_IN>
    SYM_IN
    statement<out Statement body>       (. letStatement = new LetStatement(identifiers, valueExpr, body, start.join(loc())); popScope(this); .)
  .

  ifStatement<out Statement ifStatement> (. Statement elseStmt = null; var start = loc(); .)
  = KW_IF expression<out Expr condition, BIN_OPS>
    THEN statement<out Statement thenStmt>
    [ IF (la.kind == _ELSE)
      ELSE statement<out elseStmt>
    ]                                    (. ifStatement = new IfStatement(condition, thenStmt, elseStmt, start.join(loc())); .)
  .

  // -- EXPRESSIONS --------------------------------------------------------------------------------------------------

  expression<out Expr expr, boolean[] allowedOps>
  = term<out expr>
    {
      IF (allowedOps[la.kind] || la.kind == _SYM_AS || la.kind == _SYM_DOLLAR)
      (
        binaryOperator<out Operator op>                                   (. var operator = new OperatorExpr(op, loc()); .)
        term<out Expr right>                                              (. expr = new BinaryExpr(expr, operator, right); .)
      | macroInstanceOrPlaceholder<out Node node, BasicSyntaxType.Bin()>
        term<out Expr right>                                              (. expr = new BinaryExpr(expr, (OperatorOrPlaceholder) node, right); .)
      | SYM_AS
        (
          symbolOrBinaryExpression<out Expr symOrBin, true>               (. expr = reorderCastExpr(expr, symOrBin); .)
        | macroInstanceOrPlaceholder<out Node node, BasicSyntaxType.Id()> (. expr = reorderCastExpr(expr, (Expr) node); .)
        )
      )
    }                                                                     (. expr = reorderBinary(this, expr); .)
  .

  /// Call expressions of form "a::b<3>().c()".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  callOrBinaryExpression<out Expr expr, boolean allowLtOp>
  = symbolOrBinaryExpression<out expr, allowLtOp> (. List<List<Expr>> argsIndices = new ArrayList<>(); .)
    {
      // Check if we received a symbol expression -> collect arguments
      // Otherwise, just return the collected binary expression
      // TODO Also collect pseudo-instruction arguments in {...}
      IF (la.kind == _SYM_PAREN_OPEN && expr instanceof IsSymExpr)
      arguments<.out List<Expr> args.>           (. argsIndices.add(args); .)
    }                                            (. List<CallExpr.SubCall> subCalls = new ArrayList<>(); .)
    {
      IF (la.kind == _SYM_DOT && (expr instanceof IsSymExpr))
      SYM_DOT                                    (. var subCallArgsIndices = new ArrayList<List<Expr>>(); .)
      identifier<out Identifier id>
      {
        IF (la.kind == _SYM_PAREN_OPEN)
        arguments<.out List<Expr> args.>         (. subCallArgsIndices.add(args); .)
      }                                          (. subCalls.add(new CallExpr.SubCall(id, argsIndices)); .)
    }                                            (. if (expr instanceof IsSymExpr symExpr && (!argsIndices.isEmpty() || !subCalls.isEmpty()))
                                                      expr = new CallExpr(symExpr, argsIndices, subCalls, expr.location().join(loc()));
                                                    if (expr instanceof IsCallExpr callExpr && !disableSymbolChecking)
                                                      symbolTable.requireValue(callExpr);
                                                 .)
  .

  /// Represents one set of invocation arguments.
  /// Multiple invocations (e.g. multi-dimensional access) will need multiple #arguments
  arguments<.out List<Expr> args.>
  = SYM_PAREN_OPEN                            (. args = new ArrayList<>(); .)
    expression<out Expr arg, BIN_OPS>         (. args.add(arg); .)
    ( SYM_RANGE
      expression<out Expr rangeTo, BIN_OPS>   (. args.set(0, new RangeExpr(arg, rangeTo)); .)
    | {
      SYM_COMMA
      expression<out Expr nextArg, BIN_OPS>   (. args.add(nextArg); .)
    })
    SYM_PAREN_CLOSE
  .

  /// Symbol expressions of form "a::b<3>".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  symbolOrBinaryExpression<out Expr expr, boolean allowLtOp>
  = identifierPath<out IsId path> (. expr = null; .)
    [
      IF (la.kind == _SYM_LT)
      SYM_LT                                (. var lessLoc = loc(); .)
      term<out Expr term>
      [
        IF (!allowLtOp || la.kind == _SYM_GT)
        SYM_GT                              (. expr = new SymbolExpr(path, term, path.location().join(loc())); .)
      ]                                     (. if (expr == null) expr = new BinaryExpr((Expr) path, new OperatorExpr(Operator.Less(), lessLoc), term); .)
    ]                                       (. if (expr == null) expr = (Expr) path; .)
  .

  binaryOperator<out Operator op>    (.op = null;.)
  = SYM_LOGOR  (. op = Operator.LogicalOr(); .)
  | SYM_LOGAND (. op = Operator.LogicalAnd(); .)
  | SYM_BINOR  (. op = Operator.Or(); .)
  | SYM_CARET  (. op = Operator.Xor(); .)
  | SYM_BINAND (. op = Operator.And(); .)
  | SYM_EQ     (. op = Operator.Equal(); .)
  | SYM_NEQ    (. op = Operator.NotEqual(); .)
  | SYM_GTE    (. op = Operator.GreaterEqual(); .)
  | SYM_GT     (. op = Operator.Greater(); .)
  | SYM_LTE    (. op = Operator.LessEqual(); .)
  | SYM_LT     (. op = Operator.Less(); .)
  | SYM_ROTR   (. op = Operator.RotateRight(); .)
  | SYM_ROTL   (. op = Operator.RotateLeft(); .)
  | SYM_SHR    (. op = Operator.ShiftRight(); .)
  | SYM_SHL    (. op = Operator.ShiftLeft(); .)
  | SYM_PLUS   (. op = Operator.Add(); .)
  | SYM_MINUS  (. op = Operator.Subtract(); .)
  | SYM_MUL    (. op = Operator.Multiply(); .)
  | SYM_DIV    (. op = Operator.Divide(); .)
  | SYM_MOD    (. op = Operator.Modulo(); .)
  | SYM_IN     (. op = Operator.In(); .)
  | SYM_NIN    (. op = Operator.NotIn(); .)
  // When adding a new operator here, it must also be added to the "BIN_OPS" list in ParserUtils.java!
  .

  unary<out Expr expr>
  = unaryOperator<out UnaryOperator op>
    term<out Expr operand> (. if (operand instanceof BinaryExpr binExpr) {
                                expr = new BinaryExpr(new UnaryExpr(op, binExpr.left), binExpr.operator, binExpr.right);
                              } else {
                                expr = new UnaryExpr(op, operand);
                              }
                           .)
  .

  unaryOperator<out UnaryOperator op> (. op = null; .)
  = SYM_MINUS (. op = UnaryOperator.NEGATIVE; .)
  | SYM_EXCL  (. op = UnaryOperator.LOG_NOT; .)
  | SYM_TILDE (. op = UnaryOperator.COMPLEMENT; .)
  .

  term<out Expr expr>                            (. expr = null; .)
  = literal<out expr>
  | callOrBinaryExpression<out expr, true>
  | groupedExpression<out expr>
  | unary<out expr>
  | ifExpression<out expr>
  | letExpression<out expr>
  | macroInstanceOrPlaceholder<out Node node, BasicSyntaxType.Ex()> (. expr = (Expr) node; .)
  .

  groupedExpression<out GroupedExpr expr> (. expr = new GroupedExpr(new ArrayList<>(), loc()); .)
  = SYM_PAREN_OPEN
    expression<out Expr inner, BIN_OPS>   (. expr.expressions.add(inner); .)
    {
      SYM_COMMA
      expression<out Expr next, BIN_OPS>  (. expr.expressions.add(next); .)
    }
    SYM_PAREN_CLOSE                       (. expr.loc = expr.loc.join(loc()); .)
  .

  literal<out Expr expr> (. expr = null; .)
  = valLiteral<out expr>
  | stringLiteral<out expr>
  .

  valLiteral<out Expr expr> (. expr = null; .)
  = boolLiteral<out expr>
  | intLiteral<out expr>
  | binLiteral<out expr>
  .

  intLiteral<out Expr expr>
  = decLit (. expr = new IntegerLiteral(t.val, loc()); .)
  .

  binLiteral<out Expr expr>
  = (hexLit | binLit) (. expr = new BinaryLiteral(t.val, loc()); .)
  .

  boolLiteral<out Expr expr> (. expr = null; .)
  = TRUE                     (. expr = new BoolLiteral(true, loc()); .)
  | FALSE                    (. expr = new BoolLiteral(false, loc()); .)
  .

  identifierPath<out IsId path>       (. List<Identifier> segments = new ArrayList<>(); .)
  = identifier<out Identifier id>     (. segments.add(id); .)
    {
      SYM_NAMESPACE
      identifier<out Identifier next> (. segments.add(next); .)
    }                                 (. if (segments.size() == 1) path = segments.get(0);
                                         else path = new IdentifierPath(segments); .)
  .

  rangeExpression<out Expr expr>
  = expression<out expr, BIN_OPS>
    [ SYM_RANGE expression<out Expr to, BIN_OPS> (. expr = new RangeExpr(expr, to); .) ]
  .

  letExpression<out Expr expr>
  = LET                                 (. var start = loc(); var identifiers = new ArrayList<Identifier>(); .)
    identifier<out Identifier id>       (. pushScope(this); identifiers.add(id); symbolTable.defineConstant(id.name, loc()); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); symbolTable.defineConstant(nextId.name, loc()); .)
    }
    SYM_EQ
    expression<out Expr valueExpr, BIN_OPS_EXCEPT_IN>
    SYM_IN
    expression<out Expr body, BIN_OPS>  (. expr = new LetExpr(identifiers, valueExpr, body, start.join(loc())); popScope(this); .)
  .

  ifExpression<out Expr expr>
  = KW_IF                                       (. var startLoc = loc(); .)
    expression<out Expr condition, BIN_OPS>
    THEN expression<out Expr thenExpr, BIN_OPS>
    ELSE expression<out Expr elseExpr, BIN_OPS> (. expr = new IfExpr(condition, thenExpr, elseExpr, startLoc.join(loc())); .)
  .

  // -- PRIMITIVES ---------------------------------------------------------------------------------------------------

  typeLiteralOrPlaceholder<out TypeLiteralOrPlaceholder type>    (. type = null; .)
  = typeLiteral<out type>
  | macroInstanceOrPlaceholder<out Node n, BasicSyntaxType.Id()> (. if (n instanceof IsId id) type = new TypeLiteral(id, List.of(), id.location());
                                                                    else type = (PlaceholderExpr) n; .)
  .

  typeLiteral<out TypeLiteral type>
  = identifierPath<out IsId path>                        (. List<List<Expr>> sizeIndices = new ArrayList<>(); .)
    {
      SYM_LT                                             (. List<Expr> sizes = new ArrayList<>(); .)
      expression<out Expr sizeExpr, BIN_OPS_EXCEPT_GT>   (. sizes.add(sizeExpr); .)
      {
        SYM_COMMA
        expression<out Expr nextSize, BIN_OPS_EXCEPT_GT> (. sizes.add(nextSize); .)
      }
      SYM_GT                                             (. sizeIndices.add(sizes); .)
    }                                                    (. type = new TypeLiteral(path, sizeIndices, path.location().join(loc())); .)
  .

  identifier<out Identifier identifier>
  = (identifierToken | allowedIdentifierKeywords) (. identifier = new Identifier(t.val, loc()); .)
  .

  allowedIdentifierKeywords
  = T_BOOL
  | REGISTER
  // TODO Add all allowed keywords
  .

  // -- MACROS -------------------------------------------------------------------------------------------------------
  macroInstanceOrPlaceholder<out Node body, SyntaxType requiredType> (. body = null; .)
  = IF (!insideMacro) macroInstance<out body, requiredType>
  | placeholder<out body, requiredType>
  .

  placeholder<out Node placeholder, SyntaxType requiredType>
  = SYM_DOLLAR                            (. var startloc = loc(); .)
  identifierPath<out IsId path>           (. if (isDefType(requiredType)) placeholder = new PlaceholderDefinition(path, startloc.join(loc()));
                                             else placeholder = new PlaceholderExpr(path, startloc.join(loc())); .)
  .


  macroInstance<out Node body, SyntaxType requiredType>         (. disableSymbolChecking(); .)
  = SYM_DOLLAR                                                  (. var args = new ArrayList<Node>(); .)
    identifier<out Identifier id>                               (. var macro = Objects.requireNonNull(symbolTable.getMacro(id.name)); .)
    SYM_PAREN_OPEN                                              (. var params = macro.params().iterator(); .)
    (
      IF (!params.hasNext())
      SYM_PAREN_CLOSE
    | macroInstanceParam<out Node arg1, params.next().type()>   (. args.add(arg1); .)
      {
        SYM_SEMICOLON
        macroInstanceParam<out Node arg2, params.next().type()> (. args.add(arg2); .)
      }
      SYM_PAREN_CLOSE
    )                                                           (. body = expandMacro(this, id, args, requiredType); enableSymbolChecking(); .)
  .

  macroInstanceParam<out Node arg, SyntaxType syntaxType> (. arg = null; var start = loc(); .)
  = IF (syntaxType == BasicSyntaxType.BinOp())
    binaryOperator<out Operator op>                       (. arg = new OperatorExpr(op, loc()); .)
  | IF (syntaxType == BasicSyntaxType.IsaDefs())
    isaDefinitionList<.out List<Definition> defs.>        (. arg = new DefinitionList(defs, start.join(loc())); .)
  | IF (syntaxType == BasicSyntaxType.Encs())
    encodingDefinitionList<out arg>
  | IF (syntaxType == BasicSyntaxType.Ex())
    expression<out arg, BIN_OPS>
  | IF (syntaxType == BasicSyntaxType.CallEx())
    callOrBinaryExpression<out arg, false>
  | IF (syntaxType == BasicSyntaxType.SymEx())
    symbolOrBinaryExpression<out arg, false>
  | IF (syntaxType == BasicSyntaxType.Id())
    identifier<out arg>
  | IF (syntaxType == BasicSyntaxType.Lit())
    literal<out arg>
  | IF (syntaxType == BasicSyntaxType.Str())
    stringLiteral<out arg>
  | IF (syntaxType == BasicSyntaxType.Val())
    valLiteral<out arg>
  | IF (syntaxType == BasicSyntaxType.Bool())
    boolLiteral<out arg>
  | IF (syntaxType == BasicSyntaxType.Int())
    intLiteral<out arg>
  | IF (syntaxType == BasicSyntaxType.Bin())
    binLiteral<out arg>
  | expression<out arg, BIN_OPS>
  .

  macroDef
  = MODEL                                   (. var startLoc = loc(); .)
    identifier<out Identifier id>
    SYM_PAREN_OPEN                          (. var params = new ArrayList<MacroParam>(); .)
    [
      identifier<out Identifier paramId1>
      SYM_COLON
      syntaxType<out SyntaxType synType1>   (. params.add(new MacroParam(paramId1, synType1)); .)
      {
        SYM_COMMA
        identifier<out Identifier paramId2>
        SYM_COLON
        syntaxType<out SyntaxType synType2> (. params.add(new MacroParam(paramId2, synType2)); .)
      }
    ]
    SYM_PAREN_CLOSE
    SYM_COLON syntaxType<out SyntaxType returnType> SYM_EQ
    SYM_BRACE_OPEN                          (. Node body = null; insideMacro = true; disableSymbolChecking(); .)
    macroBody<out body, returnType>
    SYM_BRACE_CLOSE                         (.
                                              insideMacro = false;
                                              enableSymbolChecking();
                                              var bodyType = narrowNode(body).syntaxType();
                                              if (!bodyType.isSubTypeOf(returnType)) {
                                                errors.SemErr(t.line, t.col, "The macro signature promises to return `%s` but it's body is of type `%s`.".formatted(returnType, bodyType));
                                                symbolTable.addMacro(new Macro(id, params, body, BasicSyntaxType.Invalid()), startLoc.join(loc()));
                                              } else {
                                                symbolTable.addMacro(new Macro(id, params, body, returnType), startLoc.join(loc()));
                                              }
                                            .)
  .

  macroBody<out Node body, SyntaxType type>        (. body = null; var loc = lookaheadLoc(); .)
  = IF (type == BasicSyntaxType.Id())
    identifier<out body>
  | IF (type == BasicSyntaxType.Ex() || type == BasicSyntaxType.Int())
    expression<out body, BIN_OPS>
  | IF (type == BasicSyntaxType.Stat())
    statement<out body>
  | IF (type == BasicSyntaxType.Stats())
    statementList<.out List<Statement> stmts.>     (. body = narrowNode(new StatementList(stmts, loc.join(loc()))); .)
  | IF (type == BasicSyntaxType.IsaDefs())
    isaDefinitionList<.out List<Definition> defs.> (. body = new DefinitionList(defs, loc.join(loc())); .)
  | // IF (type == BasicSyntaxType.Encs())
    encodingDefinitionList<out body>
  .

  syntaxType<out SyntaxType type>
  = basicSyntaxType<out type>
  .

  basicSyntaxType<out BasicSyntaxType type> (. type = null; .)
  = T_STATS                                 (. type = BasicSyntaxType.Stats(); .)
  | T_STAT                                  (. type = BasicSyntaxType.Stat(); .)
  | T_ENCS                                  (. type = BasicSyntaxType.Encs(); .)
  | T_ISA_DEFS                              (. type = BasicSyntaxType.IsaDefs(); .)
  | T_EX                                    (. type = BasicSyntaxType.Ex(); .)
  | T_LIT                                   (. type = BasicSyntaxType.Lit(); .)
  | T_STR                                   (. type = BasicSyntaxType.Str(); .)
  | T_VAL                                   (. type = BasicSyntaxType.Val(); .)
  | T_BOOL                                  (. type = BasicSyntaxType.Bool(); .)
  | T_INT                                   (. type = BasicSyntaxType.Int(); .)
  | T_BIN                                   (. type = BasicSyntaxType.Bin(); .)
  | T_CALL_EX                               (. type = BasicSyntaxType.CallEx(); .)
  | T_SYM_EX                                (. type = BasicSyntaxType.SymEx(); .)
  | T_ID                                    (. type = BasicSyntaxType.Id(); .)
  | T_BIN_OP                                (. type = BasicSyntaxType.BinOp(); .)
  | T_UN_OP                                 (. type = BasicSyntaxType.UnOp(); .)
  .

END vadl.
