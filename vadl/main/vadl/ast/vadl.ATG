// SPDX-FileCopyrightText : © 2024 TU Wien <vadl@tuwien.ac.at>
// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

$package=vadl.ast
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;

import vadl.utils.SourceLocation;

import static vadl.ast.CounterDefinition.CounterKind.GROUP;
import static vadl.ast.CounterDefinition.CounterKind.PROGRAM;
import static vadl.ast.ParserUtils.*;

COMPILER vadl
  java.net.URI sourceFile = SourceLocation.INVALID_SOURCE_LOCATION.uri();
  @Nullable java.net.URI resolutionUri;
  Deque<List<MacroParam>> macroContext = new ArrayDeque<>();
  Ast ast = new Ast();
  SymbolTable macroTable = new SymbolTable();
  Map<String, Identifier> macroOverrides = new HashMap<>();

  {
    ast.rootSymbolTable = new SymbolTable();
    ast.rootSymbolTable.loadBuiltins();
  }

  SourceLocation lastTokenLoc() {
    return locationFromToken(this, t);
  }

  SourceLocation nextTokenLoc() {
    return locationFromToken(this, la);
  }

  // This function is needed in the parser to avoid an unreachable statement error,
  // since the java compiler doesn't check the body of called functions.
  void throwException(RuntimeException throwable) {
    throw throwable;
  }

CHARACTERS
  digit = '0' .. '9'.
  binDigit = '0' .. '1'.
  hexDigit = '0' .. '9' + 'A' .. 'F' + 'a' .. 'f'.
  letter = 'a' .. 'z' + 'A' .. 'Z'.
  validDQStringCharacters = ANY - '"' - "\\".
  validSQStringCharacters = ANY - "'" - "\\".
  validSourceCharacters = ANY.

TOKENS
  hexLit = "0x" hexDigit {hexDigit | "'"}.
  binLit = "0b" binDigit {binDigit | "'"}.
  decLit = digit {digit | "'"}.
  embeddedSource = "-<{" {validSourceCharacters} "}>-".

  identifierToken = letter {letter | digit | "_"}.
  string =
  ( '"' { "\\" (letter | '"' | "'" | "\\") | validDQStringCharacters } '"') |
  ( "'" { "\\" (letter | '"' | "'" | "\\") | validSQStringCharacters } "'").

  T_BIN         = "Bin".
  T_BIN_OP      = "BinOp".
  T_BOOL        = "Bool".
  T_CALL_EX     = "CallEx".
  T_COMMON_DEFS = "Defs".
  T_ENCS        = "Encs".
  T_EX          = "Ex".
  T_ID          = "Id".
  T_INT         = "Int".
  T_ISA_DEFS    = "IsaDefs".
  T_LIT         = "Lit".
  T_STAT        = "Stat".
  T_STATS       = "Stats".
  T_STR         = "Str".
  T_SYM_EX      = "SymEx".
  T_UN_OP       = "UnOp".
  T_VAL         = "Val".

  ABSOLUTE     = "absolute".
  ADDRESS      = "address".
  ADJUSTMENT   = "adjustment".
  ALIAS        = "alias".
  ALIGN        = "align".
  APPEND       = "append".
  APPLICATION  = "application".
  ARCHITECTURE = "architecture".
  ARGUMENT     = "argument".
  ASSEMBLY     = "assembly".
  BINARY       = "binary".
  CACHE        = "cache".
  CALL         = "call".
  CALLEE       = "callee".
  CALLER       = "caller".
  COMPILER_KW  = "compiler".
  CONSTANT     = "constant".
  COUNTER      = "counter".
  DECODER      = "decoder".
  DESCRIPTION  = "description".
  DIRECTIVES   = "directives".
  DO           = "do".
  ELSE         = "else".
  ENCODE       = "encode".
  ENCODING     = "encoding".
  ENUMERATION  = "enumeration".
  EXCEPTION    = "exception".
  EXISTS       = "exists".
  EXTEND_ID    = "ExtendId".
  EXTENDING    = "extending".
  FALSE        = "false".
  FETCH        = "fetch".
  FILE         = "file".
  FOLD         = "fold".
  FOR          = "for".
  FORALL       = "forall".
  FORMAT       = "format".
  FRAME        = "frame".
  FUNCTION     = "function".
  GLOBAL       = "global".
  GRAMMAR      = "grammar".
  GROUP        = "group".
  HIT          = "hit".
  ID_TO_STR    = "IdToStr".
  IF_KW        = "if".
  INT          = "int".
  IMPLEMENTS   = "implements".
  IMPORT       = "import".
  INSTRUCTION  = "instruction".
  INTERFACE    = "interface".
  LET          = "let".
  LOAD         = "load".
  LOCAL        = "local".
  LOCK         = "lock".
  LOGIC        = "logic".
  LONG         = "long".
  MATCH        = "match".
  MAX          = "max".
  MEMORY       = "memory".
  MICRO        = "micro".
  MISS         = "miss".
  MODEL        = "model".
  MODEL_TYPE   = "model-type".
  MODIFIERS    = "modifiers".
  NON          = "non".
  NONE         = "none".
  NOP          = "nop".
  OPERATION    = "operation".
  PATCH        = "patch".
  PIC          = "pic".
  PIPELINE     = "pipeline".
  POINTER      = "pointer".
  PREDICATE    = "predicate".
  PREDICTION   = "prediction".
  PROCESS      = "process".
  PROCESSOR    = "processor".
  PROGRAM      = "program".
  PSEUDO       = "pseudo".
  RAISE        = "raise".
  RAM          = "RAM".
  READ         = "read".
  RECORD       = "record".
  REGISTER     = "register".
  REGION       = "region".
  RELOCATION   = "relocation".
  RESET        = "reset".
  RETURN       = "return".
  ROM          = "ROM".
  SAVED        = "saved".
  SEQUENCE     = "sequence".
  SET          = "set".
  SIGNAL       = "signal".
  SIGNED       = "signed".
  SIZE_T       = "size_t".
  SPECIAL      = "special".
  SOURCE       = "source".
  STACK        = "stack".
  STAGE        = "stage".
  STARTUP      = "startup".
  STOP         = "stop".
  TENSOR       = "tensor".
  THEN         = "then".
  THREAD       = "thread".
  TRANSLATION  = "translation".
  TRUE         = "true".
  TYPE         = "type".
  UNSIGNED     = "unsigned".
  USING        = "using".
  VALUE        = "value".
  VAR          = "var".
  WIDTH        = "width".
  WITH         = "with".
  WRITE        = "write".

  SYM_ARROW       = "->".
  SYM_AS          = "as".
  SYM_ASSIGN      = ":=".
  SYM_AT          = "@".
  SYM_BIGARROW    = "=>".
  SYM_BINAND      = "&".
  SYM_BINOR       = "|".
  SYM_BRACE_CLOSE = "}".
  SYM_BRACE_OPEN  = "{".
  SYM_BRACK_CLOSE = "]".
  SYM_BRACK_OPEN  = "[".
  SYM_CARET       = "^".
  SYM_COLON       = ":".
  SYM_COMMA       = ",".
  SYM_DIV         = "/".
  SYM_DOLLAR      = "$".
  SYM_DOT         = ".".
  SYM_ELEM_OF     = "∈".
  SYM_EQ          = "=".
  SYM_EXCL        = "!".
  SYM_GT          = ">".
  SYM_GTE         = ">=".
  SYM_IN          = "in".
  SYM_LOGAND      = "&&".
  SYM_LOGOR       = "||".
  SYM_LONG_MUL    = "*#".
  SYM_LT          = "<".
  SYM_LTE         = "<=".
  SYM_MINUS       = "-".
  SYM_MOD         = "%".
  SYM_MUL         = "*".
  SYM_NAMESPACE   = "::".
  SYM_NEQ         = "!=".
  SYM_NIN         = "!in".
  SYM_NOT_ELEM_OF = "∉".
  SYM_PAREN_CLOSE = ")".
  SYM_PAREN_OPEN  = "(".
  SYM_PLUS        = "+".
  SYM_PLUS_EQ     = "+=".
  SYM_QUESTION    = "?".
  SYM_RANGE       = "..".
  SYM_ROTL        = "<<>".
  SYM_ROTR        = "<>>".
  SYM_SAT_ADD     = "+|".
  SYM_SAT_SUB     = "-|".
  SYM_SEMICOLON   = ";".
  SYM_SHL         = "<<".
  SYM_SHR         = ">>".
  SYM_TILDE       = "~".
  SYM_UNDERSCORE  = "_".

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
  vadl =
  {
    SYNC
    topLevelDefinitions<out Definition def> (.
                                                addDef(ast.definitions, def);
                                                // Only call the symbol resolver if there were no errors, because other
                                                // wise the AST might be invalid, causing a crash.
                                                if (errors.count == 0) {
                                                  new SymbolTable.SymbolCollector().collectSymbols(ast.rootSymbolTable(), def);
                                                }
                                            .)
    | macroDef<out ModelDefinition def>     (.
                                                addDef(ast.definitions, def);
                                                // Only call the symbol resolver if there were no errors, because other
                                                // wise the AST might be invalid, causing a crash.
                                                if (errors.count == 0) {
                                                new SymbolTable.SymbolCollector().collectSymbols(ast.rootSymbolTable(), def); macroTable.addModelDefinition(def);
                                                }
                                            .)
  }SYNC.

  // -- DEFINITIONS --------------------------------------------------------------------------------------------------
  topLevelDefinitions<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<. out List<AnnotationDefinition> annotations.>
  ( instructionsetDefinition<out def>
  | applicationBinaryInterfaceDefinition<out def>
  | processorDefinition<out def>
  | microArchitectureDefinition<out def>
  | commonDefinition<out def>
  | importDefinition<out def>
  | assemblyDescriptionDefinition<out def>
  )                                         (. def.withAnnotations(annotations); .)
  .

  commonDefinitionList<.out List<Definition> definitions.> (. definitions = new ArrayList<>(); .)
  = {
    annotations<.out List<AnnotationDefinition> annotations.>
    commonDefinition<out Definition def>                   (. def.withAnnotations(annotations); definitions.add(def); .)
  | macroDef<out ModelDefinition def>                      (. addDef(definitions, def); macroTable.addModelDefinition(def); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>                           (. var def = castCommonDef(this, n);
                                                              if (def instanceof DefinitionList list) {
                                                                readMacroSymbols(macroTable, list.items);
                                                              }
                                                              addDef(definitions, def); .)
  }
  .

  commonDefinition<out Definition def>    (. def = DUMMY_DEF; .)
  = constantDefinition<out def>
  | formatDefinition<out def>
  | enumerationDefinition<out def>
  | usingDefinition<out def>
  | functionDefinition<out def>
  | recordDefinition<out def>
  | modelTypeDefinition<out def>
  .

  instructionsetDefinition<out InstructionSetDefinition isaDef> (. macroTable = macroTable.createChild(); var startLocation = nextTokenLoc();.)
  = INSTRUCTION SET ARCHITECTURE
    identifierOrPlaceholder<out var identifier>                 (. var extending = new ArrayList<IsId>(); .)
    [
      EXTENDING
      identifierOrPlaceholder<out var isa>                      (. extending.add(isa); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out isa>                        (. extending.add(isa); .)
      }
    ]                                                           (. extending.forEach(e -> {
                                                                      var extendingIsa = macroTable.requireIsaDef(e);
                                                                      if (extendingIsa != null)
                                                                          readMacroSymbols(macroTable, extendingIsa);
                                                                    }); .)
    SYM_EQ SYM_BRACE_OPEN
    isaDefinitionList<.out List<Definition> definitions.>       (. macroTable = macroTable.pop(); .)
    SYM_BRACE_CLOSE                                             (. isaDef = new InstructionSetDefinition(identifier, extending, definitions, startLocation.join(lastTokenLoc()));
                                                                   macroTable.defineSymbol(isaDef); .)
  .

  isaDefinitionList<.out List<Definition> definitions.> (. definitions = new ArrayList<>(); .)
  = {
    annotations<.out List<AnnotationDefinition> annotations.>
    isaDefinition<out Definition def>                   (. def.withAnnotations(annotations); definitions.add(def); .)
  | macroDef<out ModelDefinition def>                   (. addDef(definitions, def); macroTable.addModelDefinition(def); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.ISA_DEFS))
    macroReplacement<out Node n>                        (. var def = castIsaDef(this, n);
                                                           if (def instanceof DefinitionList list) {
                                                             readMacroSymbols(macroTable, list.items);
                                                           }
                                                           addDef(definitions, def); .)
  }
  .

  annotations<out List<AnnotationDefinition> annotations> (. var list = new ArrayList<AnnotationDefinition>(); .)
  = {
    annotation<out AnnotationDefinition annotation>       (. list.add(annotation); .)
  }                                                       (. annotations = new ArrayList<AnnotationDefinition>(list); .)
  .

  annotation<out AnnotationDefinition annotation> (. var startLocation = nextTokenLoc(); var keywords = new ArrayList<IdentifierOrPlaceholder>(); var values = new ArrayList<Expr>(); .)
  = SYM_BRACK_OPEN
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>   (. keywords.add(id); .)
    {
      identifierOrPlaceholder<out IdentifierOrPlaceholder id2> (. keywords.add(id2); .)
    }
    [
      SYM_COLON
      expression<out Expr expr, BIN_OPS>                               (. values.add(expr); .)
      {
        SYM_COMMA
        expression<out Expr expr2, BIN_OPS>                             (. values.add(expr2); .)
      }
    ]
    SYM_BRACK_CLOSE                     (. annotation = new AnnotationDefinition(keywords, values, startLocation.join(lastTokenLoc())); .)
  .

  isaDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = commonDefinition<out def>
  | IF (la.kind == _GROUP && scanner.Peek().kind != _COUNTER)
    groupDefinition<out def>
  | counterDefinition<out def>
  | instructionDefinition<out def>
  | pseudoInstructionDefinition<out def>
  | relocationDefinition<out def>
  | encodingDefinition<out def>
  | assemblyDefinition<out def>
  | memoryDefinition<out def>
  | registerDefinition<out def>
  | aliasDefinition<out def>
  | exceptionDefinition<out def>
  | processDefinition<out def>
  | operationDefinition<out def>
  .

  constantDefinition<out ConstantDefinition def> (. TypeLiteral type = null; var startLocation = nextTokenLoc(); .)
  = CONSTANT
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out type> ]
    SYM_EQ
    expression<out Expr expr, BIN_OPS>           (. def = new ConstantDefinition(id, type, expr, startLocation.join(lastTokenLoc())); .)
  .

  formatDefinition<out FormatDefinition def>                     (. var startLoc = nextTokenLoc(); .)
  = FORMAT
  identifierOrPlaceholder<out IdentifierOrPlaceholder id>        (. var fields = new ArrayList<FormatField>();.)
  SYM_COLON typeLiteral<out TypeLiteral type>                    (. var auxFields = new ArrayList<FormatDefinition.AuxiliaryField>();.)
  [
    SYM_EQ SYM_BRACE_OPEN
    formatField<out FormatField f1>             (. fields.add(f1); .)
    {
      SYM_COMMA formatField<out FormatField f2> (. fields.add(f2); .)
    | SYM_COLON
      auxiliaryField<out FormatDefinition.AuxiliaryField aux>    (. auxFields.add(aux); .)
    }
    SYM_BRACE_CLOSE
  ]                                                              (. def = new FormatDefinition(id, type, fields, auxFields, startLoc.join(lastTokenLoc())); .)
  .

  formatField<out FormatField field> (. field = null; .)
  = identifier<out Identifier id>
    ( formatFieldRange<out field, id>
    | formatFieldType<out field, id>
    | formatFieldDerived<out field, id>
    )
  .

  auxiliaryField<out FormatDefinition.AuxiliaryField auxField> (. FormatDefinition.AuxiliaryFieldKind kind = null; .)
  = (
    PREDICATE                                                  (. kind = FormatDefinition.AuxiliaryFieldKind.PREDICATE; .)
  | ENCODE                                                     (. kind = FormatDefinition.AuxiliaryFieldKind.ENCODE; .)
  )
    SYM_BRACE_OPEN                                             (. var auxEntries = new ArrayList<FormatDefinition.AuxiliaryFieldEntry>(); .)
    identifier<out Identifier fieldId>
    SYM_BIGARROW
    expression<out Expr fieldExpr, BIN_OPS>                    (. auxEntries.add(new FormatDefinition.AuxiliaryFieldEntry(fieldId, fieldExpr)); .)
    {
      SYM_COMMA
      identifier<out fieldId>
      SYM_BIGARROW
      expression<out fieldExpr, BIN_OPS>                       (. auxEntries.add(new FormatDefinition.AuxiliaryFieldEntry(fieldId, fieldExpr)); .)
    }
    SYM_BRACE_CLOSE                                            (. auxField = new FormatDefinition.AuxiliaryField(kind, auxEntries); .)
  .

  formatFieldRange<out FormatField field, Identifier id>
  = SYM_BRACK_OPEN                      (. List<Expr> ranges = new ArrayList<>();.)
    rangeExpression<out Expr e1>        (. ranges.add(e1); .)
    {
      SYM_COMMA
      rangeExpression<out Expr e2>      (. ranges.add(e2); .)
    }
    SYM_BRACK_CLOSE                     (. TypeLiteral type = null; .)
    [
      IF (la.kind == _SYM_COLON && !AUX_FIELD_TOKENS[la.kind])
      SYM_COLON
      typeLiteral<out type>
    ]                                   (. field = new RangeFormatField(id, ranges, type); .)
  .

  formatFieldType<out FormatField field, Identifier id>
  = SYM_COLON
    typeLiteral<out TypeLiteral type> (. field = new TypedFormatField(id, type); .)
  .

  formatFieldDerived<out FormatField field, Identifier id>
  = SYM_EQ
    expression<out Expr expr, BIN_OPS> (. field = new DerivedFormatField(id, expr); .)
  .

  counterDefinition<out CounterDefinition def>  (. CounterDefinition.CounterKind kind = null; var startLocation = nextTokenLoc(); .)
  = ( PROGRAM                                   (. kind = PROGRAM; .)
    | GROUP                                     (. kind = GROUP; .)
    )
    COUNTER
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral type> (. def = new CounterDefinition(kind, id, type, startLocation.join(lastTokenLoc())); .)
  .

  instructionDefinition<out InstructionDefinition def>                      (. var startLocation = nextTokenLoc(); .)
  = INSTRUCTION identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON identifierOrPlaceholder<out IdentifierOrPlaceholder formatId>
    SYM_EQ statement<out Statement behavior>                                (. def = new InstructionDefinition(id, formatId, behavior, startLocation.join(lastTokenLoc())); .)
  .

  pseudoInstructionDefinition<out Definition def>            (. PseudoInstructionDefinition.PseudoInstrKind kind = null;  var startLocation = nextTokenLoc(); .)
  = ( PSEUDO                                                 (. kind = PseudoInstructionDefinition.PseudoInstrKind.PSEUDO; .)
    | COMPILER_KW                                            (. kind = PseudoInstructionDefinition.PseudoInstrKind.COMPILER; .)
    )
    INSTRUCTION
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>  (. List<Parameter> params = new ArrayList<>(); .)
    [ parameters<out params> ]
    SYM_EQ
    SYM_BRACE_OPEN                                           (. var stmts = new ArrayList<InstructionCallStatement>(); .)
    {
      instructionCallStmt<out InstructionCallStatement stmt> (. stmts.add(stmt); .)
    }
    SYM_BRACE_CLOSE                                          (. def = new PseudoInstructionDefinition(id, kind, params, stmts, startLocation.join(lastTokenLoc())); .)
  .

  relocationDefinition<out Definition def>    (. var startLocation = nextTokenLoc(); .)
  = RELOCATION
    identifier<out Identifier id>
    parameters<.out List<Parameter> params.>
    SYM_ARROW
    typeLiteral<out TypeLiteral resultType>
    SYM_EQ
    expression<out Expr expr, BIN_OPS>        (. def = new RelocationDefinition(id, params, resultType, expr, startLocation.join(lastTokenLoc())); .)
  .

  identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. id = DUMMY_ID; .)
  = identifier<out id>
  | macroReplacement<out Node node>                       (. id = castId(this, node); .)
  .

  encodingDefinition<out EncodingDefinition def>                        (. var startLocation = nextTokenLoc(); .)
  = ENCODING
    identifierOrPlaceholder<out IdentifierOrPlaceholder instrId>
    SYM_EQ SYM_BRACE_OPEN
    encodingDefinitionList<out EncodingDefinition.EncsNode encodings>
    SYM_BRACE_CLOSE                                                     (. def = new EncodingDefinition(instrId, encodings, startLocation.join(lastTokenLoc())); .)
  .

  encodingDefinitionList<out EncodingDefinition.EncsNode encs> (. var start = nextTokenLoc(); var entries = new ArrayList<IsEncs>(); .)
  = encodingEntry<out IsEncs enc>                              (. addEncs(entries, enc); .)
    {
      // In a macro match, commas are used for separating multiple pattern alternatives
      // In the unlikely event that someone uses macro match with Encs literals,
      // we interpret commas as part of the Encs body, not the macro match alternatives.
      // Instead, the specification author can use multiple macro match productions with the same effect.
      IF (la.kind == _SYM_COMMA)
      SYM_COMMA
      encodingEntry<out enc>                                   (. addEncs(entries, enc); .)
    }                                                          (. encs = new EncodingDefinition.EncsNode(entries, start.join(lastTokenLoc())); .)
  .

  encodingEntry<out IsEncs enc>        (. enc = null; .)
  = IF (la.kind == _NONE)
    NONE
  | macroReplacement<out Node node>    (. enc = castEncs(this, node); .)
  | identifier<out Identifier id>
    SYM_EQ
    expression<out Expr expr, BIN_OPS> (. enc = new EncodingDefinition.EncodingField(id, expr); .)
  .

  assemblyDefinition<out AssemblyDefinition def>                        (. List<IdentifierOrPlaceholder> ids = new ArrayList<>(); var start = nextTokenLoc(); .)
  = ASSEMBLY
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>             (. ids.add(id); .)
    {
      SYM_COMMA
      identifierOrPlaceholder<out IdentifierOrPlaceholder additionalId> (. ids.add(additionalId); .)
    }
    SYM_EQ
    expression<out Expr expr, BIN_OPS>                                  (. def = new AssemblyDefinition(ids, expr, start.join(lastTokenLoc())); .)
  .

  stringLiteral<out StringLiteral lit>
  = string                                               (. lit = new StringLiteral(t.val, lastTokenLoc()); .)
  .

  memoryDefinition<out MemoryDefinition def>                (. var startLocation = nextTokenLoc(); .)
  = MEMORY
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2>               (. def = new MemoryDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  registerDefinition<out RegisterDefinition def>            (. var startLocation = nextTokenLoc(); .)
  = REGISTER
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_COLON
    relationType<out RegisterDefinition.RelationTypeLiteral type> (. def = new RegisterDefinition(id, type, startLocation.join(lastTokenLoc())); .)
  .

  relationType<out RegisterDefinition.RelationTypeLiteral type> (. var argTypes = new ArrayList<TypeLiteral>(); .)
  = typeLiteral<out TypeLiteral t0>                             (. var resultType = t0; .)
    [{
      SYM_MUL
      typeLiteral<out TypeLiteral argType>                      (. argTypes.add(argType); .)
    }
    SYM_ARROW
    typeLiteral<out TypeLiteral t1>                             (. argTypes.add(0, resultType); resultType = t1; .) // switch result types
    ]                                                           (. type = new RegisterDefinition.RelationTypeLiteral(argTypes, resultType); .)
  .

  aliasDefinition<out Definition def>                 (. var startLocation = nextTokenLoc(); AliasDefinition.AliasKind kind = null;
                                                         TypeLiteral aliasType = null; TypeLiteral targetType = null;
                                                         IdentifierOrPlaceholder id = null;
                                                      .)
  = ALIAS
    (
      REGISTER                                        (. kind = AliasDefinition.AliasKind.REGISTER; .)
      identifierOrPlaceholder<out id>
      // FIXME: This should probably use the same relationType as the register definition
      [
        SYM_COLON
        typeLiteral<out aliasType>
        [
          SYM_ARROW
          typeLiteral<out targetType>
        ]
      ]
    | PROGRAM COUNTER                                 (. kind = AliasDefinition.AliasKind.PROGRAM_COUNTER; .)
      identifierOrPlaceholder<out id>
      [
        SYM_COLON
        typeLiteral<out aliasType>
      ]
    )
    SYM_EQ
    callOrBinaryExpression<out Expr value, false>     (. def = new AliasDefinition(id, kind, aliasType, targetType, value, startLocation.join(lastTokenLoc())); .)
  .

  usingDefinition<out Definition def>                         (. var start = nextTokenLoc(); .)
  = USING
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_EQ
    typeLiteral<out TypeLiteral type>                         (. def = new UsingDefinition(id, type, start.join(lastTokenLoc())); .)
  .

  functionDefinition<out Definition def> (. var start = nextTokenLoc(); List<Parameter> params = new ArrayList<>(); .)
  = FUNCTION
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    [ parameters<out params> ]
    SYM_ARROW
    typeLiteral<out TypeLiteral retType>
    SYM_EQ
    expression<out Expr expr, BIN_OPS> (. def = new FunctionDefinition(name, params, retType, expr, start.join(lastTokenLoc())); .)
  .

  parameters<.out List<Parameter> params.>
  = SYM_PAREN_OPEN                  (. params = new ArrayList<>(); .)
    parameter<out Parameter param>  (. params.add(param); .)
    {
      SYM_COMMA
      parameter<out Parameter next> (. params.add(next); .)
    }
    SYM_PAREN_CLOSE
  .

  parameter<out Parameter param>
  = identifier<out Identifier name>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. param = new Parameter(name, type); .)
  .

  enumerationDefinition<out Definition def> (. var start = nextTokenLoc(); TypeLiteral enumType = null; .)
  = ENUMERATION
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ SYM_COLON typeLiteral<out enumType> ]
    SYM_EQ                                  (. var entries = new ArrayList<EnumerationDefinition.Entry>(); .)
    SYM_BRACE_OPEN                          (. Expr value = null; .)
    identifier<out Identifier name>
    [
      SYM_EQ
      expression<out value, BIN_OPS>
    ]                                       (. entries.add(new EnumerationDefinition.Entry(name, value)); .)
    {                                       (. value = null; .)
      SYM_COMMA
      identifier<out name>
      [
        SYM_EQ
        expression<out value, BIN_OPS>
      ]                                     (. entries.add(new EnumerationDefinition.Entry(name, value)); .)
    }
    SYM_BRACE_CLOSE                         (. def = new EnumerationDefinition(id, enumType, entries, start.join(lastTokenLoc())); .)
  .

  exceptionDefinition<out Definition def> (. var start = nextTokenLoc(); List<Parameter> params = new ArrayList<>(); .)
  = EXCEPTION
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [ parameters<out params> ]
    SYM_EQ
    statement<out Statement statement> (. def = new ExceptionDefinition(id, params, statement, start.join(lastTokenLoc())); .)
  .

  recordDefinition<out RecordTypeDefinition def> (. var start = nextTokenLoc(); .)
  = RECORD
    identifier<out Identifier recordName>
    SYM_PAREN_OPEN
    identifier<out Identifier paramName>
    SYM_COLON                       (. var entries = new ArrayList<RecordType.Entry>(); .)
    syntaxType<out SyntaxType type> (. entries.add(new RecordType.Entry(paramName.name, type)); .)
    {
      SYM_COMMA
      identifier<out paramName>
      SYM_COLON
      syntaxType<out type>          (. entries.add(new RecordType.Entry(paramName.name, type)); .)
    }                               (. var recordType = new RecordType(recordName.name, entries); .)
    SYM_PAREN_CLOSE                 (. def = new RecordTypeDefinition(recordName, recordType, start.join(lastTokenLoc()));
                                       macroTable.defineSymbol(def); .)
  .

  modelTypeDefinition<out ModelTypeDefinition def> (. var start = nextTokenLoc(); .)
  = MODEL_TYPE
    identifier<out Identifier name>
    SYM_EQ
    projectionType<out ProjectionType type> (. def = new ModelTypeDefinition(name, type, start.join(lastTokenLoc()));
                                               macroTable.defineSymbol(def); .)
  .

  importDefinition<out Definition def>     (. var start = nextTokenLoc(); var importPaths = new ArrayList<IsId>(); Identifier fileId = null; StringLiteral filePath = null; .)
  = IMPORT
    ( identifier<out fileId>
    | stringLiteral<out filePath>
    )                                      (. var segments = new ArrayList<Identifier>(); .)
    {
      IF (la.kind == _SYM_NAMESPACE && scanner.Peek().kind != _SYM_BRACE_OPEN)
      SYM_NAMESPACE
      identifier<out Identifier segment>   (. segments.add(segment); .)
    }                                      (. var symbolList = new ArrayList<List<Identifier>>(); .)
    [
      SYM_NAMESPACE
      SYM_BRACE_OPEN                       (. var list = new ArrayList<Identifier>(); .)
      identifier<out Identifier symbol>    (. list.add(symbol); .)
      {
        SYM_NAMESPACE
        identifier<out symbol>             (. list.add(symbol); .)
      }                                    (. symbolList.add(List.copyOf(list)); .)
      {
        SYM_COMMA                          (. list.clear(); .)
        identifier<out symbol>             (. list.add(symbol); .)
        {
          SYM_NAMESPACE
          identifier<out symbol>           (. list.add(symbol); .)
        }                                  (. symbolList.add(List.copyOf(list)); .)
      }
      SYM_BRACE_CLOSE
    ]                                      (. var args = new ArrayList<StringLiteral>(); .)
    [
      WITH
      SYM_PAREN_OPEN
      stringLiteral<out StringLiteral arg> (. args.add(arg); .)
      {
        SYM_COMMA
        stringLiteral<out arg>             (. args.add(arg); .)
      }
      SYM_PAREN_CLOSE
    ]                                      (. def = importModules(this, fileId, filePath, importedSymbols(segments, symbolList), args, start.join(lastTokenLoc())); .)
  .

  processDefinition<out Definition def>   (. var start = nextTokenLoc();
                                             List<TemplateParam> templateParams = new ArrayList<>();
                                             List<Parameter> inputs = new ArrayList<>();
                                             List<Parameter> outputs = new ArrayList<>(); .)
    = PROCESS
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    [ processTemplateParameters<.out templateParams.> ]
    [ parameters<.out inputs.> ]
    [ SYM_ARROW parameters<.out outputs.> ]
    SYM_EQ
    statement<out Statement stmt> (. def = new ProcessDefinition(name, templateParams, inputs, outputs, stmt, start.join(lastTokenLoc())); .)
  .

  processTemplateParameters<.out List<TemplateParam> templateParams.>
  = SYM_LT                            (. templateParams = new ArrayList<>(); .)
    identifier<out Identifier id>
    SYM_COLON
    typeLiteral<out TypeLiteral type> (. Expr value = null; .)
    [
      SYM_EQ
      expression<out value, BIN_OPS_EXCEPT_GT>
    ]                                 (. templateParams.add(new TemplateParam(id, type, value)); .)
    {
        identifier<out id>
        SYM_COLON
        typeLiteral<out type>         (. value = null; .)
        [
          SYM_EQ
          expression<out value, BIN_OPS_EXCEPT_GT>
        ]                             (. templateParams.add(new TemplateParam(id, type, value)); .)
    }
    SYM_GT
  .

  operationDefinition<out Definition def>  (. var start = nextTokenLoc(); .)
  = OPERATION
    identifierOrPlaceholder<out IdentifierOrPlaceholder name>
    SYM_EQ
    SYM_BRACE_OPEN                  (. var resources = new ArrayList<IsId>(); .)
    [
      identifierPath<out IsId path> (. resources.add(path); .)
      {
        SYM_COMMA
        identifierPath<out path>    (. resources.add(path); .)
      }
    ]
    SYM_BRACE_CLOSE                 (. def = new OperationDefinition(name, resources, start.join(lastTokenLoc())); .)
  .

  groupDefinition<out Definition def>     (.  var start = nextTokenLoc(); TypeLiteral type = null; .)
  = GROUP
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [
      SYM_COLON
      typeLiteral<out type>
    ]
    SYM_EQ
    groupSequence<out Group.Sequence seq> (. def = new GroupDefinition(id, type, seq, start.join(lastTokenLoc())); .)
  .

  groupSequence<out Group.Sequence seq> (. var groups = new ArrayList<Group>(); var start = nextTokenLoc(); .)
  = group<out Group group>              (. groups.add(group); .)
    {
      SYM_DOT
      group<out group>                  (. groups.add(group); .)
    }                                   (. seq = new Group.Sequence(groups, start.join(lastTokenLoc())); .)
  .

  group<out Group group> (. group = null; .)
  = groupLiteral<out group>
  | groupAlternative<out group>
  | groupPermutation<out group>
  .

  groupLiteral<out Group group>                         (. var start = nextTokenLoc(); Expr size = null; .)
  = identifierPath<out IsId path>
    [
      SYM_LT
      expression<out size, BIN_OPS_EXCEPT_GT>
      [
        SYM_RANGE
        expression<out Expr rangeTo, BIN_OPS_EXCEPT_GT> (. size = new RangeExpr(size, rangeTo); .)
      ]
      SYM_GT
    ]                                                   (. group = new Group.Literal(path, size, start.join(lastTokenLoc())); .)
  .

  groupAlternative<out Group group>       (. var start = nextTokenLoc(); var sequences = new ArrayList<Group.Sequence>(); .)
  = SYM_PAREN_OPEN
    groupSequence<out Group.Sequence seq> (. sequences.add(seq); .)
    {
      SYM_BINOR
      groupSequence<out seq>              (. sequences.add(seq); .)
    }
    SYM_PAREN_CLOSE                       (. group = new Group.Alternative(sequences, start.join(lastTokenLoc())); .)
  .

  groupPermutation<out Group group>       (. var start = nextTokenLoc(); var sequences = new ArrayList<Group.Sequence>(); .)
  = SYM_BRACE_OPEN
    groupSequence<out Group.Sequence seq> (. sequences.add(seq); .)
    {
      SYM_COMMA
      groupSequence<out seq>              (. sequences.add(seq); .)
    }
    SYM_BRACE_CLOSE                       (. group = new Group.Permutation(sequences, start.join(lastTokenLoc())); .)
  .

  // -- ABI DEFINITIONS-----------------------------------------------------------------------------------------------

  applicationBinaryInterfaceDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  = APPLICATION  BINARY INTERFACE
    identifier<out Identifier id>
    FOR
    identifierPath<out IsId isaPath>
    SYM_EQ
    SYM_BRACE_OPEN                              (. var elements = new ArrayList<Definition>(); .)
    {
      abiElementDefinition<out Definition elem> (. addDef(elements, elem); .)
    }
    SYM_BRACE_CLOSE                             (. def = new ApplicationBinaryInterfaceDefinition(id, isaPath, elements, start.join(lastTokenLoc())); .)
  .

  abiElementDefinition<out Definition def>   (. def = DUMMY_DEF; .)
  = annotations<.out List<AnnotationDefinition> annotations.> (. var peek = scanner.Peek(); .)
    ( specialPurposeRegisterSingleDef<out def>
    | aliasDefinition<out def>
    | abiSpecialPurposeInstructionDefinition<out def>
    | abiSequenceDef<out def>
    | clangTypeDefinition<out def>
    | clangNumericTypeDefinition<out def>
  )                                        (. def.withAnnotations(annotations); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>             (. def = castCommonDef(this, n);
                                                if (def instanceof DefinitionList list) {
                                                  readMacroSymbols(macroTable, list.items);
                                                } .)
  .

  clangTypeDefinition<out Definition def>                     (. def = DUMMY_DEF; var startLoc = nextTokenLoc(); .)
  =
  (
    SIZE_T TYPE SYM_EQ typeSizeDefinition<out AbiClangTypeDefinition.TypeSize size1> (. def = new AbiClangTypeDefinition(AbiClangTypeDefinition.TypeName.SIZE_TYPE, size1, startLoc.join(lastTokenLoc())); .)
    | INT MAX TYPE SYM_EQ typeSizeDefinition<out AbiClangTypeDefinition.TypeSize size2> (. def = new AbiClangTypeDefinition(AbiClangTypeDefinition.TypeName.INT_MAX_TYPE, size2, startLoc.join(lastTokenLoc())); .)
  )
  .

  clangNumericTypeDefinition<out Definition def>    (. def = DUMMY_DEF; var startLoc = nextTokenLoc(); AbiClangNumericTypeDefinition.TypeName typeName = null; .)
  =
  (
    POINTER (
         WIDTH                                      (. typeName = AbiClangNumericTypeDefinition.TypeName.POINTER_WIDTH; .)
      |  ALIGN                                      (. typeName = AbiClangNumericTypeDefinition.TypeName.POINTER_ALIGN; .)
    )
    | LONG (
         WIDTH                                      (. typeName = AbiClangNumericTypeDefinition.TypeName.LONG_WIDTH; .)
      |  ALIGN                                      (. typeName = AbiClangNumericTypeDefinition.TypeName.LONG_ALIGN; .)
    )
  )
  SYM_EQ expression<out Expr expr, BIN_OPS>         (. def = new AbiClangNumericTypeDefinition(typeName, expr, startLoc.join(lastTokenLoc())); .)
  .

  // See https://clang.llvm.org/doxygen/structclang_1_1TransferrableTargetInfo.html#a30e275c7308708d1b55cd9d009265e33
  typeSizeDefinition<out AbiClangTypeDefinition.TypeSize def> (. def = null; .)
  =
  (
    UNSIGNED (
        INT                                            (. def = AbiClangTypeDefinition.TypeSize.UNSIGNED_INT; .)
      | LONG                                           (. def = AbiClangTypeDefinition.TypeSize.UNSIGNED_LONG; .)
    )
    | SIGNED (
        INT                                            (. def = AbiClangTypeDefinition.TypeSize.SIGNED_INT; .)
      | LONG                                           (. def = AbiClangTypeDefinition.TypeSize.SIGNED_LONG; .)
    )
  )
  .

  specialPurposeRegisterSingleDef<out Definition def>        (. var start = nextTokenLoc(); .)
  =                                                          (. SpecialPurposeRegisterDefinition.Purpose purpose = null; .)
  (
  RETURN (
    ADDRESS                                                  (. purpose = SpecialPurposeRegisterDefinition.Purpose.RETURN_ADDRESS; .)
    | VALUE                                                  (. purpose = SpecialPurposeRegisterDefinition.Purpose.RETURN_VALUE; .)
    )
  | STACK POINTER                                            (. purpose = SpecialPurposeRegisterDefinition.Purpose.STACK_POINTER; .)
  | GLOBAL POINTER                                           (. purpose = SpecialPurposeRegisterDefinition.Purpose.GLOBAL_POINTER; .)
  | FRAME POINTER                                            (. purpose = SpecialPurposeRegisterDefinition.Purpose.FRAME_POINTER; .)
  | THREAD POINTER                                           (. purpose = SpecialPurposeRegisterDefinition.Purpose.THREAD_POINTER; .)
  | CALLER SAVED                                             (. purpose = SpecialPurposeRegisterDefinition.Purpose.CALLER_SAVED; .)
  | CALLEE SAVED                                             (. purpose = SpecialPurposeRegisterDefinition.Purpose.CALLEE_SAVED; .)
  | FUNCTION ARGUMENT                                        (. purpose = SpecialPurposeRegisterDefinition.Purpose.FUNCTION_ARGUMENT; .)
  )
  SYM_EQ
  sequenceCallExprList<.out List<ExpandedSequenceCallExpr> calls.> (. def = new SpecialPurposeRegisterDefinition(purpose, calls, start.join(lastTokenLoc())); .)
  .

  abiSpecialPurposeInstructionDefinition<out Definition def>         (. var start = nextTokenLoc(); .)
  =                                                          (. AbiSpecialPurposeInstructionDefinition.Kind kind = null; .)
  SPECIAL
  (
    RETURN INSTRUCTION                                       (. kind = AbiSpecialPurposeInstructionDefinition.Kind.RETURN; .)
    | CALL INSTRUCTION                                       (. kind = AbiSpecialPurposeInstructionDefinition.Kind.CALL; .)
    | LOCAL ADDRESS LOAD INSTRUCTION                         (. kind = AbiSpecialPurposeInstructionDefinition.Kind.LOCAL_ADDRESS_LOAD; .)
    | GLOBAL ADDRESS LOAD INSTRUCTION                        (. kind = AbiSpecialPurposeInstructionDefinition.Kind.GLOBAL_ADDRESS_LOAD; .)
    | ABSOLUTE ADDRESS LOAD INSTRUCTION                      (. kind = AbiSpecialPurposeInstructionDefinition.Kind.ABSOLUTE_ADDRESS_LOAD; .)
  )
  SYM_EQ
  identifier<out Identifier id>  (. def = new AbiSpecialPurposeInstructionDefinition(kind, id, start.join(lastTokenLoc())); .)
  .

  abiSequenceDef<out Definition def>                         (. var start = nextTokenLoc(); .)
  =                                                          (. AbiSequenceDefinition.SeqKind kind = null; .)
  (
    CONSTANT                                                 (. kind = AbiSequenceDefinition.SeqKind.CONSTANT; .)
    | REGISTER ADJUSTMENT                                    (. kind = AbiSequenceDefinition.SeqKind.REGISTER; .)
  )
  SEQUENCE                                                   (. List<Parameter> params = new ArrayList<>(); .)
  [ parameters<.out params.> ]
  SYM_EQ
  SYM_BRACE_OPEN                                             (. var stmts = new ArrayList<InstructionCallStatement>(); .)
  {
    instructionCallStmt<out InstructionCallStatement stmt>   (. stmts.add(stmt); .)
  }
  SYM_BRACE_CLOSE                                            (. def = new AbiSequenceDefinition(kind, params, stmts, start.join(lastTokenLoc())); .)
  .


  // -- CPU DEFINITIONS-----------------------------------------------------------------------------------------------
  processorDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  = PROCESSOR
    identifier<out Identifier id>
    IMPLEMENTS
    identifierPath<out IsId isa>           (. IsId abi = null; .)
    [
      WITH
      identifierPath<out IsId abiId>       (. abi = abiId; .)
    ]
    SYM_EQ
    SYM_BRACE_OPEN                         (. var definitions = new ArrayList<Definition>(); .)
    {
      cpuDefinition<out Definition cpuDef> (. addDef(definitions, cpuDef); .)
    }
    SYM_BRACE_CLOSE                        (. def = new ProcessorDefinition(id, isa, abi, definitions, start.join(lastTokenLoc())); .)
  .

  cpuDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<.out List<AnnotationDefinition> annotations.>
    ( commonDefinition<out def>
    | memoryRegionDefinition<out def>
    | patchDefinition<out def>
    | sourceDefinition<out def>
    | exceptionDefinition<out def>
    | cpuFunctionDefinition<out def>
    | cpuProcessDefinition<out def>
    )                               (. def.withAnnotations(annotations); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>    (. def = castCommonDef(this, n);
                                       if (def instanceof DefinitionList list) {
                                         readMacroSymbols(macroTable, list.items);
                                       } .)
  .

  // memory region [ROM] MROM in MEM = {...}
  memoryRegionDefinition<out Definition def>  (. var start = nextTokenLoc(); CpuMemoryRegionDefinition.MemKind kind = null; .)
  =                                           (. Statement stmt = null; .)
    MEMORY REGION
    SYM_BRACK_OPEN
    ( RAM                                     (. kind = CpuMemoryRegionDefinition.MemKind.RAM; .)
    | ROM                                     (. kind = CpuMemoryRegionDefinition.MemKind.ROM; .)
    )
    SYM_BRACK_CLOSE
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_IN identifierPath<out IsId mem>
    [ SYM_EQ statement<out stmt> ]         (. def = new CpuMemoryRegionDefinition(id, kind, mem, stmt, start.join(lastTokenLoc())); .)
  .

  patchDefinition<out Definition def>     (. var start = nextTokenLoc(); .)
  = PATCH
    identifier<out Identifier generator>
    identifier<out Identifier handle>
    SYM_EQ                                (. IsId reference = null; String source = null; .)
    ( identifierPath<out reference>
    | sourceLiteral<out source> )         (. def = new PatchDefinition(generator, handle, reference, source, start.join(lastTokenLoc())); .)
  .

  sourceDefinition<out Definition def>  (. var start = nextTokenLoc(); .)
  = SOURCE
    identifier<out Identifier id>
    SYM_EQ
    sourceLiteral<out String source>    (. def = new SourceDefinition(id, source, start.join(lastTokenLoc())); .)
  .

  sourceLiteral<out String source>
  = embeddedSource (. source = t.val.substring(3, t.val.length() - 3); .)
  .

  cpuFunctionDefinition<out Definition def> (. var start = nextTokenLoc(); Identifier ident = null;.)
  =                                         (. CpuFunctionDefinition.BehaviorKind kind = null; IsId stopWithRef = null; .)
  ( STOP                                    (. ident = new Identifier(t.val, lastTokenLoc()); kind = CpuFunctionDefinition.BehaviorKind.STOP; .)
    [ WITH referenceLiteral<out stopWithRef> ]
    /* TODO Verify if "redirect" is needed - "redirect is unstable and must not be used"
    | REDIRECT
      parameters<out redirectParams>
      SYM_ARROW
      typeLiteral<out redirectType>
    */
  )
    SYM_EQ
    expression<out Expr expr, BIN_OPS>      (. def = new CpuFunctionDefinition(ident, kind, stopWithRef, expr, start.join(lastTokenLoc())); .)
  .

  cpuProcessDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  =                                        (. CpuProcessDefinition.ProcessKind kind = null; List<Parameter> outputs = List.of(); .)
  ( RESET                                (. kind = CpuProcessDefinition.ProcessKind.RESET; .)
    [ SYM_ARROW
    parameters<out outputs> ]
  )
    SYM_EQ
    statement<out Statement stmt>          (. def = new CpuProcessDefinition(kind, outputs, stmt, start.join(lastTokenLoc())); .)
  .

  // -- MiA DEFINITIONS-----------------------------------------------------------------------------------------------

  microArchitectureDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  = MICRO ARCHITECTURE
    identifier<out Identifier id>
    IMPLEMENTS
    identifierPath<out IsId processor>
    SYM_EQ
    SYM_BRACE_OPEN                        (. var definitions = new ArrayList<Definition>(); .)
    {
      miaDefinition<out Definition child> (. addDef(definitions, child); .)
    }
    SYM_BRACE_CLOSE                       (. def = new MicroArchitectureDefinition(id, processor, definitions, start.join(lastTokenLoc())); .)
  .

  miaDefinition<out Definition def> (. def = DUMMY_DEF; .)
  = annotations<.out List<AnnotationDefinition> annotations.>
    ( macroInstructionDefinition<out def>
    | portBehaviorDefinition<out def>
    | pipelineDefinition<out def>
    | stageDefinition<out def>
    | cacheDefinition<out def>
    | logicDefinition<out def>
    | signalDefinition<out def>
    | memoryDefinition<out def>
    | registerDefinition<out def>     // TODO Pass type MIA_DEFS - currently only ISA_DEFS
    | processDefinition<out def>
    | operationDefinition<out def>
    | commonDefinition<out def>
    )                               (. def.withAnnotations(annotations); .)
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.COMMON_DEFS))
    macroReplacement<out Node n>    (. def = castCommonDef(this, n);
                                       if (def instanceof DefinitionList list) {
                                         readMacroSymbols(macroTable, list.items);
                                       } .)
  .

  macroInstructionDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  =                                              (. MacroInstructionDefinition.MacroBehaviorKind kind = null; List<Parameter> inputs = List.of(); .)
  ( TRANSLATION                                  (. kind = MacroInstructionDefinition.MacroBehaviorKind.TRANSLATION; .)
  | PREDICTION                                   (. kind = MacroInstructionDefinition.MacroBehaviorKind.PREDICTION; .)
  | FETCH                                        (. kind = MacroInstructionDefinition.MacroBehaviorKind.FETCH; .)
  | DECODER                                      (. kind = MacroInstructionDefinition.MacroBehaviorKind.DECODER; .)
  | STARTUP                                      (. kind = MacroInstructionDefinition.MacroBehaviorKind.STARTUP; .)
  )
    [ parameters<out inputs> ]
    SYM_ARROW
    parameters<.out List<Parameter> outputs.>
    SYM_EQ
    statement<out Statement stmt>                (. def = new MacroInstructionDefinition(kind, inputs, outputs, stmt, start.join(lastTokenLoc())); .)
  .

  portBehaviorDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  =                                          (. PortBehaviorDefinition.PortKind kind = null; .)
  ( READ                                     (. kind = PortBehaviorDefinition.PortKind.READ; .)
  | WRITE                                    (. kind = PortBehaviorDefinition.PortKind.WRITE; .)
  | HIT                                      (. kind = PortBehaviorDefinition.PortKind.HIT; .)
  | MISS                                     (. kind = PortBehaviorDefinition.PortKind.MISS; .)
  )
    identifier<out Identifier id>
    parameters<.out List<Parameter> inputs.>
    SYM_ARROW
    parameters<.out List<Parameter> outputs.>
    SYM_EQ
    statement<out Statement stmt>            (. def = new PortBehaviorDefinition(id, kind, inputs, outputs, stmt, start.join(lastTokenLoc())); .)
  .

  pipelineDefinition<out Definition def>  (. var start = nextTokenLoc(); .)
  = PIPELINE
    identifier<out Identifier id> (. List<Parameter> outputs = List.of(); .)
    [ SYM_ARROW parameters<out outputs> ]
    SYM_EQ
    statement<out Statement stmt> (. def = new PipelineDefinition(id, outputs, stmt, start.join(lastTokenLoc())); .)
  .

  stageDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  = STAGE
    identifier<out Identifier id> (. List<Parameter> outputs = List.of(); .)
    [ SYM_ARROW parameters<out outputs> ]
    SYM_EQ
    statement<out Statement stmt> (. def = new StageDefinition(id, outputs, stmt, start.join(lastTokenLoc())); .)
  .

  cacheDefinition<out Definition def>       (. var start = nextTokenLoc(); .)
  = CACHE
    identifier<out Identifier id>
    SYM_COLON
    typeLiteral<out TypeLiteral sourceType>
    SYM_ARROW
    typeLiteral<out TypeLiteral targetType> (. def = new CacheDefinition(id, sourceType, targetType, start.join(lastTokenLoc())); .)
  .

  logicDefinition<out Definition def> (. var start = nextTokenLoc(); .)
  = LOGIC
    identifier<out Identifier id> (. def = new LogicDefinition(id, start.join(lastTokenLoc())); .)
  .

  signalDefinition<out Definition def>  (. var start = nextTokenLoc(); .)
  = SIGNAL
    identifier<out Identifier id>
    SYM_COLON
    typeLiteral<out TypeLiteral type>   (. def = new SignalDefinition(id, type, start.join(lastTokenLoc())); .)
  .


  // -- ASM DEFINITIONS-----------------------------------------------------------------------------------------------

  assemblyDescriptionDefinition<out AsmDescriptionDefinition asmDescription>    (. List<AsmModifierDefinition> modifiers = new ArrayList<>(); var start = nextTokenLoc(); .)
  = ASSEMBLY DESCRIPTION                                                        (. List<AsmDirectiveDefinition> directives = new ArrayList<>(); .)
    assemblyIdentifier<out Identifier id>                                       (. List<AsmGrammarRuleDefinition> rules = new ArrayList<>(); var commonDefs = new ArrayList<Definition>(); .)
    FOR
    assemblyIdentifier<out Identifier abi>
    SYM_EQ
    SYM_BRACE_OPEN
      { assemblyModifiersDefinition<out modifiers>
      | assemblyDirectivesDefinition<out directives>
      | assemblyGrammarDefinition<out rules>
      | assemblyCommonDefinition<out Definition def>                            (. commonDefs.add(def); .)
      }
    SYM_BRACE_CLOSE                                                             (. asmDescription = new AsmDescriptionDefinition(id, abi, modifiers, directives, rules, commonDefs, start.join(lastTokenLoc())); .)
  .

  assemblyCommonDefinition<out Definition def>                                    (. def = DUMMY_DEF; .)
  = constantDefinition<out def>
  | usingDefinition<out def>
  | functionDefinition<out def>
  .

  assemblyModifiersDefinition<.out List<AsmModifierDefinition> modifiers.>        (. modifiers = new ArrayList<>(); .)
  = MODIFIERS
    SYM_EQ
    SYM_BRACE_OPEN
      assemblyModifierDefinition<out AsmModifierDefinition first>                 (. modifiers.add(first); .)
      { SYM_COMMA assemblyModifierDefinition<out AsmModifierDefinition other>     (. modifiers.add(other); .)
      }
    SYM_BRACE_CLOSE
  .

  assemblyModifierDefinition<out AsmModifierDefinition modifier>            (. var start = nextTokenLoc(); .)
  = stringLiteral<out Expr strLit>
    SYM_ARROW
    assemblyIdentifier<out Identifier isaId>
    SYM_NAMESPACE
    assemblyIdentifier<out Identifier modifierId>                           (. modifier = new AsmModifierDefinition(strLit, isaId, modifierId, start.join(lastTokenLoc())); .)
  .

  assemblyDirectivesDefinition<.out List<AsmDirectiveDefinition> directives.>       (. directives = new ArrayList<>(); .)
  = DIRECTIVES
    SYM_EQ
    SYM_BRACE_OPEN
      assemblyDirectiveDefinition<out AsmDirectiveDefinition first>                 (. directives.add(first); .)
      { SYM_COMMA assemblyDirectiveDefinition<out AsmDirectiveDefinition other>     (. directives.add(other); .)
      }
    SYM_BRACE_CLOSE
  .

  assemblyDirectiveDefinition<out AsmDirectiveDefinition definition>        (. var start = nextTokenLoc(); .)
  = stringLiteral<out Expr strLit>
    SYM_ARROW
    assemblyIdentifier<out Identifier id>                                   (. definition = new AsmDirectiveDefinition(strLit, id, start.join(lastTokenLoc())); .)
  .

  assemblyGrammarDefinition<.out List<AsmGrammarRuleDefinition> rules.>         (. rules = new ArrayList<>(); .)
     = GRAMMAR
       SYM_EQ
       SYM_BRACE_OPEN
         assemblyGrammarRuleDefinition<out AsmGrammarRuleDefinition first>      (. rules.add(first); .)
         { assemblyGrammarRuleDefinition<out AsmGrammarRuleDefinition other>    (. rules.add(other); .)
         }
       SYM_BRACE_CLOSE
     .

  assemblyGrammarRuleDefinition<out AsmGrammarRuleDefinition rule>                          (. AsmGrammarTypeDefinition type = null; var start = nextTokenLoc(); .)
  = assemblyIdentifier<out Identifier id> [assemblyGrammarTypeDefinition<out type>]
    SYM_COLON
      assemblyGrammarAlternatives<.out AsmGrammarAlternativesDefinition alternatives.>
    SYM_SEMICOLON                                                                           (. rule = new AsmGrammarRuleDefinition(id, type, alternatives, start.join(lastTokenLoc())); .)
  .

  assemblyGrammarTypeDefinition<out AsmGrammarTypeDefinition type>    (. var start = nextTokenLoc(); .)
  = SYM_AT assemblyIdentifier<out Identifier id>                      (. type = new AsmGrammarTypeDefinition(id, start.join(lastTokenLoc())); .)
  .

  assemblyGrammarAlternatives<.out AsmGrammarAlternativesDefinition alternatives.>        (. var altList = new ArrayList<List<AsmGrammarElementDefinition>>(); var start = nextTokenLoc(); .)
  = assemblyGrammarElements<.out List<AsmGrammarElementDefinition> first.>                (. altList.add(first);.)
    {SYM_BINOR assemblyGrammarElements<.out List<AsmGrammarElementDefinition> other.>     (. altList.add(other); .)
    }                                                                                     (. alternatives = new AsmGrammarAlternativesDefinition(altList, start.join(lastTokenLoc())); .)
  .

  assemblyGrammarElements<.out List<AsmGrammarElementDefinition> elements.>     (. elements = new ArrayList<>(); .)
  = assemblyGrammarElement<out AsmGrammarElementDefinition element>             (. elements.add(element); .)
    { assemblyGrammarElement<out AsmGrammarElementDefinition furtherElement>    (. elements.add(furtherElement); .)
    }
  .

  assemblyGrammarElement<out AsmGrammarElementDefinition element>    (. AsmGrammarLocalVarDefinition localVar = null; Identifier id = null; Boolean isPlusEq = false; var start = nextTokenLoc();
                                                                        List<AsmGrammarLiteralDefinition> params = new ArrayList<>(); AsmGrammarLiteralDefinition asmLiteral = null;
                                                                        AsmGrammarAlternativesDefinition groupAlternatives = null; AsmGrammarAlternativesDefinition optionAlternatives = null;
                                                                        AsmGrammarAlternativesDefinition repetitionAlternatives = null;AsmGrammarTypeDefinition type = null; Expr semanticPred = null; .)
  = (
      assemblyLocalVarDeclaration<out localVar>
    | assemblyIdentifier<out id>
        [ ( SYM_PLUS_EQ  (. isPlusEq = true; .)  | SYM_EQ)
            ( assemblyGrammarLiteral<out asmLiteral>
             | assemblyGrammarGroup<out groupAlternatives> )
          | SYM_LT assemblyParameterList<out params>  SYM_GT
        ] [assemblyGrammarTypeDefinition<out type>]                  (. if(asmLiteral == null && groupAlternatives == null) {
                                                                          asmLiteral = new AsmGrammarLiteralDefinition(id, params, null, type, start.join(lastTokenLoc()));
                                                                          id = null; type = null; } .)
    | assemblyGrammarGroup<out groupAlternatives>
    | assemblyGrammarOptional<out optionAlternatives>
    | assemblyGrammarRepetition<out repetitionAlternatives>
    | SYM_QUESTION SYM_PAREN_OPEN
      callOrBinaryExpression<out semanticPred, false>
      SYM_PAREN_CLOSE
    | stringLiteral<out Expr strLit>
      [assemblyGrammarTypeDefinition<out type>]                      (. asmLiteral = new AsmGrammarLiteralDefinition(null, new ArrayList<>(), strLit, type, start.join(lastTokenLoc())); type = null;.)
  )                                                                  (. element =  new AsmGrammarElementDefinition(localVar, id, isPlusEq, asmLiteral, groupAlternatives,
                                                                                    optionAlternatives, repetitionAlternatives, semanticPred, type, start.join(lastTokenLoc())); .)
  .

  assemblyLocalVarDeclaration<out AsmGrammarLocalVarDefinition localVar> (. var start = nextTokenLoc(); .)
  = VAR
    assemblyIdentifier<out Identifier id>
    SYM_EQ
    assemblyGrammarLiteral<out AsmGrammarLiteralDefinition asmLiteral>  (. localVar = new AsmGrammarLocalVarDefinition(id, asmLiteral, start.join(lastTokenLoc())); .)
  .

  assemblyGrammarLiteral<out AsmGrammarLiteralDefinition literal>       (. Identifier id = null; List<AsmGrammarLiteralDefinition> parameters = new ArrayList<>();
                                                                           Expr strLit = null; AsmGrammarTypeDefinition type = null; .)
  = ( assemblyIdentifier<out id>
        [                                                               (. nextLaShouldBeGT = true; .)
          SYM_ROTR
          | SYM_LT assemblyParameterList<out parameters>
           (                                                            (. nextLaShouldBeGT = true; .)
             SYM_SHR | SYM_GT )
        ]
      | stringLiteral<out strLit> )                                     (. var start =  id != null ? id.location() : strLit.location(); .)
    [IF(la.kind == _SYM_AT)
      assemblyGrammarTypeDefinition<out type>]                          (. literal = new AsmGrammarLiteralDefinition(id, parameters, strLit, type, start.join(lastTokenLoc())); .)
  .

  assemblyParameterList<.out List<AsmGrammarLiteralDefinition> parameters.>               (. parameters = new ArrayList<>();  .)
  = [ assemblyGrammarLiteral<out AsmGrammarLiteralDefinition literal>                     (. parameters.add(literal); .)
      { SYM_COMMA assemblyGrammarLiteral<out AsmGrammarLiteralDefinition furtherLiteral>  (. parameters.add(furtherLiteral); .)
      }
    ]
  .

  assemblyGrammarGroup<out AsmGrammarAlternativesDefinition alternatives>
  = SYM_PAREN_OPEN
      assemblyGrammarAlternatives<.out alternatives.>
    SYM_PAREN_CLOSE
  .

  assemblyGrammarOptional<out AsmGrammarAlternativesDefinition alternatives>
  = SYM_BRACK_OPEN
      assemblyGrammarAlternatives<.out alternatives.>
    SYM_BRACK_CLOSE
  .

  assemblyGrammarRepetition<out AsmGrammarAlternativesDefinition alternatives>
  = SYM_BRACE_OPEN
    assemblyGrammarAlternatives<.out alternatives.>
    SYM_BRACE_CLOSE
  .

  // -- STATEMENTS ---------------------------------------------------------------------------------------------------

  statement<out Statement statement> (. statement = DUMMY_STAT; .)
  = letStatement<out statement>
  | ifStatement<out statement>
  | blockStatement<out statement>
  | raiseStatement<out statement>
  | IF (la.kind == _MATCH && scanner.Peek().kind != _SYM_COLON)
    matchStatement<out statement>
  | IF (isMacroReplacementOfType(this, BasicSyntaxType.STAT))
    macroReplacement<out Node n>     (. statement = castStat(this, n); .)
  | assignmentOrCallStmt<out statement>
  | lockStatement<out statement>
  | forallStatement<out statement>
  .

  blockStatement<out BlockStatement block>     (. var start = nextTokenLoc(); .)
  = SYM_BRACE_OPEN
    statementList<.out List<Statement> stmts.>
    SYM_BRACE_CLOSE                            (. block = new BlockStatement(stmts, start.join(lastTokenLoc())); .)
  .

  statementList<.out List<Statement> stmts.> (. stmts = new ArrayList<>(); .)
  = {
      IF (isMacroReplacementOfType(this, BasicSyntaxType.STATS))
      macroReplacement<out Node n>           (. addStats(stmts, castStats(this, n)); .)
    | statement<out Statement statement>     (. addStats(stmts, statement); .)
    }
  .

  assignmentOrCallStmt<out Statement statement> (. statement = DUMMY_STAT; .)
  = callOrBinaryExpression<out Expr target, false>
    [
      SYM_ASSIGN
      expression<out Expr expr, BIN_OPS>        (. statement = new AssignmentStatement(target, expr); .)
    ]                                           (. if (statement.equals(DUMMY_STAT)) statement = new CallStatement(target); .)
  .

  instructionCallStmt<out InstructionCallStatement statement> (. var start = nextTokenLoc(); var namedArguments = new ArrayList<InstructionCallStatement.NamedArgument>(); .)
  = identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    [
      SYM_BRACE_OPEN
      identifier<out Identifier argName>
      SYM_EQ
      expression<out Expr argExpr, BIN_OPS>                   (. namedArguments.add(new InstructionCallStatement.NamedArgument(argName, argExpr)); .)
      {
        SYM_COMMA
        identifier<out argName>
        SYM_EQ
        expression<out argExpr, BIN_OPS>                      (. namedArguments.add(new InstructionCallStatement.NamedArgument(argName, argExpr)); .)
      }
      SYM_BRACE_CLOSE
    ]                                                         (. var unnamedArguments = new ArrayList<Expr>(); .)
    [
      SYM_PAREN_OPEN
      expression<out Expr argExpr, BIN_OPS>                   (. unnamedArguments.add(argExpr); .)
      {
        SYM_COMMA
        expression<out argExpr, BIN_OPS>                      (. unnamedArguments.add(argExpr); .)
      }
      SYM_PAREN_CLOSE
    ]                                                         (. statement = new InstructionCallStatement(id, namedArguments, unnamedArguments, start.join(lastTokenLoc())); .)
  .

  letStatement<out Statement letStatement> (. var start = nextTokenLoc(); var identifiers = new ArrayList<Identifier>(); .)
  = LET
    identifier<out Identifier id>       (. identifiers.add(id); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); .)
    }
    SYM_EQ                              (. Expr valueExpr = DUMMY_EXPR; .)
    ( IF (la.kind == _IF_KW)
      ifExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | IF (la.kind == _FORALL)
      forallExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | expression<out valueExpr, BIN_OPS_EXCEPT_IN>
    )
    SYM_IN
    statement<out Statement body>       (. letStatement = new LetStatement(identifiers, valueExpr, body, start.join(lastTokenLoc())); .)
  .

  ifStatement<out Statement ifStatement> (. Statement elseStmt = null; var start = nextTokenLoc(); .)
  = IF_KW expression<out Expr condition, BIN_OPS>
    THEN statement<out Statement thenStmt>
    [ IF (la.kind == _ELSE)
      ELSE statement<out elseStmt>
    ]                                    (. ifStatement = new IfStatement(condition, thenStmt, elseStmt, start.join(lastTokenLoc())); .)
  .

  raiseStatement<out Statement raise>  (. var start = nextTokenLoc(); .)
  = RAISE
    statement<out Statement statement> (. raise = new RaiseStatement(statement, start.join(lastTokenLoc())); .)
  .

  matchStatement<out Statement match>       (. var start = nextTokenLoc(); .)
  = MATCH
    expression<out Expr candidate, BIN_OPS> (. var cases = new ArrayList<MatchStatement.Case>(); .)
    WITH                                    (. var patterns = new ArrayList<Expr>(); .)
    SYM_BRACE_OPEN                          (. Expr pattern; .)
    ( expression<out pattern, BIN_OPS>      (. patterns.add(pattern); .)
      {
        SYM_COMMA
        expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
      }
    | SYM_BRACE_OPEN
      expression<out pattern, BIN_OPS>      (. patterns.add(pattern); .)
      {
        SYM_COMMA
        expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
      }
      SYM_BRACE_CLOSE
    )
    SYM_BIGARROW
    statement<out Statement result>         (. cases.add(new MatchStatement.Case(new ArrayList<>(patterns), result)); .)
    {
      IF (la.kind == _SYM_COMMA && scanner.Peek().kind != _SYM_UNDERSCORE)
      SYM_COMMA                             (. patterns.clear(); .)
      ( expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>  (. patterns.add(pattern); .)
        }
      | SYM_BRACE_OPEN
        expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>  (. patterns.add(pattern); .)
        }
        SYM_BRACE_CLOSE
      )
      SYM_BIGARROW
      statement<out result>                 (. cases.add(new MatchStatement.Case(new ArrayList<>(patterns), result)); .)
    }                                       (. Statement defaultResult = null; .)
    [
      SYM_COMMA
      SYM_UNDERSCORE
      SYM_BIGARROW
      statement<out defaultResult>
    ]
    SYM_BRACE_CLOSE                         (. match = new MatchStatement(candidate, cases, defaultResult, start.join(lastTokenLoc())); .)
  .

  lockStatement<out Statement lock>         (. var start = nextTokenLoc(); .)
  = LOCK
    callOrBinaryExpression<out Expr expr, false>
    SYM_IN
    statement<out Statement statement>      (. lock = new LockStatement(expr, statement, start.join(lastTokenLoc())); .)
  .

  forallStatement<out Statement forall> (. var start = nextTokenLoc(); .)
  = FORALL                              (. var indices = new ArrayList<ForallStatement.Index>(); .)
    identifier<out Identifier indexName>
    SYM_IN
    rangeExpression<out Expr domain>    (. indices.add(new ForallStatement.Index(indexName, domain)); .)
    {
      SYM_COMMA
      identifier<out indexName>
      SYM_IN
      rangeExpression<out domain>       (. indices.add(new ForallStatement.Index(indexName, domain)); .)
    }
    DO
    statement<out Statement statement>  (. forall = new ForallStatement(indices, statement, start.join(lastTokenLoc())); .)
  .

  // -- EXPRESSIONS --------------------------------------------------------------------------------------------------

  expression<out Expr expr, boolean[] allowedOps>
  = term<out expr>
    {
      IF (allowedOps[la.kind] || la.kind == _SYM_AS || isMacroReplacementOfType(this, BasicSyntaxType.BIN_OP))
      (
        binaryOperator<out Operator op>           (. var operator = new BinOp(op, lastTokenLoc()); .)
        term<out Expr right>                      (. expr = new BinaryExpr(expr, operator, right); .)
      | macroReplacement<out Node node>
        term<out Expr right>                      (. expr = new BinaryExpr(expr, castBinOp(this, node), right); .)
      | SYM_AS                                    (. var typeStart = lastTokenLoc(); .)
        identifierPath<out IsId path>             (. TypeLiteral castTarget = new TypeLiteral(path, new ArrayList<>(), typeStart.join(lastTokenLoc()));
                                                     expr = new CastExpr(expr, castTarget); .)
        { IF (expr instanceof CastExpr && la.kind == _SYM_LT)
          SYM_LT                                  (. var lessLoc = lastTokenLoc(); .)
          term<out Expr term>                     (. var isSize = false; .)
          [
            IF (!allowedOps[_SYM_LT] || la.kind == _SYM_GT) (. isSize = true; .)
            SYM_GT                                (. castTarget.sizeIndices.add(List.of(term)); .)
          ]                                       (. if (!isSize) expr = new BinaryExpr(reorderCastExpr(expr), new BinOp(Operator.Less, lessLoc), term); .)
        }                                         (. if (expr instanceof CastExpr) expr = reorderCastExpr(expr); .)
      )
    }                                             (. expr = reorderBinaryExpr(expr); .)
  .

  /// Call expressions of form "a::b<3>(1,2)(3,4).c()".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  callOrBinaryExpression<out Expr expr, boolean allowLtOp> (. expr = DUMMY_EXPR; .)
  = IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.SYM_EX))
    symbolOrBinaryExpression<out expr, allowLtOp>          (. List<CallIndexExpr.Arguments> argsIndices = new ArrayList<>(); .)
    {
      // Check if we received a symbol expression -> collect arguments
      // Otherwise, just return the collected binary expression
      IF (la.kind == _SYM_PAREN_OPEN && expr instanceof IsSymExpr)
      arguments<.out CallIndexExpr.Arguments args.>        (. argsIndices.add(args); .)
    }                                                      (. List<CallIndexExpr.SubCall> subCalls = new ArrayList<>(); .)
    {
      IF (la.kind == _SYM_DOT && expr instanceof IsSymExpr)
      SYM_DOT                                              (. var subCallArgsIndices = new ArrayList<CallIndexExpr.Arguments>(); .)
      identifier<out Identifier id>
      {
        IF (la.kind == _SYM_PAREN_OPEN)
        arguments<.out CallIndexExpr.Arguments args.>      (. subCallArgsIndices.add(args); .)
      }                                                    (. subCalls.add(new CallIndexExpr.SubCall(id, subCallArgsIndices)); .)
    }                                                      (. if (expr instanceof IsSymExpr symExpr && (!argsIndices.isEmpty() || !subCalls.isEmpty()))
                                                                expr = new CallIndexExpr(symExpr, argsIndices, subCalls, expr.location().join(lastTokenLoc()));
                                                           .)
  | macroReplacement<out Node node>                        (. expr = castExpr(this, node); .)
  .

  /// Represents one set of invocation arguments.
  /// Multiple invocations (e.g. multi-dimensional access) will need multiple #arguments
  arguments<.out CallIndexExpr.Arguments args.>    (. var start = nextTokenLoc(); .)
  = SYM_PAREN_OPEN                            (. var values = new ArrayList<Expr>(); .)
    expression<out Expr arg, BIN_OPS>         (. values.add(arg); .)
    ( SYM_RANGE
      expression<out Expr rangeTo, BIN_OPS>   (. values.set(0, new RangeExpr(arg, rangeTo)); .)
    | {
      SYM_COMMA
      expression<out Expr nextArg, BIN_OPS>   (. values.add(nextArg); .)
    })
    SYM_PAREN_CLOSE                           (. args = new CallIndexExpr.Arguments(values, start.join(lastTokenLoc())); .)
  .

  /// Symbol expressions of form "a::b<3>".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  symbolOrBinaryExpression<out Expr expr, boolean allowLtOp> (. expr = DUMMY_EXPR; .)
  = IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.ID))
    identifierPath<out IsId path>
    [
      IF (la.kind == _SYM_LT)
      SYM_LT                                                 (. var lessLoc = lastTokenLoc(); .)
      term<out Expr term>
      [
        IF (!allowLtOp || la.kind == _SYM_GT)
        SYM_GT                                               (. expr = new SymbolExpr(path, term, path.location().join(lastTokenLoc())); .)
      ]                                                      (. if (expr.equals(DUMMY_EXPR)) expr = new BinaryExpr((Expr) path, new BinOp(Operator.Less, lessLoc), term); .)
    ]                                                        (. if (expr.equals(DUMMY_EXPR)) expr = (Expr) path; .)
  | macroReplacement<out Node node>                          (. expr = castExpr(this, node); .)
  .

  binaryOperator<out Operator op> (. op = null; .)
  = SYM_BINAND                    (. op = Operator.And; .)
  | SYM_BINOR                     (. op = Operator.Or; .)
  | SYM_CARET                     (. op = Operator.Xor; .)
  | SYM_DIV                       (. op = Operator.Divide; .)
  | SYM_ELEM_OF                   (. op = Operator.ElementOf; .)
  | SYM_EQ                        (. op = Operator.Equal; .)
  | SYM_GT                        (. op = Operator.Greater; .)
  | SYM_GTE                       (. op = Operator.GreaterEqual; .)
  | SYM_IN                        (. op = Operator.In; .)
  | SYM_LOGAND                    (. op = Operator.LogicalAnd; .)
  | SYM_LOGOR                     (. op = Operator.LogicalOr; .)
  | SYM_LONG_MUL                  (. op = Operator.LongMultiply; .)
  | SYM_LT                        (. op = Operator.Less; .)
  | SYM_LTE                       (. op = Operator.LessEqual; .)
  | SYM_MINUS                     (. op = Operator.Subtract; .)
  | SYM_MOD                       (. op = Operator.Modulo; .)
  | SYM_MUL                       (. op = Operator.Multiply; .)
  | SYM_NEQ                       (. op = Operator.NotEqual; .)
  | SYM_NIN                       (. op = Operator.NotIn; .)
  | SYM_NOT_ELEM_OF               (. op = Operator.NotElementOf; .)
  | SYM_PLUS                      (. op = Operator.Add; .)
  | SYM_ROTL                      (. op = Operator.RotateLeft; .)
  | SYM_ROTR                      (. op = Operator.RotateRight; .)
  | SYM_SAT_ADD                   (. op = Operator.SaturatedAdd; .)
  | SYM_SAT_SUB                   (. op = Operator.SaturatedSubtract; .)
  | SYM_SHL                       (. op = Operator.ShiftLeft; .)
  | SYM_SHR                       (. op = Operator.ShiftRight; .)
  // When adding a new operator here, it must also be added to the "BIN_OPS" list in ParserUtils.java!
  .

  unary<out Expr expr>
  = unaryOperator<out IsUnOp op>
    term<out Expr operand> (. if (operand instanceof BinaryExpr binExpr) {
                                expr = new BinaryExpr(new UnaryExpr(op, binExpr.left), binExpr.operator, binExpr.right);
                              } else {
                                expr = new UnaryExpr(op, operand);
                              }
                           .)
  .

  unaryOperator<out IsUnOp op>   (. op = null; .)
  = SYM_MINUS                    (. op = new UnOp(UnaryOperator.NEGATIVE, lastTokenLoc()); .)
  | SYM_EXCL                     (. op = new UnOp(UnaryOperator.LOG_NOT, lastTokenLoc()); .)
  | SYM_TILDE                    (. op = new UnOp(UnaryOperator.COMPLEMENT, lastTokenLoc()); .)
  // When adding a new operator here, it must also be added to the "UN_OPS" list in ParserUtils.java!
  | macroReplacement<out Node n> (. op = (IsUnOp) n; .)
  .

  term<out Expr expr>            (. expr = DUMMY_EXPR; .)
  = literal<out expr>
  | IF (la.kind == _MATCH && scanner.Peek().kind != _SYM_COLON) // Disambiguate from macro match
    matchExpression<out expr>
  | IF (isIdentifierToken(la) || isMacroReplacementOfType(this, BasicSyntaxType.CALL_EX))
    callOrBinaryExpression<out expr, true>
  | groupedExpression<out expr>
  | IF(isUnaryOperator(la) || isMacroReplacementOfType(this, BasicSyntaxType.UN_OP))
    unary<out expr>
  | ifExpression<out expr, BIN_OPS>
  | letExpression<out expr>
  | existsExpression<out expr>
  | forallExpression<out expr, BIN_OPS>
  | // IF (isMacroReplacementOfType(this, BasicSyntaxType.EX))
    macroReplacement<out Node n> (. expr = castExpr(this, n); .)
  .

  groupedExpression<out GroupedExpr expr> (. expr = new GroupedExpr(new ArrayList<>(), lastTokenLoc()); .)
  = SYM_PAREN_OPEN
    expression<out Expr inner, BIN_OPS>   (. expr.expressions.add(inner); .)
    {
      SYM_COMMA
      expression<out Expr next, BIN_OPS>  (. expr.expressions.add(next); .)
    }
    SYM_PAREN_CLOSE                       (. expr.loc = expr.loc.join(lastTokenLoc()); .)
  .

  literal<out Expr expr> (. expr = DUMMY_EXPR; .)
  = valLiteral<out expr>
  | stringLiteral<out expr>
  .

  valLiteral<out Expr expr> (. expr = DUMMY_EXPR; .)
  = boolLiteral<out expr>
  | intLiteral<out expr>
  | binLiteral<out expr>
  .

  intLiteral<out Expr expr>
  = decLit (. expr = new IntegerLiteral(t.val, lastTokenLoc()); .)
  .

  binLiteral<out Expr expr>
  = (hexLit | binLit) (. expr = new BinaryLiteral(t.val, lastTokenLoc()); .)
  .

  boolLiteral<out Expr expr> (. expr = DUMMY_EXPR; .)
  = TRUE                     (. expr = new BoolLiteral(true, lastTokenLoc()); .)
  | FALSE                    (. expr = new BoolLiteral(false, lastTokenLoc()); .)
  .

  referenceLiteral<out IsId reference>
  = SYM_AT
    identifierPath<out reference>
  .

  identifierPath<out IsId path>                                 (. List<IdentifierOrPlaceholder> segments = new ArrayList<>(); .)
  = identifierOrPlaceholder<out IdentifierOrPlaceholder id>     (. segments.add(id); .)
    {
      SYM_NAMESPACE
      identifierOrPlaceholder<out IdentifierOrPlaceholder next> (. segments.add(next); .)
    }                                                           (. if (segments.size() == 1) path = id;
                                                                   else path = new IdentifierPath(segments); .)
  .

  rangeExpression<out Expr expr>
  = expression<out expr, BIN_OPS>
    [ SYM_RANGE expression<out Expr to, BIN_OPS> (. expr = new RangeExpr(expr, to); .) ]
  .

  letExpression<out Expr expr>          (. var start = nextTokenLoc(); var identifiers = new ArrayList<Identifier>(); .)
  = LET
    identifier<out Identifier id>       (. identifiers.add(id); .)
    {
      SYM_COMMA
      identifier<out Identifier nextId> (. identifiers.add(nextId); .)
    }
    SYM_EQ                              (. Expr valueExpr = DUMMY_EXPR; .)
    ( IF (la.kind == _IF_KW)
      ifExpression<out valueExpr, BIN_OPS_EXCEPT_IN>
    | IF (la.kind == _FORALL)
      forallExpression<out expr, BIN_OPS_EXCEPT_IN>
    | expression<out valueExpr, BIN_OPS_EXCEPT_IN>
    )
    SYM_IN
    expression<out Expr body, BIN_OPS>  (. expr = new LetExpr(identifiers, valueExpr, body, start.join(lastTokenLoc())); .)
  .

  ifExpression<out Expr expr, boolean[] allowedElseOps>   (. var startLoc = nextTokenLoc(); .)
  = IF_KW
    expression<out Expr condition, BIN_OPS>
    THEN expression<out Expr thenExpr, BIN_OPS>
    ELSE expression<out Expr elseExpr, allowedElseOps>    (. expr = new IfExpr(condition, thenExpr, elseExpr, startLoc.join(lastTokenLoc())); .)
  .

  matchExpression<out Expr expr>              (. var start = nextTokenLoc(); .)
  = MATCH
    expression<out Expr candidate, BIN_OPS>
    WITH
    SYM_BRACE_OPEN                            (. var cases = new ArrayList<MatchExpr.Case>();  .)
    {                                         (. var patterns = new ArrayList<Expr>(); .)
      ( expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        }
      | SYM_BRACE_OPEN
        expression<out Expr pattern, BIN_OPS> (. patterns.add(pattern); .)
        {
          SYM_COMMA
          expression<out pattern, BIN_OPS>    (. patterns.add(pattern); .)
        }
        SYM_BRACE_CLOSE
      )
      SYM_BIGARROW
      expression<out Expr result, BIN_OPS>    (. cases.add(new MatchExpr.Case(patterns, result)); .)
      SYM_COMMA
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    expression<out Expr defaultResult, BIN_OPS>
    SYM_BRACE_CLOSE                           (. expr = new MatchExpr(candidate, cases, defaultResult, start.join(lastTokenLoc())); .)
  .

  existsExpression<out Expr expr>                   (. expr = DUMMY_EXPR; var start = nextTokenLoc(); .)
  = EXISTS
    ( IF (la.kind == _SYM_IN)
      SYM_IN
      operationsList<.out List<IsId> operations.>   (. expr = new ExistsInExpr(operations, start.join(lastTokenLoc())); .)
    | identifierOrPlaceholder<out IdentifierOrPlaceholder id>
      SYM_IN                                        (. var conditions = new ArrayList<ExistsInThenExpr.Condition>(); .)
      operationsList<.out List<IsId> operations.>   (. conditions.add(new ExistsInThenExpr.Condition(id, operations)); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out id>
        SYM_IN
        operationsList<out operations>              (. conditions.add(new ExistsInThenExpr.Condition(id, operations)); .)
      }
      THEN
      expression<out Expr thenExpr, BIN_OPS>        (. expr = new ExistsInThenExpr(conditions, thenExpr, start.join(lastTokenLoc())); .)
    )
  .

  operationsList<.out List<IsId> operations.>
  = SYM_BRACE_OPEN                (. operations = new ArrayList<>(); .)
    identifierPath<out IsId path> (. operations.add(path); .)
    {
      SYM_COMMA
      identifierPath<out path>    (. operations.add(path); .)
    }
    SYM_BRACE_CLOSE
  .

  forallExpression<out Expr forallExpr, boolean[] allowedOps> (. forallExpr = DUMMY_EXPR; var start = nextTokenLoc(); .)
  = FORALL
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_IN
    (                                                         (. var indices = new ArrayList<ForallThenExpr.Index>(); .)
      operationsList<.out List<IsId> operations.>             (. indices.add(new ForallThenExpr.Index(id, operations)); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out id>
        SYM_IN
        operationsList<out operations>                        (. indices.add(new ForallThenExpr.Index(id, operations)); .)
      }
      THEN
      expression<out Expr thenExpr, allowedOps>               (. forallExpr = new ForallThenExpr(indices, thenExpr, start.join(lastTokenLoc())); .)
    |                                                         (. var indices = new ArrayList<ForallExpr.Index>(); .)
      rangeExpression<out Expr domain>                        (. indices.add(new ForallExpr.Index(id, domain)); .)
      {
        SYM_COMMA
        identifierOrPlaceholder<out id>
        SYM_IN
        rangeExpression<out domain>                           (. indices.add(new ForallExpr.Index(id, domain)); .)
      }                                                       (. ForallExpr.Operation operation = null; Operator foldAction = null; .)
      ( APPEND                                                (. operation = ForallExpr.Operation.APPEND; .)
      | TENSOR                                                (. operation = ForallExpr.Operation.TENSOR; .)
      | FOLD                                                  (. operation = ForallExpr.Operation.FOLD; .)
        binaryOperator<out foldAction>
        WITH
      )
      expression<out Expr expr, allowedOps>                   (. forallExpr = new ForallExpr(indices, operation, foldAction, expr, start.join(lastTokenLoc())); .)
    )
  .

  // -- PRIMITIVES ---------------------------------------------------------------------------------------------------

  typeLiteral<out TypeLiteral type>
  = identifierPath<out IsId path>                        (. List<List<Expr>> sizeIndices = new ArrayList<>(); .)
    {
      SYM_LT                                             (. List<Expr> sizes = new ArrayList<>(); .)
      expression<out Expr sizeExpr, BIN_OPS_EXCEPT_GT>   (. sizes.add(sizeExpr); .)
      {
        SYM_COMMA
        expression<out Expr nextSize, BIN_OPS_EXCEPT_GT> (. sizes.add(nextSize); .)
      }
      SYM_GT                                             (. sizeIndices.add(sizes); .)
    }                                                    (. type = new TypeLiteral(path, sizeIndices, path.location().join(lastTokenLoc())); .)
  .

  identifier<out Identifier identifier>
  = (identifierToken | allowedIdentifierKeywords) (. identifier = new Identifier(t.val, lastTokenLoc()); .)
  .

  /// Must be kept in sync with ParserUtils.ID_TOKENS.
  allowedIdentifierKeywords
  = ADDRESS
  | ALIAS
  | ALIGN
  // | ASSERT
  | APPEND
  | BINARY
  | CALL
  | CONSTANT
  // | DESCRIPTION
  | ENCODE
  | EXCEPTION
  | FETCH
  | GLOBAL
  | GROUP
  | INSTRUCTION
  | INT
  // | INVALID
  // | LABEL
  | LONG
  | MAX
  | MEMORY
  // | MNEMONIC
  // | MODE
  // | MODIFIER
  | NONE
  | NOP
  // | OPERAND
  | OPERATION
  | PREDICATE
  | PREDICTION
  // | PROCEDURE
  | READ
  // | REDIRECT
  | REGISTER
  | RETURN
  | SEQUENCE
  | SIGNED
  | SIZE_T
  | STAGE
  | STARTUP
  | RESET
  | STOP
  // | SYMBOL
  | SYM_IN
  | T_BIN
  | T_BIN_OP
  | T_BOOL
  | T_CALL_EX
  | T_COMMON_DEFS
  | T_ENCS
  | T_ID
  | T_INT
  | T_ISA_DEFS
  | T_LIT
  | T_STAT
  | T_STATS
  | T_STR
  | T_SYM_EX
  | T_UN_OP
  | T_VAL
  | TRANSLATION
  | TYPE
  | UNSIGNED
  // | UNIT
  // | USER
  | WRITE
  | WIDTH
  // TODO Add all allowed keywords
  .

  assemblyIdentifier<out Identifier identifier>
  = (identifierToken | assemblyAllowedIdentifierKeywords) (. identifier = new Identifier(t.val, lastTokenLoc()); .)
  .

  assemblyAllowedIdentifierKeywords
  = allowedIdentifierKeywords
  // | TODO other keywords
  .

  sequenceCallExprList<.out List<ExpandedSequenceCallExpr> list.> (. var calls = new ArrayList<SequenceCallExpr>(); .)
  = ( sequenceCallExpr<out SequenceCallExpr call>                 (. calls.add(call); .)
    | SYM_BRACK_OPEN
      sequenceCallExpr<out SequenceCallExpr call>                 (. calls.add(call); .)
      {
        SYM_COMMA
        sequenceCallExpr<out call>                                (. calls.add(call); .)
      }
      SYM_BRACK_CLOSE
    )                                                             (. list = expandSequenceCalls(this, calls); .)
  .

  sequenceCallExpr<out SequenceCallExpr call>     (. var start = nextTokenLoc();
                                                     Expr range = null;
                                                     call = null;
                                                     IsCallExpr ident = null;
                                                  .)
  =
  identifier<out Identifier id1> (. ident = id1; .)
  {
        // X(1)
        arguments<out CallIndexExpr.Arguments args>
        (. ident =  new CallIndexExpr(id1, List.of(args), List.of(), start); .)
    |  // a{0..7}
        SYM_BRACE_OPEN
        rangeExpression<out range>
        SYM_BRACE_CLOSE
  } (. call = new SequenceCallExpr(ident, range, start.join(lastTokenLoc())); .)
  .

  // -- MACROS -------------------------------------------------------------------------------------------------------

  macroReplacement<out Node body> (. body = DUMMY_ID; .)
  = ( macroMatch<out body>
    | maximumMacroExpr<out body>
    | extendId<out body>
    | idToStr<out body>
    )                             (. body = expandNode(this, body); .)
  .

  extendId<out Node body>                   (. var start = nextTokenLoc(); .)
  = EXTEND_ID
    groupedExpression<out GroupedExpr expr> (. body = new ExtendIdExpr(expr, start.join(lastTokenLoc())); .)
  .

  idToStr<out Node body> (. var start = nextTokenLoc(); .)
  = ID_TO_STR
    SYM_PAREN_OPEN
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_PAREN_CLOSE (. body = new IdToStrExpr(id, start.join(lastTokenLoc())); .)
  .

  macroMatch<out Node node>                           (. var start = nextTokenLoc(); .)
  = MATCH
    SYM_COLON
    basicSyntaxType<out SyntaxType type>
    SYM_PAREN_OPEN                                    (. var choices = new ArrayList<MacroMatch.Choice>(); .)
    macroReplacement<out Node candidate>              (. var patterns = new ArrayList<MacroMatch.Pattern>(); .)
    (SYM_EQ | SYM_NEQ )                               (. var comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
    macroBody<out Node match, candidate.syntaxType()> (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
    {
      SYM_COMMA
      macroReplacement<out candidate>
      (SYM_EQ | SYM_NEQ )                             (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
      macroBody<out match, candidate.syntaxType()>    (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
    }
    SYM_BIGARROW
    macroBody<out Node result, type>                  (. choices.add(new MacroMatch.Choice(patterns, result)); .)
    SYM_SEMICOLON
    {                                                 (. patterns = new ArrayList<MacroMatch.Pattern>(); .)
      macroReplacement<out candidate>
      (SYM_EQ | SYM_NEQ )                             (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
      macroBody<out match, candidate.syntaxType()>    (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
      {
        SYM_COMMA
        macroReplacement<out candidate>
        (SYM_EQ | SYM_NEQ )                           (. comparison = t.kind == _SYM_EQ ? MacroMatch.Comparison.EQUAL : MacroMatch.Comparison.NOT_EQUAL; .)
        macroBody<out match, candidate.syntaxType()>  (. patterns.add(new MacroMatch.Pattern(candidate, comparison, match)); .)
      }
      SYM_BIGARROW
      macroBody<out result, type>                     (. choices.add(new MacroMatch.Choice(patterns, result)); .)
      SYM_SEMICOLON
    }
    SYM_UNDERSCORE
    SYM_BIGARROW
    macroBody<out Node defaultChoice, type>
    SYM_PAREN_CLOSE                                   (. node = createMacroMatch(type, choices, defaultChoice, start.join(lastTokenLoc())); .)
  .

  /// Parses the longest macro expression (either instance or placeholder) from the parser.
  maximumMacroExpr<out Node node>                 (. node = null; var startLoc = nextTokenLoc(); .)
  = SYM_DOLLAR                                    (. var segments = new ArrayList<String>(); .)
    identifier<out Identifier id>                 (. var macro = macroTable.getMacro(id.name);
                                                     var paramType = paramSyntaxType(this, id.name);
                                                     segments.add(id.name); .)
    { IF (macro == null && la.kind == _SYM_DOT && paramType instanceof RecordType record)
      SYM_DOT
      identifier<out Identifier next>             (. paramType = record.findEntry(next.name); segments.add(next.name); .)
    }
    [
      IF (la.kind == _SYM_PAREN_OPEN && (macro != null || paramType instanceof ProjectionType))
      SYM_PAREN_OPEN                              (. var macroOrPlaceholder = macroOrPlaceholder(macro, paramType, segments);
                                                     var params = instanceParamTypes(macroOrPlaceholder);
                                                     var args = new ArrayList<Node>(); .)
      (
        SYM_PAREN_CLOSE
      |                                           (.
                                                      // If too many arguments exist we cannot parse them because we
                                                      // need the information from the model signature to know how to
                                                      // parse them so instead we must abort parsing and throw an error.
                                                      if (!params.hasNext()) throw ParserUtils.tooManyMacroArgumentsError(macro, nextTokenLoc());
                                                  .)
        macroBody<out Node arg1, params.next()>   (. args.add(arg1); .)
        {
          SYM_SEMICOLON                           (.
                                                      // If too many arguments exist we cannot parse them because we
                                                      // need the information from the model signature to know how to
                                                      // parse them so instead we must abort parsing and throw an error.
                                                      if (!params.hasNext()) throw ParserUtils.tooManyMacroArgumentsError(macro, nextTokenLoc());
                                                  .)
          macroBody<out Node arg2, params.next()> (. args.add(arg2); .)
        }
        SYM_PAREN_CLOSE
      )                                           (. node = createMacroInstance(macroOrPlaceholder, args, startLoc.join(lastTokenLoc())); .)
    ]                                             (.
                                                     node = Objects.requireNonNullElse(
                                                       node,
                                                       macro == null
                                                       ? createPlaceholder(paramType, segments, startLoc.join(lastTokenLoc()))
                                                       : createMacroInstance(macro, List.of(), startLoc.join(lastTokenLoc()))
                                                     );
                                                  .)
  .

  macroDef<out ModelDefinition def>         (. var startLoc = nextTokenLoc(); .)
  = MODEL
    identifierOrPlaceholder<out IdentifierOrPlaceholder id>
    SYM_PAREN_OPEN                          (. var params = new ArrayList<MacroParam>(); .)
    [
      identifier<out Identifier paramId1>
      SYM_COLON
      syntaxType<out SyntaxType synType1>   (. params.add(new MacroParam(paramId1, synType1)); .)
      {
        SYM_COMMA
        identifier<out Identifier paramId2>
        SYM_COLON
        syntaxType<out SyntaxType synType2> (. params.add(new MacroParam(paramId2, synType2)); .)
      }
    ]
    SYM_PAREN_CLOSE                         (. macroContext.addFirst(params); .)
    SYM_COLON
    basicSyntaxType<out SyntaxType returnType>
    SYM_EQ

    SYM_BRACE_OPEN
    macroBody<out Node body, returnType>
    SYM_BRACE_CLOSE                         (. macroContext.removeFirst();
                                               SyntaxType macroType = assertSyntaxType(this, body, returnType, "Macro body does not match signature")
                                                 ? returnType : BasicSyntaxType.INVALID;
                                               def = new ModelDefinition(id, params, body, macroType, startLoc.join(lastTokenLoc()));
                                            .)
  .

  macroBody<out Node body, SyntaxType type>                 (. body = DUMMY_ID; var start = nextTokenLoc(); .)
  = (
    IF (type == BasicSyntaxType.STATS)
    statementList<.out List<Statement> stmts.>              (. body = new StatementList(stmts, start.join(lastTokenLoc())); .)
  | IF (type == BasicSyntaxType.STAT)
    statement<out body>
  | IF (type == BasicSyntaxType.ENCS)
    encodingDefinitionList<out body>
  | IF (type == BasicSyntaxType.ISA_DEFS)                   (. macroTable = macroTable.createChild(); .)
    isaDefinitionList<.out List<Definition> defs.>          (. body = new DefinitionList(defs, type, start.join(lastTokenLoc())); macroTable = macroTable.pop(); .)
  | IF (type == BasicSyntaxType.COMMON_DEFS)                (. macroTable = macroTable.createChild(); .)
    commonDefinitionList<.out List<Definition> defs.>       (. body = new DefinitionList(defs, type, start.join(lastTokenLoc())); macroTable = macroTable.pop(); .)
  | IF (type == BasicSyntaxType.EX)
    expression<out body, BIN_OPS>
  | IF (type == BasicSyntaxType.LIT)
    ( literal<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.STR)
    ( stringLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.VAL)
    ( valLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.BOOL)
    ( boolLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.INT)
    ( intLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.BIN)
    ( binLiteral<out body>
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.CALL_EX)
    callOrBinaryExpression<out body, false>
  | IF (type == BasicSyntaxType.SYM_EX)
    symbolOrBinaryExpression<out body, false>
  | IF (type == BasicSyntaxType.ID)
    identifierOrPlaceholder<out IdentifierOrPlaceholder id> (. body = (Node) id; .)
  | IF (type == BasicSyntaxType.BIN_OP)
    ( binaryOperator<out Operator op>                       (. body = new BinOp(op, lastTokenLoc()); .)
    | macroReplacement<out body>
    )
  | IF (type == BasicSyntaxType.UN_OP)
    unaryOperator<out IsUnOp op>                            (. body = (Node) op; .)
  | IF (type instanceof RecordType recordType)
    ( SYM_PAREN_OPEN                                        (. var entries = new ArrayList<Node>(recordType.entries.size()); var nextEntry = recordType.entries.iterator(); .)
      macroBody<out Node entry, nextEntry.next().type()>    (. entries.add(entry); .)
      {
        SYM_SEMICOLON
        macroBody<out entry, nextEntry.next().type()>       (. entries.add(entry); .)
      }
      SYM_PAREN_CLOSE                                       (. body = new RecordInstance(recordType, entries, start.join(lastTokenLoc())); .)
    | macroReplacement<out body>
    )
  | IF (type instanceof ProjectionType projection)
    ( identifier<out Identifier id>                         (. body = createMacroReference(this, id); .)
    | macroReplacement<out body>
    )
  | unreachableRule
  )                                                         (. assertSyntaxType(this, body, type, "Mismatched node type"); .)
  .

  unreachableRule
  = ANY                                     (. throw new IllegalStateException("Unreachable rule"); .)
  .

  syntaxType<out SyntaxType type> (. type = BasicSyntaxType.INVALID; .)
  = IF (la.kind == _identifierToken)
    identifier<out Identifier id> (. type = macroTable.requireSyntaxType(id); .)
  | projectionType<out type>
  | basicSyntaxType<out type>
  .

  projectionType<out ProjectionType type>     (. var arguments = new ArrayList<SyntaxType>(); .)
  = SYM_PAREN_OPEN
    [
      syntaxType<out SyntaxType argType>      (. arguments.add(argType); .)
      { SYM_COMMA syntaxType<out argType>     (. arguments.add(argType); .) }
    ]
    SYM_PAREN_CLOSE
    SYM_ARROW
    syntaxType<out SyntaxType resultType>     (. type = new ProjectionType(arguments, resultType); .)
  .

  basicSyntaxType<out BasicSyntaxType type> (. type = BasicSyntaxType.INVALID; .)
  = T_BIN                                   (. type = BasicSyntaxType.BIN; .)
  | T_BIN_OP                                (. type = BasicSyntaxType.BIN_OP; .)
  | T_BOOL                                  (. type = BasicSyntaxType.BOOL; .)
  | T_CALL_EX                               (. type = BasicSyntaxType.CALL_EX; .)
  | T_COMMON_DEFS                           (. type = BasicSyntaxType.COMMON_DEFS; .)
  | T_ENCS                                  (. type = BasicSyntaxType.ENCS; .)
  | T_EX                                    (. type = BasicSyntaxType.EX; .)
  | T_ID                                    (. type = BasicSyntaxType.ID; .)
  | T_INT                                   (. type = BasicSyntaxType.INT; .)
  | T_ISA_DEFS                              (. type = BasicSyntaxType.ISA_DEFS; .)
  | T_LIT                                   (. type = BasicSyntaxType.LIT; .)
  | T_STAT                                  (. type = BasicSyntaxType.STAT; .)
  | T_STATS                                 (. type = BasicSyntaxType.STATS; .)
  | T_STR                                   (. type = BasicSyntaxType.STR; .)
  | T_SYM_EX                                (. type = BasicSyntaxType.SYM_EX; .)
  | T_UN_OP                                 (. type = BasicSyntaxType.UN_OP; .)
  | T_VAL                                   (. type = BasicSyntaxType.VAL; .)
  | identifierToken                         (.
                                                // Unfortunately, we need this type to be correctly parsed because,
                                                // depending on it, we parse the body of the macro differently. So if we
                                                // don't know what it is, we must exit early.
                                                throwException(ParserUtils.unknownSyntaxTypeError(t.val, lastTokenLoc()));
                                            .)
  .



END vadl.
