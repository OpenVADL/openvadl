$package=vadl.ast
import java.util.ArrayList;
import java.util.List;

import vadl.ast.EncodingDefinition.FieldEncoding;
import vadl.utils.SourceLocation;

import static vadl.ast.CounterDefinition.CounterKind.GROUP;
import static vadl.ast.CounterDefinition.CounterKind.PROGRAM;
import static vadl.ast.ParserUtils.*;

COMPILER vadl
  java.net.URI sourceFile = SourceLocation.INVALID_SOURCE_LOCATION.uri();
  boolean insideMacro = false;
  boolean insideAnnotation = false;
  Ast ast = new Ast();
  NestedSymbolTable symbolTable = new NestedSymbolTable();

  SourceLocation loc() {
    return locationFromToken(this);
  }

CHARACTERS
  digit = '0' .. '9'.
  binDigit = '0' .. '1'.
  hexDigit = '0' .. '9' + 'A' .. 'F' + 'a' .. 'f'.
  letter = 'a' .. 'z' + 'A' .. 'Z'.
  validDQStringCharacters = ANY - '"' - "\\".
  validSQStringCharacters = ANY - "'" - "\\".

TOKENS
  number = digit {digit | "'"}
         | "0x" hexDigit {hexDigit | "'"}
         | "0b" binDigit {binDigit | "'"}
         .
  identifierToken = letter {letter | digit | "_"}.
  string =
  ( '"' { ("\\" letter | '"' | "'" | "\\") | validDQStringCharacters } '"') |
  ( "'" { ("\\" letter | '"' | "'" | "\\") | validSQStringCharacters } "'").

  T_STATS = "Stats".
  T_STAT = "Stat".
  T_ENCS = "Encs".
  T_ISA_DEFS = "IsaDefs".
  T_EX = "Ex".
  T_LIT = "Lit".
  T_STR = "Str".
  T_VAL = "Val".
  T_BOOL = "Bool".
  T_INT = "Int".
  T_BIN = "Bin".
  T_CALL_EX = "CallEx".
  T_SYM_EX = "SymEx".
  T_ID = "Id".
  T_BIN_OP = "BinOp".
  T_UN_OP = "UnOp".

  INSTRUCTION = "instruction".
  SET = "set".
  ARCHITECTURE = "architecture".
  CONSTANT = "constant".
  FORMAT = "format".
  PROGRAM = "program".
  GROUP = "group".
  COUNTER = "counter".
  ENCODING = "encoding".
  ASSEMBLY = "assembly".
  MNEMONIC = "mnemonic".
  MEMORY = "memory".
  REGISTER = "register".
  MODEL = "model".
  FILE = "file".
  LET = "let".
  KW_IF = "if".
  THEN = "then".
  ELSE = "else".

  SYM_IN = "in".
  SYM_AS = "as".
  SYM_EQ = "=".
  SYM_GT = ">".
  SYM_LT = "<".
  SYM_NIN = "!in".
  SYM_NEQ = "!=".
  SYM_GTE = ">=".
  SYM_LTE = "<=".
  SYM_MUL = "*".
  SYM_DIV = "/".
  SYM_MOD = "%".
  SYM_DOT = ".".
  SYM_SHR = ">>".
  SYM_SHL = "<<".
  SYM_ROTR = "<>>".
  SYM_ROTL = "<<>".
  SYM_EXCL = "!".
  SYM_PLUS = "+".
  SYM_MINUS = "-".
  SYM_TILDE = "~".
  SYM_COLON = ":".
  SYM_COMMA = ",".
  SYM_CARET = "^".
  SYM_BINOR = "|".
  SYM_LOGOR = "||".
  SYM_ARROW = "->".
  SYM_RANGE = "..".
  SYM_BINAND = "&".
  SYM_LOGAND = "&&".
  SYM_ASSIGN = ":=".
  SYM_DOLLAR = "$".
  SYM_SEMICOLON = ";".
  SYM_NAMESPACE = "::".
  SYM_PAREN_OPEN = "(".
  SYM_BRACK_OPEN = "[".
  SYM_BRACE_OPEN = "{".
  SYM_PAREN_CLOSE = ")".
  SYM_BRACK_CLOSE = "]".
  SYM_BRACE_CLOSE = "}".

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
  vadl =
  {
    topLevelDefinitions<out Definition d>   (. ast.definitions.add(d); .)
    | macroDef
  }.

  // -- DEFINITIONS --------------------------------------------------------------------------------------------------
  topLevelDefinitions<out Definition def> (. def = null; .)
  = instructionsetDefinition<out def>
  | commonDefinition<out def>             (. def.accept(symbolTable); .)
  .

  commonDefinition<out Definition def>    (. def = null; .)
  = constantDefinition<out def>
  | formatDefinition<out def>
  .

  instructionsetDefinition<out InstructionSetDefinition isaDef>   (. var children = new ArrayList<Definition>(); pushScope(this); .)
  = INSTRUCTION                                                   (. var startLocation = loc(); .)
    SET ARCHITECTURE identifier<out Identifier identifier>
    SYM_EQ SYM_BRACE_OPEN
    {(
      annotations<.out List<Annotation> annotations.>
      isaDefinition<out Definition def>                           (. def.annotations.annotations().addAll(annotations); children.add(def); def.accept(symbolTable); .)
      | macroDef
      | macroInstance<out Node b, BasicSyntaxType.IsaDefs()>      (. children.add((Definition) b); .)
    )}
    SYM_BRACE_CLOSE                                               (. isaDef = new InstructionSetDefinition(identifier, children, startLocation.join(loc()));
                                                                     popScope(this);
                                                                     isaDef.accept(symbolTable);
                                                                  .)
    .

  annotations<.out List<Annotation> annotations.> (. annotations = new ArrayList<>(); insideAnnotation = true; .)
  = { annotation<out Annotation annotation> (. annotations.add(annotation); .) }
                                            (. insideAnnotation = false; .)
  .

  annotation<out Annotation annotation> (. TypeLiteral type = null; Identifier property = null; .)
  = SYM_BRACK_OPEN
    expression<out Expr expr, BIN_OPS>
    [ (SYM_COLON typeLiteral<out type>)
    | identifier<out property>
    ]
    SYM_BRACK_CLOSE                     (. annotation = new Annotation(expr, type, property); .)
  .

  isaDefinition<out Definition def> (. def = null; .)
  = commonDefinition<out def>
  | counterDefinition<out def>
  | instructionDefinition<out def>
  | encodingDefinition<out def>
  | assemblyDefinition<out def>
  | memoryDefinition<out def>
  | IF (la.kind == _REGISTER && scanner.Peek().kind == _FILE)
    registerFileDefinition<out def>
  | registerDefinition<out def>
  .

  constantDefinition<out ConstantDefinition def>    (. TypeLiteral type = null; .)
  = CONSTANT                                        (. var startLocation = loc(); .)
    identifier<out Identifier id>
    [ SYM_COLON typeLiteral<out type> ]
    SYM_EQ expression<out Expr expr, BIN_OPS>                (. def = new ConstantDefinition(id, type, expr, startLocation.join(loc())); .)
  .

  formatDefinition<out FormatDefinition def>                      (. List<FormatDefinition.FormatField> fields = new ArrayList<>();.)
  = FORMAT                                                        (. var startLoc = loc(); .)
  identifier<out Identifier id>
  SYM_COLON typeLiteral<out TypeLiteral type>
  [SYM_EQ SYM_BRACE_OPEN
      formatField<out FormatDefinition.FormatField f1>            (. fields.add(f1); .)
      {
      SYM_COMMA formatField<out FormatDefinition.FormatField f2>  (. fields.add(f2); .)
      }
  SYM_BRACE_CLOSE]                                                (. def = new FormatDefinition(id, type, fields, startLoc.join(loc())); .)
  .

  // FIXME: more versions are missing here
  formatField<out FormatDefinition.FormatField field>             (. field = null; .)
  = identifier<out Identifier id>
    ( formatFieldRange<out field, id>
      | formatFieldType<out field, id>
    )
  .

  formatFieldRange<out FormatDefinition.FormatField field, Identifier id>
  = SYM_BRACK_OPEN                      (. List<RangeExpr> ranges = new ArrayList<>();.)
    rangeExpression<out RangeExpr e1>   (. ranges.add(e1); .)
    {
      SYM_COMMA
      rangeExpression<out RangeExpr e2> (. ranges.add(e2); .)
    }
    SYM_BRACK_CLOSE                     (. field = new FormatDefinition.RangeFormatField(id, ranges); .)
  .

  formatFieldType<out FormatDefinition.FormatField field, Identifier id>
  = SYM_COLON
    typeLiteral<out TypeLiteral type>   (. field = new FormatDefinition.TypedFormatField(id, type, symbolTable); .)
  .

  counterDefinition<out CounterDefinition def>  (. CounterDefinition.CounterKind kind = null; .)
  = ( PROGRAM                                   (. kind = PROGRAM; .)
    | GROUP                                     (. kind = GROUP; .)
    )                                           (. var startLocation = loc(); .)
    COUNTER
    identifier<out Identifier id>
    SYM_COLON typeLiteral<out TypeLiteral type> (. def = new CounterDefinition(kind, id, type, startLocation.join(loc())); .)
  .

  instructionDefinition<out InstructionDefinition def>   (. var startLocation = loc(); .)
  = INSTRUCTION identifierOrPlaceholder<out Node id>
    SYM_COLON identifierOrPlaceholder<out Node formatId> (. pushFormatScope(this, formatId); .)
    SYM_EQ blockStatement<out BlockStatement behavior>   (. def = new InstructionDefinition(id, formatId, behavior, startLocation.join(loc()));
                                                            popScope(this); .)
  .

  identifierOrPlaceholder<out Node n> (. n = null; .)
  = identifier<out n>
  | placeholder<out n, BasicSyntaxType.Id()>
  .

  encodingDefinition<out EncodingDefinition def>    (. var startLocation = loc(); var entries = new ArrayList<FieldEncoding>(); .)
  = ENCODING identifier<out Identifier instrId>
    SYM_EQ SYM_BRACE_OPEN
    encodingEntry<out FieldEncoding e1>             (. entries.add(e1); .)
    { SYM_COMMA encodingEntry<out FieldEncoding e2> (. entries.add(e2); .) }
    SYM_BRACE_CLOSE                                 (. def = new EncodingDefinition(instrId, entries, startLocation.join(loc())); .)
  .

  encodingEntry<out FieldEncoding e>
  = identifier<out Identifier id>
    SYM_EQ number                    (. e = new FieldEncoding(id, new IntegerLiteral(t.val, loc())); .)
  .

  assemblyDefinition<out AssemblyDefinition def>         (. List<Identifier> ids = new ArrayList<>(); var start = loc(); .)
  = ASSEMBLY identifier<out Identifier id>               (. ids.add(id); pushInstructionScope(this, id); .)
    { SYM_COMMA identifier <out Identifier additionalId> (. ids.add(additionalId); pushInstructionScope(this, id); .) }
    SYM_EQ SYM_PAREN_OPEN                                (. var isMnemonic = false; List<Node> segments = new ArrayList<>(); .)
    (  MNEMONIC                                          (. isMnemonic = true; .)
      | stringLit<out StringLiteral lit1>                (. segments.add(lit1); .)
    ) { SYM_COMMA (
      stringLit<out StringLiteral lit2>                  (. segments.add(lit2); .)
      | term<out Expr expr>                              (. segments.add(expr); .)
    )} SYM_PAREN_CLOSE                                   (. def = new AssemblyDefinition(ids, isMnemonic, segments, start.join(loc()));
                                                            popScope(this); .)
  .

  stringLit<out StringLiteral lit>
  = string                                               (. lit = new StringLiteral(t.val, loc()); .)
  .

  memoryDefinition<out MemoryDefinition def>
  = MEMORY                                    (. var startLocation = loc(); .)
    identifier<out Identifier id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2> (. def = new MemoryDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .

  registerDefinition<out RegisterDefinition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    identifier<out Identifier id>
    SYM_COLON typeLiteral<out TypeLiteral t1>         (. def = new RegisterDefinition(id, t1, startLocation.join(t1.location())); .)
  .

  registerFileDefinition<out Definition def>
  = REGISTER                                          (. var startLocation = loc(); .)
    FILE
    identifier<out Identifier id>
    SYM_COLON typeLiteral<out TypeLiteral t1>
    SYM_ARROW typeLiteral<out TypeLiteral t2>         (. def = new RegisterFileDefinition(id, t1, t2, startLocation.join(t2.location())); .)
  .


  // -- STATEMENTS ---------------------------------------------------------------------------------------------------

  statement<out Statement statement> (. statement = null; .)
  = letStatement<out statement>
  | ifStatement<out statement>
  | assignment<out statement>
  | blockStatement<out statement>
  .

  blockStatement<out BlockStatement block>   (. var start = loc(); block = new BlockStatement(start); pushScope(this); .)
  = SYM_BRACE_OPEN {
      statement<out Statement statement>     (. block.add(statement); .)
   } SYM_BRACE_CLOSE                         (. popScope(this); block.location = start.join(loc()); .)
  .

  assignment<out Statement statement>
  = callOrBinaryExpression<out Expr target, false>
    SYM_ASSIGN
    expression<out Expr expr, BIN_OPS>      (. statement = new AssignmentStatement(target, expr); .)
  .

  letStatement<out Statement letStatement>
  = LET                                   (. var start = loc(); .)
    identifier<out Identifier id>         (. pushScope(this); symbolTable.defineConstant(id.name, loc()); .)
    SYM_EQ expression<out Expr valueExpr, BIN_OPS_EXCEPT_IN>
    SYM_IN
    statement<out Statement body>         (. letStatement = new LetStatement(id, valueExpr, body, start.join(loc())); popScope(this); .)
  .

  ifStatement<out Statement ifStatement>     (. Statement elseStmt = null; var start = loc(); .)
  = KW_IF expression<out Expr condition, BIN_OPS>
    THEN statement<out Statement thenStmt>
    [ IF (la.kind == _ELSE)
      ELSE statement<out elseStmt>
    ]                                        (. ifStatement = new IfStatement(condition, thenStmt, elseStmt, start.join(loc())); .)
  .

  // -- EXPRESSIONS --------------------------------------------------------------------------------------------------

  expression<out Expr expr, boolean[] allowedOps>
  = term<out expr>
    {
        IF (allowedOps[la.kind] || la.kind == _SYM_AS)
        (
          binaryOperator<out Operator op>
          term<out Expr right>                              (. expr = new BinaryExpr(expr, op, right); .)
        | SYM_AS
          symbolOrBinaryExpression<out Expr symOrBin, true> (. expr = reorderCastExpr(expr, symOrBin); .)
        )
    }                                                       (. expr = ungroup(this, reorderBinary(this, expr)); .)
  .

  /// Call expressions of form "a::b<3>().c()".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  callOrBinaryExpression<out Expr expr, boolean allowLtOp>
  = symbolOrBinaryExpression<out expr, allowLtOp> (. if (expr instanceof SymbolExpr symExpr) {
                                                       expr = new CallExpr(symExpr, new ArrayList<>(), new ArrayList<>(), expr.location());
                                                     }
                                                  .)
    {
      // Check if we received a symbol expression -> collect arguments
      // Otherwise, just return the collected binary expression
      // TODO Also collect pseudo-instruction arguments in {...}
      IF (la.kind == _SYM_PAREN_OPEN && (expr instanceof CallExpr callExpr))
      arguments<.out List<Expr> args.> (. callExpr.argsIndices.add(args); callExpr.location = callExpr.location.join(loc()); .)
    }
    {
      IF (la.kind == _SYM_DOT && (expr instanceof CallExpr callExpr))
      SYM_DOT                            (. var argsIndices = new ArrayList<List<Expr>>(); .)
      identifier<out Identifier id>
      {
        IF (la.kind == _SYM_PAREN_OPEN)
        arguments<.out List<Expr> args.> (. argsIndices.add(args); .)
      }                                  (. callExpr.subCalls.add(new CallExpr.SubCall(id, argsIndices)); callExpr.location = callExpr.location.join(loc()); .)
    }                                    (. if (expr instanceof CallExpr callExpr && !insideMacro && !insideAnnotation) symbolTable.requireValue(callExpr); .)
  .

  /// Represents one set of invocation arguments.
  /// Multiple invocations (e.g. multi-dimensional access) will need multiple #arguments
  arguments<.out List<Expr> args.>
  = SYM_PAREN_OPEN                            (. args = new ArrayList<>(); .)
    expression<out Expr arg, BIN_OPS>         (. args.add(arg); .)
    {
        SYM_COMMA
        expression<out Expr nextArg, BIN_OPS> (. args.add(nextArg); .)
    }
    SYM_PAREN_CLOSE
  .

  /// Symbol expressions of form "a::b<3>".
  /// Due to the "<"-ambiguity with the less-than operator, this rule can also return a BinaryExpr.
  /// Use the "allowLtOp" parameter to disallow this behavior, e.g. in type literals.
  symbolOrBinaryExpression<out Expr expr, boolean allowLtOp>
  = identifierPath<out IdentifierPath path> (. expr = new SymbolExpr(path, null, path.location()); .)
    [
      IF (la.kind == _SYM_LT)
      SYM_LT
      term<out Expr term>                   (. expr = new BinaryExpr(expr, Operator.Less(), term); .)
      [
        IF (la.kind == _SYM_GT)
        SYM_GT                              (. expr = new SymbolExpr(path, term, path.location().join(loc())); .)
      ]                                     (. if (!allowLtOp && expr instanceof BinaryExpr) {
                                                 semError(this, expr.location(), "Binary operator '<' not allowed here");
                                               }
                                            .)
    ]
  .

  binaryOperator<out Operator op>    (.op = null;.)
  = SYM_LOGOR  (. op = Operator.LogicalOr(); .)
  | SYM_LOGAND (. op = Operator.LogicalAnd(); .)
  | SYM_BINOR  (. op = Operator.Or(); .)
  | SYM_CARET  (. op = Operator.Xor(); .)
  | SYM_BINAND (. op = Operator.And(); .)
  | SYM_EQ     (. op = Operator.Equal(); .)
  | SYM_NEQ    (. op = Operator.NotEqual(); .)
  | SYM_GTE    (. op = Operator.GreaterEqual(); .)
  | SYM_GT     (. op = Operator.Greater(); .)
  | SYM_LTE    (. op = Operator.LessEqual(); .)
  | SYM_LT     (. op = Operator.Less(); .)
  | SYM_ROTR   (. op = Operator.RotateRight(); .)
  | SYM_ROTL   (. op = Operator.RotateLeft(); .)
  | SYM_SHR    (. op = Operator.ShiftRight(); .)
  | SYM_SHL    (. op = Operator.ShiftLeft(); .)
  | SYM_PLUS   (. op = Operator.Add(); .)
  | SYM_MINUS  (. op = Operator.Subtract(); .)
  | SYM_MUL    (. op = Operator.Multiply(); .)
  | SYM_DIV    (. op = Operator.Divide(); .)
  | SYM_MOD    (. op = Operator.Modulo(); .)
  | SYM_IN     (. op = Operator.In(); .)
  | SYM_NIN    (. op = Operator.NotIn(); .)
  // When adding a new operator here, it must also be added to the "BIN_OPS" list in ParserUtils.java!
  .

  unary<out Expr expr>
  = unaryOperator<out UnaryOperator op>
    term<out Expr operand> (. if (operand instanceof BinaryExpr binExpr) {
                                expr = new BinaryExpr(new UnaryExpr(op, narrowExpr(binExpr.left)), binExpr.operator, narrowExpr(binExpr.right));
                              } else {
                                expr = new UnaryExpr(op, narrowExpr(operand));
                              }
                           .)
  .

  unaryOperator<out UnaryOperator op> (. op = null; .)
  = SYM_MINUS (. op = UnaryOperator.NEGATIVE; .)
  | SYM_EXCL  (. op = UnaryOperator.LOG_NOT; .)
  | SYM_TILDE (. op = UnaryOperator.COMPLEMENT; .)
  .

  term<out Expr expr>                            (. expr = null; .)
  = number                                                          (. expr = new IntegerLiteral(t.val, loc()); .)
  | callOrBinaryExpression<out expr, true>
  | SYM_PAREN_OPEN expression<out expr, BIN_OPS> SYM_PAREN_CLOSE    (. expr = new GroupExpr(expr); .)
  | unary<out expr>
  | ifExpression<out expr>
  | letExpression<out expr>
  | macroInstanceOrPlaceholder<out Node node, BasicSyntaxType.Ex()> (. expr = (Expr)node; .)
  .

  identifierPath<out IdentifierPath path> (. List<Identifier> segments = new ArrayList<>(); .)
  = identifier<out Identifier id>         (. segments.add(id); .)
    {
      SYM_NAMESPACE
      identifier<out Identifier next>     (. segments.add(next); .)
    }                                     (. path = new IdentifierPath(segments); .)
  .

  rangeExpression<out RangeExpr expr>
  = expression<out Expr e1, BIN_OPS>
    SYM_RANGE
    expression<out Expr e2, BIN_OPS> (. expr = new RangeExpr(e1, e2);.)
  .

  letExpression<out Expr expr>
  = LET                           (. var startLoc = loc(); .)
    identifier<out Identifier id> (. pushScope(this); symbolTable.defineConstant(id.name, loc()); .)
    SYM_EQ
    expression<out Expr valueExpr, BIN_OPS_EXCEPT_IN>
    SYM_IN
    expression<out Expr body, BIN_OPS> (. expr = new LetExpr(id, valueExpr, body, startLoc.join(loc())); popScope(this); .)
  .

  ifExpression<out Expr expr>
  = KW_IF                                (. var startLoc = loc(); .)
    expression<out Expr condition, BIN_OPS>
    THEN expression<out Expr thenExpr, BIN_OPS>
    ELSE expression<out Expr elseExpr, BIN_OPS>   (. expr = new IfExpr(condition, thenExpr, elseExpr, startLoc.join(loc())); .)
  .

  // -- PRIMITIVES ---------------------------------------------------------------------------------------------------

  typeLiteral<out TypeLiteral type>
  = identifierPath<out IdentifierPath path>              (. List<List<Expr>> sizeIndices = new ArrayList<>(); .)
    {
      SYM_LT                                             (. List<Expr> sizes = new ArrayList<>(); .)
      expression<out Expr sizeExpr, BIN_OPS_EXCEPT_GT>   (. sizes.add(sizeExpr); .)
      {
        SYM_COMMA
        expression<out Expr nextSize, BIN_OPS_EXCEPT_GT> (. sizes.add(nextSize); .)
      }
      SYM_GT                                             (. sizeIndices.add(sizes); .)
    }                                                    (. type = new TypeLiteral(path, sizeIndices, path.location().join(loc())); .)
  .

  identifier<out Identifier identifier>
  = (identifierToken | allowedIdentifierKeywords) (. identifier = new Identifier(t.val, loc()); .)
  .

  allowedIdentifierKeywords
  = T_BOOL
  // TODO Add all allowed keywords
  .

  // -- MACROS -------------------------------------------------------------------------------------------------------
  macroInstanceOrPlaceholder<out Node body, SyntaxType requiredType> (. body = null; .)
  = IF (!insideMacro) macroInstance<out body, requiredType>
  | placeholder<out body, requiredType>
  .

  placeholder<out PlaceholderExpr placeholder, SyntaxType requiredType>
  = SYM_DOLLAR                            (. var startloc = loc(); .)
  identifierPath<out IdentifierPath path> (. placeholder = new PlaceholderExpr(path, startloc.join(loc())); .)
  .


  macroInstance<out Node body, SyntaxType requiredType>       (. var args = new ArrayList<Node>(); .)
  = SYM_DOLLAR identifier<out Identifier id>
  SYM_PAREN_OPEN
      [
          macroInstanceParam<out Node arg1>                   (. args.add(arg1); .)
          {
              SYM_SEMICOLON macroInstanceParam<out Node arg2> (. args.add(arg2); .)
          }
      ]
  SYM_PAREN_CLOSE                                             (. body = expandMacro(this, id, args, requiredType); .)
  .

  macroInstanceParam<out Node arg> (. arg = null; .)
  = IF (la.kind == _identifierToken) identifier<out arg>
  | expression<out arg, BIN_OPS>
  .

  macroDef
  = MODEL                                         (. var startLoc = loc(); .)
  identifier<out Identifier id>
  SYM_PAREN_OPEN                                  (. var params = new ArrayList<MacroParam>(); .)
      [
          identifier<out Identifier paramId1>
          SYM_COLON
          syntaxType<out SyntaxType synType1>     (. params.add(new MacroParam(paramId1, synType1)); .)
          {
              SYM_COMMA
              identifier<out Identifier paramId2>
              SYM_COLON
              syntaxType<out SyntaxType synType2> (. params.add(new MacroParam(paramId2, synType2)); .)
          }
      ]
   SYM_PAREN_CLOSE
  SYM_COLON syntaxType<out SyntaxType returnType> SYM_EQ
  SYM_BRACE_OPEN                        (. Node body = null; insideMacro = true; .)
      ( expression<out body, BIN_OPS>
      | isaDefinition<out body>
      )
  SYM_BRACE_CLOSE                       (.
                                          insideMacro = false;
                                          var bodyType = narrowNode(body).syntaxType();
                                          if (!bodyType.isSubTypeOf(returnType)) {
                                              errors.SemErr(t.line, t.col, "The macro signature promises to return `%s` but it's body is of type `%s`.".formatted(returnType, bodyType));
                                              symbolTable.addMacro(new Macro(id, params, body, BasicSyntaxType.Invalid()), startLoc.join(loc()));
                                          } else {
                                              symbolTable.addMacro(new Macro(id, params, body, returnType), startLoc.join(loc()));
                                          }
                                         .)
  .

  syntaxType<out SyntaxType type>
  = basicSyntaxType<out type>
  .

  basicSyntaxType<out BasicSyntaxType type> (. type = null; .)
  = T_STATS                                 (. type = BasicSyntaxType.Stats(); .)
  | T_STAT                                  (. type = BasicSyntaxType.Stat(); .)
  | T_ENCS                                  (. type = BasicSyntaxType.Encs(); .)
  | T_ISA_DEFS                              (. type = BasicSyntaxType.IsaDefs(); .)
  | T_EX                                    (. type = BasicSyntaxType.Ex(); .)
  | T_LIT                                   (. type = BasicSyntaxType.Lit(); .)
  | T_STR                                   (. type = BasicSyntaxType.Str(); .)
  | T_VAL                                   (. type = BasicSyntaxType.Val(); .)
  | T_BOOL                                  (. type = BasicSyntaxType.Bool(); .)
  | T_INT                                   (. type = BasicSyntaxType.Int(); .)
  | T_BIN                                   (. type = BasicSyntaxType.Bin(); .)
  | T_CALL_EX                               (. type = BasicSyntaxType.CallEx(); .)
  | T_SYM_EX                                (. type = BasicSyntaxType.SymEx(); .)
  | T_ID                                    (. type = BasicSyntaxType.Id(); .)
  | T_BIN_OP                                (. type = BasicSyntaxType.BinOp(); .)
  | T_UN_OP                                 (. type = BasicSyntaxType.UnOp(); .)
  .



END vadl.
