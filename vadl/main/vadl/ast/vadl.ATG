$package=vadl.ast
import java.util.ArrayList;
import java.util.List;

import vadl.ast.Ast;
import vadl.ast.Expr;
import vadl.ast.Stmt;


COMPILER vadl
    Ast ast = new Ast();
    SymbolTable symbolTable = new SymbolTable();

    Location locationFromToken(Token token) {
        return new Location("unknown.vadl", token.line,  token.line, token.col, token.col + token.val.length());
    }



CHARACTERS
    digit = '0' .. '9'.
    letter = 'a' .. 'z' + 'A' .. 'Z'.

TOKENS
    number = digit {digit}.
    identifierToken = letter {letter | digit}.

COMMENTS FROM "//" TO '\n'
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\t' + '\r' + '\n'


PRODUCTIONS
    vadl =
    {
        definition<out Definition definition>   (. ast.definitions.add(definition); .)
    }.

    // -- DEFINITIONS --------------------------------------------------------------------------------------------------
    definition<out Definition definition>                               (. definition = null; .)
    = instructionsetDefinition<out InstructionSetDefinition isaDef>     (. definition = isaDef; .)
    | commonDefinition<out CommonDefinition commonDef>                  (. definition = commonDef; .)
    .

    commonDefinition<out CommonDefinition common>
    = statement<out Stmt stmt>      (. var statements = new ArrayList<Stmt>(List.of(stmt)); .)
      {
        statement<out Stmt stmt2>     (. statements.add(stmt2); .)
      } (. common = new CommonDefinition(statements); .)
    .

    instructionsetDefinition<out InstructionSetDefinition isaDef> (. var statements = new ArrayList<Stmt>(); .)
    = "instruction" (. var startLocation = locationFromToken(t);.)
       "set" "architecture" identifier<out Identifier identifier>
       "=" "{"
      {
        // FIXME: In the future this will be wrong as not all statements should be accepted here.
        statement<out Stmt stmt>    (. statements.add(stmt); .)
      }
      "}"   (. isaDef = new InstructionSetDefinition(identifier, statements, new Location(startLocation, locationFromToken(t))); .)
      .


    // -- STATEMENTS ---------------------------------------------------------------------------------------------------
    statement<out Stmt stmt>
    = "constant" (. var startLocation = locationFromToken(t); .)
        identifier<out Identifier id>       (. symbolTable.addDefinition(id); .)
        '=' expression<out Expr expr>       (. stmt = new ConstantDefinitionStmt(id, expr, new Location(startLocation, locationFromToken(t))); .)
    .

    // -- EXPRESSIONS ---------------------------------------------------------------------------------------------------
    expression<out Expr expr>
    = term<out Expr expr1>  (. expr = expr1; .)
    .

    term<out Expr expr>
    = factor<out Expr expr1>                   (. expr = expr1; .)
        {
            '+' factor<out Expr expr2>         (. expr = new BinaryExpr(expr, BinaryExpr.Operation.ADD, expr2); .)
        |   '-' factor<out Expr expr2>         (. expr = new BinaryExpr(expr, BinaryExpr.Operation.SUBTRACT, expr2); .)
        }
    .

    factor<out Expr expr>
    = primary<out Expr expr1>                 (. expr = expr1; .)
        {
            '*' primary<out Expr expr2>       (. expr = new BinaryExpr(expr, BinaryExpr.Operation.MULTIPLY, expr2); .)
        |   '/' primary<out Expr expr2>       (. expr = new BinaryExpr(expr, BinaryExpr.Operation.DIVIDE, expr2); .)
        }
    .

    primary<out Expr expr>                  (. expr = null; .)
    = number                                (. expr = new IntegerLiteral(Integer.parseInt(t.val), locationFromToken(t)); .)
    | identifier<out Identifier id>         (. expr = new Variable(id); symbolTable.addUsage(id); .)
    | '(' expression<out Expr expr1> ')'    (. expr = expr1; .)
    .

    identifier<out Identifier identifier> = identifierToken (. identifier = new Identifier(t.val, locationFromToken(t)); .)
    .

END vadl.
