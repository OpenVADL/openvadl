package vadl.gcb.passes.pseudo;


import com.google.common.collect.Streams;
import java.io.IOException;
import java.util.Arrays;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import vadl.configuration.GeneralConfiguration;
import vadl.error.DeferredDiagnosticStore;
import vadl.error.Diagnostic;
import vadl.pass.Pass;
import vadl.pass.PassResults;
import vadl.utils.Pair;
import vadl.viam.Constant;
import vadl.viam.Instruction;
import vadl.viam.PseudoInstruction;
import vadl.viam.Specification;
import vadl.viam.graph.Graph;
import vadl.viam.graph.HasRegisterFile;
import vadl.viam.graph.control.InstrCallNode;
import vadl.viam.graph.dependency.ConstantNode;
import vadl.viam.graph.dependency.ExpressionNode;
import vadl.viam.graph.dependency.FieldAccessRefNode;
import vadl.viam.graph.dependency.FuncParamNode;

/**
 * This pass replaces the arguments of a {@link Instruction} in a
 * {@link PseudoInstruction} with the parameters.
 * In the example below, {@code NOP} has one {@link Instruction} with
 * two registers and an immediate. This pass will copy the behavior
 * of {@code ADDI} and replace the arguments and returns the applied graph.
 * This applied graph will be used in the {@code PseudoExpansionFunctionGeneratorPass}
 * for the expansion of pseudo instructions.
 * <code>
 * pseudo instruction NOP =
 * {
 * ADDI{ rd = 0 as Bits5, rs1 = 0 as Bits5, imm = 0 as Bits12 }
 * }
 * </code>
 * Why is this class split up into two subclasses?
 * Because the {@link PseudoInstructionArgumentReplacementPass} is part of the gcb & cppCodeGen,
 * while {@code ConstMatPseudoInstructionArgumentReplacementPass} is part of the lcb and
 * the {@code ConstantMatPseudoInstruction} will be only generated by after the LLVM lowering.
 * The constant mat generation must be deferred at least until the IsaMatching because
 * they require an addition with immediate instruction.
 * Also note that the graph is not mutated, but the change is an extra result saved.
 */
public abstract class AbstractPseudoInstructionArgumentReplacementPass extends Pass {
  public AbstractPseudoInstructionArgumentReplacementPass(GeneralConfiguration configuration) {
    super(configuration);
  }

  /**
   * Output of the pass.
   */
  public record Output(
      IdentityHashMap<PseudoInstruction, Graph> appliedGraph) {

  }

  /**
   * Get the {@link PseudoInstruction} which the argument replacement should be applied on.
   */
  protected abstract Stream<PseudoInstruction> getApplicable(PassResults passResults,
                                                             Specification viam);

  @Nullable
  @Override
  public Output execute(PassResults passResults, Specification viam) throws IOException {
    var appliedGraph =
        new IdentityHashMap<PseudoInstruction, Graph>();

    getApplicable(passResults, viam).forEach(pseudoInstruction -> {
      var newPseudoBehavior = pseudoInstruction.behavior().copy();
      checkForWarnings(pseudoInstruction);

      for (var callNode : newPseudoBehavior.getNodes(InstrCallNode.class).toList()) {
        var machineInstructionBehavior = callNode.target().behavior().copy();
        applyArguments(callNode, machineInstructionBehavior);

        // Create new machine instruction which is essentially the same
        // except that the behavior is updated with the updated graph.
        var oldInstruction = callNode.target();
        var instruction = new Instruction(oldInstruction.identifier,
            machineInstructionBehavior,
            oldInstruction.assembly(),
            oldInstruction.encoding());
        callNode.setTarget(instruction);
      }

      appliedGraph.put(pseudoInstruction, newPseudoBehavior);
    });

    return new Output(appliedGraph);
  }

  /**
   * Apply given arguments of a {@link Instruction}.
   * <code>
   * pseudo instruction RET =
   * {
   * JALR{ rs1 = 1 as Bits5, rd = 0 as Bits5, imm = 0 as Bits12 }
   * }
   * </code>
   */
  private void applyArguments(InstrCallNode callNode, Graph machineInstructionBehavior) {
    Streams.zip(callNode.getParamFields().stream(), callNode.arguments().stream(),
            Pair::new)
        .forEach(app -> {
          // JALR{ rs1 = 1 as Bits5 ... }
          // rs1 is the formatField
          // argument is 1
          var formatField = app.left();
          var argument = indexArgument(callNode.arguments(), app.right());

          // Get all the fields in the instruction.
          machineInstructionBehavior.getNodes(FieldAccessRefNode.class)
              .filter(x -> x.fieldAccess().fieldRef().equals(formatField))
              .forEach(occurrence -> {
                // Edge case:
                // When we have the following pseudo instruction. Note that "r1" is replaced
                // by a constant. Sometimes, we need to create instruction selectors in TableGen,
                // and it requires a variable. However, if we replace the field by a constant
                // we lose the name of the variable because we have no field anymore.
                // {
                //     JALR{ rs1 = 1 as Bits5, rd = 0 as Bits5, imm = 0 as Bits12 }
                // }
                if(argument instanceof ConstantNode constantNode) {
                  checkIfRegisterIndexHasConstraintForValue(occurrence, constantNode.constant());
                }
                occurrence.replaceAndDelete(argument.copy());
              });
        });
  }

  /**
   * When you replace a field by a constant and the field is a register then it the used register
   * has to have a constraint. Otherwise, we cannot generate instruction selectors. It is
   * not really required to have those instruction selectors to make the compiler work, but
   * we emit a warning.
   * In the example, we have two registers {@code rs1} and {@code rd}. For {@code rs1} we set the
   * register index to {@code 1} which will create a warning because {@code X(1)} has no constraint.
   * However, {@code rd} is set to {@code 1} which is fine because {@code X(0)} has a constraint
   * in risc-v.
   * <code>
   * JALR{ rs1 = 1 as Bits5, rd = 0 as Bits5, imm = 0 as Bits12 }
   * </code>
   */
  private static void checkIfRegisterIndexHasConstraintForValue(FieldAccessRefNode occurrence,
                                                                Constant argument) {
    // The constantNode tells me the register index.

    // Go over the usages to emit warnings.
    // We need the usage because we need to find out what the register file
    // to check for constraints.
    occurrence.usages().filter(node -> (node instanceof HasRegisterFile))
        .forEach(node -> {
          var cast = (HasRegisterFile) node;

          var constraintValue =
              Arrays.stream(cast.registerFile().constraints()).filter(
                  c -> c.address().intValue()
                      == argument.asVal().intValue()).findFirst();

          if (constraintValue.isEmpty()) {
            DeferredDiagnosticStore.add(Diagnostic.warning(
                "There is no constraint value for this register. "
                    +
                    "Therefore, we cannot generate instruction selectors for it.",
                occurrence.sourceLocation()).build());
          }
        });
  }

  private static void checkForWarnings(PseudoInstruction pseudoInstruction) {
    if (pseudoInstruction.behavior().getNodes(InstrCallNode.class).toList().size() > 1) {
      DeferredDiagnosticStore.add(Diagnostic.warning(
          "Cannot generate instruction selectors for pseudo instruction with multiple "
              + "machine instructions", pseudoInstruction.sourceLocation()).build());
    }
  }


  /**
   * There are two relevant cases.
   * The first is that the {@code argument} is a constant. Then, we do not have to do anything.
   * The second case is when {@link PseudoInstruction} uses an {@code index}. Then, the argument
   * is replaced by a {@link FuncParamNode}. However, we still require to know the index for
   * the pseudo instance expansion. That's why we extend {@link FuncParamNode} with
   * {@link PseudoFuncParamNode} which has an {@code index} property.
   * Here is an example of the index. Note that {@code rs} will be transformed into
   * a {@link PseudoFuncParamNode} when it is replaced.
   * <code>
   * pseudo instruction BGEZ( rs : Index, offset : Bits<12> ) =
   * {
   * BGE{ rs1 = rs, rs2 = 0 as Bits5, imm = offset }
   * }
   * </code>
   */
  private ExpressionNode indexArgument(List<ExpressionNode> arguments, ExpressionNode argument) {
    if (argument instanceof FuncParamNode funcParamNode) {
      int index = arguments.indexOf(argument);
      return new PseudoFuncParamNode(funcParamNode.parameter(), index);
    }
    return argument;
  }
}
