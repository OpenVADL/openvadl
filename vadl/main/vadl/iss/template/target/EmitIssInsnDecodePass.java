package vadl.iss.template.target;

import java.util.Map;
import java.util.Objects;
import vadl.configuration.IssConfiguration;
import vadl.iss.passes.decode.QemuDecodeSymbolResolvingPass;
import vadl.iss.passes.decode.dto.ArgumentSet;
import vadl.iss.passes.decode.dto.Field;
import vadl.iss.passes.decode.dto.Format;
import vadl.iss.passes.decode.dto.Pattern;
import vadl.iss.passes.decode.dto.QemuDecodeResolveSymbolPassResult;
import vadl.iss.passes.decode.dto.RenderContext;
import vadl.iss.template.IssTemplateRenderingPass;
import vadl.pass.PassResults;
import vadl.viam.Specification;

/**
 * Emits the target/gen-arch/insn.decode that contains the decoding tree for the
 * given ISA.
 * This file is used during ISS compile time to generate a C decoder that calls
 * the correct translation functions for given instructions.
 */
public class EmitIssInsnDecodePass extends IssTemplateRenderingPass {
  public EmitIssInsnDecodePass(IssConfiguration configuration) {
    super(configuration);
  }

  public static final String HEADER_KEY = "decode_header";
  public static final String FIELDS_KEY = "decode_fields";
  public static final String ARGUMENT_SETS_KEY = "decode_argument_sets";
  public static final String FORMATS_KEY = "decode_formats";
  public static final String PATTERNS_KEY = "decode_patterns";

  public static final String CONTEXT_KEY = "decode_context";

  @Override
  protected String issTemplatePath() {
    return "target/gen-arch/insn-generated.decode";
  }

  @Override
  protected Map<String, Object> createVariables(PassResults passResults,
                                                Specification specification) {

    final Map<String, Object> variables = super.createVariables(passResults, specification);

    variables.put(HEADER_KEY, "# Generated by OpenVADL");

    final var passResult = passResults.lastResultOf(QemuDecodeSymbolResolvingPass.class);
    if (!(passResult instanceof QemuDecodeResolveSymbolPassResult qemuDefs)) {
      // Nothing to enrich
      return variables;
    }

    variables.put(FORMATS_KEY, qemuDefs.formats());
    variables.put(PATTERNS_KEY, qemuDefs.patterns());
    variables.put(ARGUMENT_SETS_KEY, qemuDefs.argSets());
    variables.put(FIELDS_KEY, qemuDefs.fields());

    // Prepare the formatting context for rendering

    final int maxPatternNameLength = qemuDefs.patterns().stream()
        .map(Pattern::getName)
        .filter(Objects::nonNull)
        .mapToInt(String::length).max().orElse(0);
    final int maxPatternBitLength = qemuDefs.patterns().stream()
        .mapToInt(p -> p.toBitPattern().length())
        .max().orElse(0);
    final int maxFormatNameLength = qemuDefs.formats().stream()
        .map(Format::getName)
        .filter(Objects::nonNull)
        .mapToInt(String::length).max().orElse(0);
    final int maxFormatBitLength = qemuDefs.formats().stream()
        .map(Format::toBitPattern)
        .mapToInt(String::length)
        .max().orElse(0);
    final int maxArgSetNameLength = qemuDefs.argSets().stream()
        .map(ArgumentSet::getName)
        .filter(Objects::nonNull)
        .mapToInt(String::length).max().orElse(0);
    final int maxFieldNameLength = qemuDefs.fields().stream()
        .map(Field::getName)
        .filter(Objects::nonNull)
        .mapToInt(String::length).max().orElse(0);
    final int maxFieldBitLength = qemuDefs.fields().stream()
        .mapToInt(f ->
            f.getSlices().stream()
                .mapToInt(s -> s.render(RenderContext.EMPTY).length()).sum() +
                f.getSlices().size() - 1)
        .max().orElse(0);

    final var context = new RenderContext(
        maxPatternNameLength,
        maxPatternBitLength,
        maxFormatNameLength,
        maxFormatBitLength,
        maxArgSetNameLength,
        maxFieldNameLength,
        maxFieldBitLength
    );

    variables.put(CONTEXT_KEY, context);

    return variables;
  }
}
