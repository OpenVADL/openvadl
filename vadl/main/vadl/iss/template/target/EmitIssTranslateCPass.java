// SPDX-FileCopyrightText : Â© 2025 TU Wien <vadl@tuwien.ac.at>
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package vadl.iss.template.target;

import static vadl.error.Diagnostic.error;

import com.google.common.collect.Streams;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import vadl.configuration.IssConfiguration;
import vadl.iss.template.IssRenderUtils;
import vadl.iss.template.IssTemplateRenderingPass;
import vadl.pass.PassResults;
import vadl.template.AbstractMultiTemplateRenderingPass;
import vadl.utils.Pair;
import vadl.utils.codegen.CodeGeneratorAppendable;
import vadl.utils.codegen.StringBuilderAppendable;
import vadl.viam.RegisterTensor;
import vadl.viam.Specification;

/**
 * Emits the target/gen-arch/translate.c includes the C files that contain the instruction
 * translation functions and are generated by the {@link EmitIssInsnTransCIncPass}.
 * It also contains the {@code gen_intermediate_code} function, called by QEMU as
 * entry point to start the TCG generation.
 */
public class EmitIssTranslateCPass extends IssTemplateRenderingPass {
  public EmitIssTranslateCPass(IssConfiguration configuration) {
    super(configuration);
  }

  @Override
  protected String issTemplatePath() {
    return "target/gen-arch/translate.c";
  }

  @Override
  protected Map<String, Object> createVariables(PassResults passResults,
                                                Specification specification) {
    var vars = super.createVariables(passResults, specification);
    vars.put("insn_width", getInstructionWidth(specification));
    vars.put("mem_word_size", getMemoryWordSize(specification));
    vars.put("trans_includes", translationIncludes(passResults));
    vars.put("tcg_v_init_code", genRegInitCode(specification));
    return vars;
  }

  /**
   * Gets translate functions.
   */
  private List<String> translationIncludes(PassResults results) {
    var insnTransResult = results.lastResultOf(EmitIssInsnTransCIncPass.class,
        AbstractMultiTemplateRenderingPass.Result.class);
    return insnTransResult.emittedFiles().stream()
        .map(p -> {
          var nameCount = p.getNameCount();
          return p.subpath(nameCount - 2, nameCount).toString();
        })
        .toList();
  }

  private static Map<String, Object> getMemoryWordSize(Specification specification) {
    var wordSize = specification.isa().get().ownMemories().get(0).wordSize();
    return Map.of(
        "int", wordSize
    );
  }

  private static Map<String, Object> getInstructionWidth(Specification specification) {
    var refFormat = specification.isa().get().ownInstructions()
        .get(0).format();
    var width = refFormat.type().bitWidth();

    return switch (width) {
      case 8 -> Map.of(
          "short", "b",
          "int", 8
      );
      case 16 -> Map.of(
          "short", "uw",
          "int", 16
      );
      case 32 -> Map.of(
          "short", "l",
          "int", 32
      );
      case 64 -> Map.of(
          "short", "q",
          "int", 64
      );
      default -> throw error("Invalid instruction width", refFormat.identifier.sourceLocation())
          .description(
              "The ISS generator requires that every instruction width "
                  + "is one of [8, 16, 32, 64], but found %s",
              width)
          .build();
    };
  }

  private String genRegInitCode(Specification specification) {
    var sb = new StringBuilderAppendable();
    var isa = specification.mip().get().isa();
    sb.indent();
    isa.registerTensors().forEach(tensor -> {
      regInitCode(sb, tensor);
      sb.append("\n");
    });
    return sb.toString();
  }

  private void regInitCode(CodeGeneratorAppendable sb, RegisterTensor reg) {
    var layers = reg.indexDimensions().stream()
        .map(d -> Pair.of("d" + d.index(), d.size()))
        .toList();
    var indexAccess = layers.stream().map(l -> "[" + l.left() + "]")
        .collect(Collectors.joining());

    var nameLower = reg.simpleName().toLowerCase();
    var targetUpper = configuration().targetName().toUpperCase();

    IssRenderUtils.generateNestedLoops(sb, layers, (b) -> {
      if (layers.isEmpty()) {
        b.append(
            "cpu_" + nameLower + " = tcg_global_mem_new(tcg_env, offsetof(CPU" + targetUpper
                + "State, " + nameLower + "), \"" + reg.simpleName() + "\");");
      } else {
        var target = configuration().targetName().toLowerCase();
        var names = target + "_cpu_" + nameLower + "_names";

        for (var c : reg.constraints()) {
          var check = genInitConstraintCheck(reg, c);
          b.appendLn("if (" + check + ") continue;");
        }

        // cpu_x[i] = tcg_global_mem_new(tcg_env,
        //       offsetof(CPURV64IMState, x[i]),
        //       rv64im_cpu_x_names[i]);
        b.append("cpu_" + nameLower + indexAccess + "= tcg_global_mem_new(tcg_env, ")
            .append("offsetof(CPU" + targetUpper + "State, " + nameLower + indexAccess + "), ")
            .append(names + indexAccess + ");");
      }
    });
  }

  private String genInitConstraintCheck(RegisterTensor reg, RegisterTensor.Constraint constraint) {
    return Streams.zip(constraint.indices().stream(),
            reg.indexDimensions().stream().limit(constraint.indices().size()),
            (index, dimension) -> "d" + dimension.index() + " == " + index.intValue())
        .collect(Collectors.joining(" && "));

  }


}
