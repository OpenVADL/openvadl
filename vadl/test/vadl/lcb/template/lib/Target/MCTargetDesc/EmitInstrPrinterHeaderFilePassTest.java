package vadl.lcb.template.lib.Target.MCTargetDesc;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalToIgnoringWhiteSpace;
import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.io.StringWriter;
import org.junit.jupiter.api.Test;
import vadl.gcb.valuetypes.ProcessorName;
import vadl.lcb.config.LcbConfiguration;
import vadl.utils.SourceLocation;
import vadl.viam.Identifier;
import vadl.viam.Specification;

class EmitInstrPrinterHeaderFilePassTest {

  private static LcbConfiguration createLcbConfiguration() {
    return new LcbConfiguration("");
  }

  @Test
  void shouldRenderTemplate() throws IOException {
    // Given
    var specification = new Specification(
        new Identifier("specificationValue", SourceLocation.INVALID_SOURCE_LOCATION));

    var template =
        new vadl.lcb.lib.Target.MCTargetDesc.EmitInstrPrinterHeaderFilePass(createLcbConfiguration(),
            new ProcessorName("processorNameValue"));
    var writer = new StringWriter();

    // When
    template.renderToString(specification, writer);
    var output = writer.toString();

    // Then
    assertThat(output, equalToIgnoringWhiteSpace("""
        #ifndef LLVM_LIB_TARGET_specificationValue_MCTARGETDESC_specificationValueINSTPRINTER_H
        #define LLVM_LIB_TARGET_specificationValue_MCTARGETDESC_specificationValueINSTPRINTER_H
               
        #include "AsmUtils.h"
        #include "llvm/ADT/StringRef.h"
        #include "llvm/MC/MCInstPrinter.h"
        #include "llvm/MC/MCInst.h"
        #include "llvm/MC/MCExpr.h"
        #include "llvm/MC/MCRegister.h"
        #include <string>
               
        namespace llvm
        {
            class specificationValueInstPrinter : public MCInstPrinter
            {
                virtual void anchor();
               
            public:
                specificationValue InstPrinter(const MCAsmInfo &MAI, const MCInstrInfo &MII, const MCRegisterInfo &MRI)
                    : MCInstPrinter(MAI, MII, MRI)
                {
                }
               
                void printInst(const MCInst *MI, uint64_t Address, StringRef Annot, const MCSubtargetInfo &STI, raw_ostream &O) override;
               
                void printRegName(raw_ostream & OS, MCRegister RegNo) const override;
               
                MCOperand adjustImmediateOp(const MCInst *MI, unsigned OpIndex) const;
               
               \s
                    void printCSRSystemRegister
                            ( const MCInst *MI
                            , unsigned OpNo
                            , raw_ostream &O
                            );
               \s
               
                ////
                // Autogenerated by tblgen.
                ////
                std::pair<const char *, uint64_t>
                getMnemonic(const MCInst *MI) override;
                void printInstruction(const MCInst *MI, uint64_t Address, raw_ostream &OS);
                static const char *getRegisterName(MCRegister Reg);
               
            private:
                std::string instToString(const MCInst *MI, uint64_t Address) const;
               
               \s
                std::string getRegisterNameFromXByIndex(unsigned RegIndex) const
                {
                    return AsmUtils::getRegisterNameFromXByIndex(RegIndex);
                }
               \s
            };
        }
               
        #endif // LLVM_LIB_TARGET_specificationValue_MCTARGETDESC_specificationValueINSTPRINTER_H 
        """));
  }

}